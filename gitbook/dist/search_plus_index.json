{"./":{"url":"./","title":"Introduction","keywords":"","body":"welcome doc 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-12 23:42:23 "},"笔记/HTML与CSS基础/JavaScript使用 Fetch.html":{"url":"笔记/HTML与CSS基础/JavaScript使用 Fetch.html","title":"JavaScript使用 Fetch","keywords":"","body":"JavaScript使用 Fetch 12019.07.11 14:28:15字数 2,245阅读 11,949 Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。 请注意，fetch规范与jQuery.ajax()主要有两种方式的不同，牢记： 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值 进行 fetch 请求 参考 一个基本的 fetch请求设置起来很简单。看看下面的代码： fetch('http://example.com/movies.json') .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); }); 这里我们通过网络获取一个JSON文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想fetch()到的资源路径，然后返回一个包含响应结果的promise(一个 Response 对象)。 当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json()方法（在Bodymixin 中定义，被 Request 和 Response 对象实现）。 注意：Body mixin 还有其他相似的方法，用于获取其他类型的内容。参考 Body。 最好使用符合内容安全策略 (CSP)的链接而不是使用直接指向资源地址的方式来进行Fetch的请求。 支持的请求参数参考 fetch() 接受第二个可选参数，一个可以控制不同配置的 init 对象： 参考 fetch()，查看所有可选的配置和更多描述。 // Example POST method implementation: postData('http://example.com/answer', {answer: 42}) .then(data => console.log(data)) // JSON from `response.json()` call .catch(error => console.error(error)) function postData(url, data) { // Default options are marked with * return fetch(url, { body: JSON.stringify(data), // must match 'Content-Type' header cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached credentials: 'same-origin', // include, same-origin, *omit headers: { 'user-agent': 'Mozilla/4.0 MDN Example', 'content-type': 'application/json' }, method: 'POST', // *GET, POST, PUT, DELETE, etc. mode: 'cors', // no-cors, cors, *same-origin redirect: 'follow', // manual, *follow, error referrer: 'no-referrer', // *client, no-referrer }) .then(response => response.json()) // parses response to JSON } 发送带凭据的请求参考 为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: 'include'添加到传递给 fetch()方法的init对象。 fetch('https://example.com', { credentials: 'include' }) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加credentials: 'same-origin'。 // The calling script is on the origin 'https://example.com' fetch('https://example.com', { credentials: 'same-origin' }) 要改为确保浏览器不在请求中包含凭据，请使用credentials: 'omit'。 fetch('https://example.com', { credentials: 'omit' }) 上传 JSON 数据参考 使用 fetch() POST JSON数据 var url = 'https://example.com/profile'; var data = {username: 'example'}; fetch(url, { method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or {object}! headers: new Headers({ 'Content-Type': 'application/json' }) }).then(res => res.json()) .catch(error => console.error('Error:', error)) .then(response => console.log('Success:', response)); 上传文件参考 可以通过HTML元素，FormData() 和fetch()上传文件。 var formData = new FormData(); var fileField = document.querySelector(\"input[type='file']\"); formData.append('username', 'abc123'); formData.append('avatar', fileField.files[0]); fetch('https://example.com/profile/avatar', { method: 'PUT', body: formData }) .then(response => response.json()) .catch(error => console.error('Error:', error)) .then(response => console.log('Success:', response)); 上传多个文件参考 可以通过HTML元素，FormData() 和fetch()上传文件。 var formData = new FormData(); var photos = document.querySelector(\"input[type='file'][multiple]\"); formData.append('title', 'My Vegas Vacation'); formData.append('photos', photos.files); fetch('https://example.com/posts', { method: 'POST', body: formData }) .then(response => response.json()) .then(response => console.log('Success:', JSON.stringify(response))) .catch(error => console.error('Error:', error)); 检测请求是否成功参考 如果遇到网络故障，fetch() promise 将会 reject，带上一个 TypeError 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。想要精确的判断 fetch() 是否成功，需要包含 promise resolved 的情况，此时再判断 Response.ok 是不是为 true。类似以下代码： fetch('flowers.jpg').then(function(response) { if(response.ok) { return response.blob(); } throw new Error('Network response was not ok.'); }).then(function(myBlob) { var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }).catch(function(error) { console.log('There has been a problem with your fetch operation: ', error.message); }); 自定义请求对象参考 除了传给 fetch() 一个资源的地址，你还可以通过使用 Request() 构造函数来创建一个 request 对象，然后再作为参数传给 fetch()： var myHeaders = new Headers(); var myInit = { method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' }; var myRequest = new Request('flowers.jpg', myInit); fetch(myRequest).then(function(response) { return response.blob(); }).then(function(myBlob) { var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }); Request() 和 fetch() 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝： var anotherRequest = new Request(myRequest,myInit); 这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 init 参数。 注意：clone() 方法也可以用于创建一个拷贝。它在语义上有一点不同于其他拷贝的方法。其他方法（比如拷贝一个 response）中，如果 request 的 body 已经被读取过，那么将执行失败，然而 clone() 则不会失败。 Headers参考 使用 Headers 的接口，你可以通过 Headers() 构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多名值对： var content = \"Hello World\"; var myHeaders = new Headers(); myHeaders.append(\"Content-Type\", \"text/plain\"); myHeaders.append(\"Content-Length\", content.length.toString()); myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以传一个多维数组或者对象字面量： myHeaders = new Headers({ \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\", }); 它的内容可以被获取： console.log(myHeaders.has(\"Content-Type\")); // true console.log(myHeaders.has(\"Set-Cookie\")); // false myHeaders.set(\"Content-Type\", \"text/html\"); myHeaders.append(\"X-Custom-Header\", \"AnotherValue\"); console.log(myHeaders.get(\"Content-Length\")); // 11 console.log(myHeaders.getAll(\"X-Custom-Header\")); // [\"ProcessThisImmediately\", \"AnotherValue\"] myHeaders.delete(\"X-Custom-Header\"); console.log(myHeaders.getAll(\"X-Custom-Header\")); // [ ] 虽然一些操作只能在 ServiceWorkers 中使用，但是它提供了更方便的操作 Headers 的 API。 如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出 TypeError 异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如： var myResponse = Response.error(); try { myResponse.headers.set(\"Origin\", \"http://mybank.com\"); } catch(e) { console.log(\"Cannot pretend to be a bank!\"); } 最佳实践是在使用之前检查 content type 是否正确，比如： fetch(myRequest).then(function(response) { if(response.headers.get(\"content-type\") === \"application/json\") { return response.json().then(function(json) { // process your JSON further }); } else { console.log(\"Oops, we haven't got JSON!\"); } }); Guard参考 由于 Headers 可以在 request 请求中被发送或者在 response 请求中被接收，并且规定了哪些参数是可写的，Headers 对象有一个特殊的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。 可能的值如下： none：默认的 request：从 request 中获得的 headers（Request.headers）只读 request-no-cors：从不同域（Request.mode no-cors）的 request 中获得的 headers 只读 response：从 response 中获得的 headers（Response.headers）只读 immutable：在 ServiceWorkers 中最常用的，所有的 headers 都只读。 注意：你不可以添加或者修改一个 guard 属性是 request 的 Request Headers 的 Content-Length 属性。同样地，插入 Set-Cookie 属性到一个 response headers 是不允许的，因此 ServiceWorkers 是不能给合成的 Response 的 headers 添加一些 cookies。 Response 对象参考 如上述, Response 实例是在 fetch() 处理完promises之后返回的。 你会用到的最常见的response属性有: Response.status — 整数(默认值为200) 为response的状态码. Response.statusText — 字符串(默认值为\"OK\"),该值与HTTP状态码消息对应. Response.ok — 如上所示, 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个Boolean值. 它的实例也可用通过 JavaScript 来创建, 但只有在ServiceWorkers中才真正有用,当使用respondWith()方法并提供了一个自定义的response来接受request时: var myBody = new Blob(); addEventListener('fetch', function(event) { event.respondWith(new Response(myBody, { headers: { \"Content-Type\" : \"text/plain\" } }); }); Response() 构造方法接受两个可选参数—response的数据体和一个初始化对象(与Request()所接受的init参数类似.) 注意: 静态方法error()只是返回了一个错误的response. 与此类似地, redirect() 只是返回了一个可以重定向至某URL的response. 这些也只与Service Workers才有关。 Body参考 不管是请求还是响应都能够包含body对象. body也可以是以下任意类型的实例. ArrayBuffer ArrayBufferView (Uint8Array等) Blob/File string URLSearchParams [FormData](https://www.jianshu.com/p/[https://developer.mozilla.org/zh-CN/docs/Web/API/FormData](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFormData) \"FormData 接口提供了一种表示表单数据的键值对的构造方式，经过它的数据可以使用 XMLHttpRequest.send() 方法送出，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 \"multipart/form-data\"，它会使用和表单一样的格式。\") Body 类定义了以下方法 (这些方法都被 Request 和Response所实现)以获取body内容. 这些方法都会返回一个被解析后的Promise对象和数据. arrayBuffer() blob() json() [text()](https://www.jianshu.com/p/[https://developer.mozilla.org/zh-CN/docs/Web/API/Body/text](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBody%2Ftext) \"Body混入的 text() 方法提供了一个可供读取的\"返回流\", ——它返回一个包含USVString对象 (text)的Promise对象，返回结果的编码为UTF-8。\") formData() 比起XHR来，这些方法让非文本化的数据使用起来更加简单。 请求体可以由传入body参数来进行设置: var form = new FormData(document.getElementById('login-form')); fetch(\"/login\", { method: \"POST\", body: form }) request和response（包括fetch() 方法）都会试着自动设置Content-Type。如果没有设置Content-Type值，发送的请求也会自动设值。 特性检测参考 Fetch API 的支持情况，可以通过检测Headers, Request, Response 或 fetch()是否在Window 或 Worker 域中。例如： if(self.fetch) { // run my fetch request here } else { // do something with XMLHttpRequest? } 原文链接：https://www.cnblogs.com/libin-1/p/6853677.html 原文链接：... 原文链接：https://www.cnblogs.com/libin-1/p/6853677.html 这个也看看... 我们在项目中经常会用到HTTP请求来访问网络，HTTP(HTTPS)请求通常分为\"GET\"、\"PUT\"、\"POST... 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-13 21:44:33 "},"笔记/HTML与CSS基础/h5笔记.html":{"url":"笔记/HTML与CSS基础/h5笔记.html","title":"H5笔记","keywords":"","body":"笔记 CSS哪些属性可以继承哪些不可继承 可继承属性： 1.字体系列属性 font:组合字体 font-family:规定元素的字体系列 font-weight:设置字体的粗细 font-size:设置字体的尺寸 font-style:定义字体的风格 font-variant:偏大或偏小的字体 2.文本系列属性 text-indent:文本缩进 text-align:文本水平对刘 line-height:行高 word-spacing:增加或减少单词间的空白 letter-spacing：增加或减少字符间的空白 text-transform:控制文本大小写 direction:规定文本的书写方向 color:文本颜色 3.元素可见性 visibility 4.表格布局属性 caption-side定位表格标题位置 border-collapse合并表格边框 border-spacing设置相邻单元格的边框间的距离 empty-cells单元格的边框的出现与消失 table-layout表格的宽度由什么决定 5.列表布局属性 list-style-type文字前面的小点点样式 list-style-position小点点位置 list-style以上的属性可通过这属性集合 6.引用 quotes设置嵌套引用的引号类型 7.光标属性 cursor:箭头可以变成需要的形状 不可继承属性 1.displey 2.文本属性 vertical-align:垂直文本对齐 text-decoration:规定添加到文本的装饰 text-shadow:文本阴影效果 white-space:空白符的处理 3.盒子模型属性 width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4.背景属性 background、background-color、background-image、background-repeat、background-position、background-attachment 5.定位属性 float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index CSS优先级算法 1.原则 使用就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 2.优先级 同权重下： 内联样式(标签内部) > 嵌入样式表(当前文件中) > 外部样式表(外部文件中) （在实际代码中发现嵌入样式表优先级并没有大于外部样式表，而是后面的覆盖前面的） ！import > id > class >tag 备注：important比内联优先级高 元素居中 1.position：absolute； top:0;bottom:0;left:0;right:0; margin:auto; 2.position:absolute; top:50%;left:50%; margin:width的一半 height的一半 3.position:absolute; top:50%;left:50%; transform:translate(-50%,-50%); 4.display:flex; justify-content:center; align-items:center; week1 day01-课程简介 一、腾讯会议 1、每天上课共享使用，通过它看到老师的屏幕 2、连接方式：会议号：736 284 7423 密码：438679 二、飞秋使用 飞秋介绍： 1、飞秋它的功能和QQ还有微信是类似的，不同的是飞秋是局域网软件，不需要上外网下载速度会快一些 2、飞秋的版本2013版本的，这个版本是比较稳定的，最新的版本实际上不需要下载 3、作用：每天大家使用它下载资料 飞秋的具体使用 1、如果你电脑关过机或者断过网，有可能获取不到最新的消息和资料，这个时候不只需要刷新下飞秋就可以 2、获取资料和代码还有视频 第一步： 第二步： 3、如果遇到同学没有飞秋群里面可以做以下操作 第一步： 第二步: 三、前端 1、什么是前端？前端就是根据UI小姐姐给的设计稿使用代码的形式还原成网页 2、前端和H5有什么关系呢？ 以前的时候，前端能的做的东西非常的少，在公司里面的地位非常低，创造的价值没有其他的专业大，所以大家都把前端叫做页面仔或者切图仔，公司里面其实很少有专门做前端的人员，基本上都是后端人员兼职的做的 随着技术的发展，前端能做的东西越来越多了，甚至可以做后端的东西了，主要是由于HTML5（H5）标准的出现，导致行业技术巨变。前面前端人员非常少，现在的市场需要一下子就爆发了 HTML5指的是一项技术，前端指的是岗位，由于之前大家对前端的刻板的影响，所以有人提出了以H5作为前端的重新的名称，大树底下好乘凉 HTML5技术火了后，大家慢慢改变了对前端的认知，所以现在把HTML5称之为前端工程师或者H5工程师其实都是一回事儿 3、一个完整的网站包含两个部分，前端、后端（后台） 4、前端需要学习那些语言？ html css JavaScript（js） 前端具有唯一性，无论开发什么样的软件都需要界面，有界面的就需要前端。网站分为pc端还有移动端，电视应用，爱奇艺、优酷、芒果TV等等，游戏有界面、小程序 更新换代速度快 5、后端语言有哪些？ java（稳定）、python、php、Go、C#、c（嵌入式）、c++、node.js、.net、asp等等 后端主要和服务器还有数据库打交道。 服务器：它其实也是一台电脑，只不过它的配置和性能比普通电脑高不知道多少倍，一天24小时不能断电 服务器作用：存储数据和处理数据。网站还有软件都是放在服务器上面，要不然其他人访问不了 四、PS简单操作 1、快捷键 ctrl+O 打开文件 ctrl++ 放大 ctrl-- 缩小 缩放图片：按下alt+鼠标滚轮，也可以进行缩放图片的操作 拖动图片：点击空格键，当鼠标变成小手后，使用鼠标左键按着图片进行移动即可 量取尺寸：使用矩形选框工具 --- 先选中目标区域 --- 查看信息（宽度width和高度height，点击F8，如果F8快捷键不起作用不要纠结，直接找到窗口选项里面的信息点击即可）W表示宽度，H表示高度 修改PS默认单位：默认单位cm，修改成px（像素，网页单位） 第一步： 第二步： 调整矩形选框工具的选取位置：鼠标放在选取上面 --- 鼠标右键 --- 变换选取 --- 调整好 --- 直接回车 截图：使用矩形选框工具选中目标区域 --- 鼠标右键变换选取进行微调 --- ctrl+C（复制）--- ctrl+N（新建，注意点，不需要修改任何信息）--- ctrl—V（粘贴）--- 存储为web所用格式（可以修改大小，修改图片格式）--- 保存即可 吸取颜色值：使用吸管工具 --- 选中目标直接点击吸取 --- 找到取色器（前景色）--- 直接复制（颜色值默认是16进制 0-F 数字和字母的组合，#号是复制不上，需要自己手动添加）例如：#00ce41 五、DW简单使用 1、DW是代码编辑器，可以关闭代码提示，即使你开着代码提示，提示也非常少 2、公司里面更多的情况下使用vscode、hburlderX、sublime text这些工具，为什么还要使用更古老的DW呢？一开始学习的话，直接使用这些带有大量代码提示的工具，其实你能做出很多东西来，一旦离开工具你什么都没有记住，为了巩固学习成果一阶段前两周教学统一使用DW工具 3、DW操作 新建文件，第一种方式： 新建文件，第二种使用快捷键方式ctrl+N 进入新建文件后，默认在设计选项里面，需要点击代码选项 点击ctrl+S保存页面，后缀名为.html的文件（文档），表示的是网页类型的文件。有些同学看到的网页图标是谷歌的还有其他的，跟自己的默认浏览器相关 修改编辑器的字体大小，找到亲爱的小球 --- 选择编辑浏览器列表 --- 左边的选项里面找到字体 --- 要修改一起修改 关闭代码提示，找到亲爱的小球 --- 选择编辑浏览器列表 --- 左边的选项里面找到代码提示 --- 根据以下操作 day02-H5简介 一、学习建议 1、刚开始学习时，对于新手来说，先不要想那么多，做的比想的多 2、编程是慢慢积累而来的，不是一开始你立马变得很厉害的样子 3、摆正心态，先认识再练习然后理解 二、建站流程 1、所谓的建站流程就是一个网站从开发到上线能正常使用的过程 2、过程 域名注册：域名，其实就是网址（https//www.jd.com），网址理解为一个地址，作用是帮助咱们找到对应的网站 购买服务器： 把网站开发好以后放在对应的服务器上面，这样别人才能通过网络进行有效的访问 虚拟云主机，正常的服务器的价格是非常贵的，普通使用是没有必要花那么多钱的，所以有人就提出了虚拟服务器，钱节省了，你自己不需要去维护 购买网站：新网、西部数码、万网（阿里云）、腾讯云、百度云、华为云、新浪云等等 网站建设：确定网站主题、规划网站、搜集资料、制作页面（跟前端有关） 网站推广 网站维护 三、HTML语言 1、web标准，指的是网页制作要遵循的规范，在这个规范下有三个语言，分别是html（结构）、css（表现---样式）、JavaScript（js---行为） 2、html的作用是搭建网页的结构，css是用来美化html结构的，js是让网页有动态效果 3、html超文本标记语言 文本：指的是文字，文字不仅仅指的是英文、还包含中文还有其他语言 超文本：人加一个超，是超人，超人和人的区别是什么？内裤外穿，超人具有一些人没有的能力。超文本指的是网页中除了文本以外的其他东西，例如，超链接、图片、音频、视频、程序等等 标记：记号、标识，告诉你这个东西是什么意思 四、注释 1、什么是注释？注释就是语言里面提供给咱们作为解释代码意思的一个\"工具\" 2、注释特点，浏览器不识别它，写给自己看的 3、语法： 注意点：注释中间的杠可以有很多个，但是不能少于四个 五、HTML5基本结构 1、html5基本结构是html语言执行的一个环境 2、结构语法： 欢迎来到肖宇真爱有缘网 这是html语言的基本结构 3、乱码： 注意点：如果没有设置meta标记的话，在低版本的浏览器里面会出现乱码问题 六、HTML语法 1、html语法分为两种，常规（对儿、双）标记、单（空）标记 常规标记： 单标记： 2、说明： 把尖括号（<>）里面的第一个单词叫做标记、标签、元素 把尖括号里面的标记空格后面的单词称之为属性，属性和属性值是使用等号连接的，属性值是放在双引号里面。一个标记可以有多个属性，也可以没有属性。有多个属性的时候，属性和属性之间不分先后顺序 单标记必须使用斜杠结束 七、站点 1、站点其实就是归纳网站里面素材的地方 2、站点目录结构 目录结构解释： css文件夹，放css文件的地方 html文件夹，放子页面的地方 images文件夹，放图片的地方 js文件夹，放js文件的地方 index.html 主页面（首页） 注意点：首页必须命名为index，不然上传到服务器上面会不识别 3、命名规则 文件命名规则：用英文，不用中文 名称全部用小写英文字母、数字、下划线的组合，其中不得包含汉字、空格和特殊字符；必须以英文字母开头 首页必须命名为index.html 八、常用标记 基本标记 1、标记是告诉浏览器这个东西是什么意思，不是让你知道，因为学习的是计算机语言 2、h1-h6 标题 + h1一级标题一个网页中只能有一个，搜索权重比较高的 + 特点：独占一行，自上而下排列的 + 属性：align=\"left|center|right\" 文本水平对齐方式 3、p 段落 + 特点：独占一行，自上而下排列的 + 属性：align=\"left|center|right\" 文本水平对齐方式 4、br 换行 + 单标记 + 特点：独占一行，自上而下排列的 5、hr 水平线 + 单标记 + 特点：独占一行，自上而下排列的 + 属性：color=\"颜色值\" 水平线的颜色 6、em、i 倾斜 + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 7、b、strong 加粗 + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 8、预留字符 + 带有某种功能的符号 + &nbsp; 表示空格 + &times; 乘号 + &lt; 小于 + &gt; 大于 + &copy; 版权符号 圈c 列表标记 9、列表标记 a、导航、新闻 b、列表标记三大类 + 无序列表 ul li + 在实际开发中使用最多的 + 有序列表 ol li + 属性：type=\"number|A|a|I\" 列表符号类型 + 自定义列表 dl dt dd + dl dt放的是名词或者是图片 dd放的是解释 + 如果遇到标记嵌套标记的情况，把外层的标记称之为父标记（元素），里面的标记叫做子标记（元素） + 特点：独占一行，自上而下排列的 列表标记示例代码 千里跃进之挑战不可能 实现中华民族伟大复兴 胸怀千秋伟业 恰是百年风华 百年正道 专题 新华网评：今天的中国，多希望你们能看到 千里跃进之挑战不可能 实现中华民族伟大复兴 胸怀千秋伟业 恰是百年风华 百年正道 专题 新华网评：今天的中国，多希望你们能看到 美女 闭月羞花，沉鱼落雁。。。 日本美女 嘿嘿！肖宇最懂 超链接标记 10、a超链接 + 可以让咱们点击文本的时候进行页面跳转 + 属性：href=\"地址\" 要跳转的地址（路径） target=\"_blank|_self\" 新窗口打开 _blank 当前窗口（默认）_self + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 超链接示例代码 百度一下，还是不知道 东哥最喜欢奶茶 图片标记 11、img图片标记 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格。单标记 属性： + src 路径 + width 宽度 + height 高度 + title 标题，当鼠标悬停在图片上面的时候显示，默认是隐藏的 + alt 提示信息，当图片由于某种特殊（路径错误、网络比较慢、被和谐了）原因无法加载的时候给用户一个提示 路径问题 + 绝对路径，带有盘符的路径、或者网络地址 + 相对路径，在一个大的目录下，分级进行操作 + 当前文件指的是网页，目标文件指的是图片 + ./表示当前目录（可以省略） ../表示返回上一级目录 a、当当前文件与目标文件在同一目录下时，直接写目标文件名+扩展名 b、当当前文件与目标文件的文件夹在同一目录下时，先写目标文件夹名/目标文件名+扩展名 c、当当前文件的文件夹与目标文件的文件夹在同一目录下时，先../目标文件夹名/目标文件名+扩展名 表格标记 12、table表格标记 + 特点：独占一行，自上而下排列的 + 表格作用：显示数据，后台页面使用比较多 + 表格组成：table tr（行） td（列---单元格） + 属性： border 边框 width 宽度 height 高度 align=\"left|center|right\" 水平对齐方式使用规则 a、如果设置在table上面表示的是整个表格的水平对齐方式 b、如果设置在tr上面表示整行的水平对齐方式 c、如果设置在td上面表示单元格的水平对齐方式 valign=\"top|middle|bottom\" 垂直对齐方式 不能给table设置 bgcolor背景颜色 使用规则： a、如果设置在table上面表示的是整个表格的背景颜色 b、如果设置在tr上面表示整行的背景颜色 c、如果设置在td上面表示单元格的背景颜色 bordercolor 边框颜色 只能给table设置 cellspacing 表示单元格与单元格之间的间隙 cellpadding 表示单元格内容到边框之间的距离 rowspan 合并行 合并上下 colspan 合并列 合并左右 day03-form表单、网页标记 一、form表单标记 1、form标记 作用：收集用户信息，发送给服务器 特点：form是独占一行，自上而下排列的 属性： name 表单的名称，用于区分不同的表单 method 表单提交方式 get post action 表单提交地址，在实际开发中是一个后台地址（login.php） 注意点：表单必须配合其他的表单标记一起使用 2、get和post区别 get是从服务器上面获取数据（百度搜索、其他网站搜索），post是向服务器传输数据（登陆、注册） get是没有经过加密的，所以安全性没有post高，post是通过http post机制加密过所以比较安全 get传输的数据在url（浏览器的地址栏）里面可以看得到，而post是看不见的 get传输的数据量有限定（一般2kb左右），post理论是没有限定的。get执行效率比post高 get数据量示意图: 3、input标记 input标记有不同的类型 input标记它的功能是由type属性的属性值决定的 特点：横向排列的 属性： name 表单的名称，为了区分不同的表单框 value 表单的值，表单默认显示的信息 placeholder 表单默认显示的信息 4、value和placeholder属性区别 value设置的信息，当用户输入内容的时候不会自动消失。value属性可以让js通过它拿到表单的内容 placeholder设置的信息，当用户输入内容的时候会自动消失。是H5标准里面新增的属性 5、表单标记 6、其他表单标记 肖宇真爱有缘网 欢迎张必聪来到，肖宇真爱有缘网 请花一分钟完善你的个人资料，请真实填写不能欺骗小姐姐 诚意宣言:&nbsp;我抱着严肃的态度，保证不偏财不偏财不骗人 我是: 男 女 生日： -请选择- 1990 1991 1992 年 -请选择- 1 2 3 月 -请选择- 1 2 3 日 兴趣爱好：吃饭 睡觉打豆豆 婚姻状况：未婚 离婚 丧偶 注册方式：手机注册 我的手机号: 验证码: 密码: 内容独白 按钮 二、网页布局标记 标记介绍 div网页布局标记 + 分割，区域。 + 特点：独占一行，自上而下排列的 + 作用：用于把网页划分成不同大小的区域，区块。主要用于网页结构的外层布局 浏览器控制台 + 浏览器控制台是浏览器提供给开发者的一个调试工具，可以在控制台里面可以看到源代码 + 打开控制台的方法 1、直接按下F12键，不能精确的定位需要的地方 2、把鼠标移动到目标区域，然后鼠标右键 --- 选择检查（审查元素）--- 点击进去 浏览器控制台示意图 三、文本结点标记 span文本结点标记 + 主要用于某个段落里面某个字或者词区分 + 特点：横向排列的 + 最大好处是自身没有带任何默认的样式 示例代码 html结构代码 警校生公交上抓贼被威胁后霸气回怼。近日，湖北一公交车上，女子发现钱包被偷，一中国人民公安大学学生挺身而出抓住小偷。面对小偷威胁，学生呵斥 css样式代码 span{font-size:30px;color:red;} 四、css介绍和语法 css层叠样式表 + 层叠在css里面表示的是规则，指的是css里面的一些规则 + 样式表，是css给咱们提供的编写css代码的一个环境。html和css是两个不同的语言，每个语言执行都有自己的规范，也需要自己的环境，样式就是css代码执行环境，也可以理解为是html和css代码之间沟通的一个\"桥梁\" + css是web表现标准语言，web标准指的是网页制作要遵循的规范，html结构、css是表现（样式）、js（行为） + css的作用是对网页信息显示进行控制，网页信息，文本、图片、音频、视频、超链接等等，无论是图片还是文字都是放在html里面的。解释，css的作用就是美化html标记使用的 css语法 + css语法由两部分组成，选择器（选择符）和声明组成 + 选择器表示要定义样式的对象（理解：你给谁加样式，谁就是那个对象），可以是标记名称也可以取名称的标记。选择器就是把标记选取出来给其设置样式，也一个\"小工具\" + 声明分为属性和属性值，属性和属性值是使用冒号连接的，分号结束的。当一个属性有多个属性值的时候，不分先后顺序 + 声明必须放在花括号里面 + 属性和属性之间换行空格不影响实际的效果 + 注意点：html属性和css属性不能混用 语法示意图 五、css样式表 1、内部样式表 通过一个style标记，在style标记内部编写css代码，style标记的作用就是执行css代码 属性：type=\"text/css\" 定义文档类型 可以省略，但是不能写错 适用于代码量较少的时候使用 代码示意图 div{ width:200px; height:200px; background-color:hotpink; } 2、外部样式表 通过一个link标记，引入一个外部的css文件，在css文件里面编写css代码 属性： rel=\"stylesheet\" 关联样式表，就是把html文件和css文件连接起来 type=\"text/css\" 定义文档类型 可以省略，但是不能写错 href=\"地址\" 路径 适用于代码量较多的时候，实际开发中使用最多的 代码示意图 3、内联样式表 内联样式表也叫行内样式表 通过一个style属性，在属性值里面编写css代码 偶尔使用 代码示意图 网页布局使用的 4、样式位置问题 代码是自上而下执行的，在本地环境下设置在头部区域或者其他区域是看不出效果的，如果在服务器环境下可以看出区别 在实际的开发中推荐设置head区域 六、选择器 1、选择器表示要定义样式的对象，可以是标记本身也可以是标记取名称。css给咱们提供了很多种选择器，帮助咱们解决各种冲突和问题 2、标记选择器（标签）、类型选择器 + 语法：标记{} + 可以给同一类型的标记都设置样式 3、class选择器 + 语法: css：.名称{} html： + 通过取名区分同一类型的标记，限定了样式起作用的范围 + class可以取多个名称 4、id选择器 + 语法: css：#名称{} html： + id选择器具有唯一性，一个标记对应的只能有一个id名称 5、包含（后代）选择器 + 语法: css：标记1 标记2{} html: + 限定样式起作用的范围 七、权重 + 权重是选择器的规则 + 权重是每一种选择器自带的一种特性，这种特性可以用于解决样式冲突问题 + 权重默认是以四位数表示 0 0 0 0 + 标记选择器权重：0 0 0 1 + class选择器权重：0 0 1 0 + id选择器权重：0 1 0 0 + 后代（包含）选择器权重：包含选择器之和 + 伪类选择器权重：0 0 1 0 + 内联样式表的权重：1 0 0 0 + 通配符的权重：0 0 0 0 通配符对权重没有贡献 + 权重具有就近原则 day04-css、选择器 一、css层叠性 概念：一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则， 这就是层叠。 这些规则中有些是没有冲突的可以同时起作用，然而有些规则是相互冲突的。当发生冲突的时候必须选出一条最高特殊性(权重)的规则来应用，以优先级高的权重为标准 注意点：在样式表里面叫做优先级，在选择器里面叫做权重 二、外部样式表补充 样式表分类 link标记直接引入外部css文件使用 结合内部样式表一起使用，然后引入外部css文件 import url() 样式表代码： @import url(css/a.css); link和import区别： 1、本质区别，link属于html（xhtml）提供的标记，而import属于css提供的一种方式 2、加载顺序，link可以让结构和样式同时加载，而import先加载结构再加载样式（跟代码顺序有关） 3、兼容问题，link是没有兼容问题的，import一些老版本的浏览器不支持（低版本的IE浏览器） 4、控制DOM（document object model 这是js给咱们提供操作标记的一种方式）时的区别，link可以被DOM操作或者控制，import无法被操作 三、HTML发展划分 从大范围进行划分，HTML是第一个版本，XHTML是第二个版本，HTML5是第三个版本（最新版本） HTML和XHTML的区别： XHTML是HTML的严格模式，语法更为规范或者严谨 XHTML区分大小写，标记必须闭合，声明文档类型更为复杂 XHTML要求必须有根标记 四、群组和伪类选择器 群组选择器 + 语法： css：选择器1,选择器2,选择器3...{} + 注意点：最后一个选择器不能有逗号 + 可以一次性给不同类型的标记设置样式 代码示意图 h1, p, span{color:red;} 伪类选择器 + 伪，假的意思。跟选择器很像但是又有区别 + 伪类其实描述的是某种状态 + 语法： a:link 鼠标的初始状态 a:visited 鼠标访问过后的状态 a:hover 鼠标悬停时的状态 使用最多的 a:active 鼠标激活（把鼠标按下去不动）时的状态 + 注意点：伪类选择器默认会把状态进行缓存，如果想要回到初始状态必须清除浏览器缓存才行 代码示意图 a:link{color:red;} a:visited{color:yellow;} a:hover{color:hotpink;} a:active{color:green;} 五、背景属性 + 分写形式 background-color 背景颜色 background-image:url(); 背景图 背景图显示规则： 1、当背景图小于容器大小时，背景图会默认平铺 2、当背景图大于容器大小时，背景图某些部分显示不完整 3、当背景图等于容器大小时，背景图刚好显示下 background-repeat:repeat（平铺）|no-repeat（不平铺）|repeat-x（水平平铺）|repeat-y（垂直平铺）; 平铺属性 background-position:left|center|right|top|bottom|number; 背景图位置属性 缩写形式 background-position-x 水平位置 background-position-y 垂直位置 background-attachment:fixed（固定）|scroll（滚动，默认值）; 背景图固定属性 + 缩写形式 background:值1 值2 值3 值4; 六、导航案例 效果图 css样式代码 /*清除内外边距*/ *{margin:0;padding:0;} ul{ width:800px; height:40px; background-color:#01204f; /*值1表示上下 值2表示左右*/ margin:0 auto; margin-top:50px; } ul li{ /*清除列表符号 li的点点*/ list-style:none; /*让竖着的东西横着排列*/ float:left; line-height:40px; font-size:14px; /*想要的效果是让元素左右有距离同时鼠标划过的时候让自身变大，padding表示的就是内容到元素边框的距离，填充*/ padding:0 10px; } ul li a{ /*清除超链接下划线*/ text-decoration:none; color:#fff; } ul .first{ padding-left:30px; background-color:#cc0000; background-image:url(images/icon.png); background-repeat:no-repeat; background-position:8px 8px; } /*当鼠标划过li标记时让其改变背景颜色*/ ul li:hover{ background-color:#cc0000; } html代码 首页 国内 军事 国际 财经 娱乐 体育 互联网 科技 游戏 女人 汽车 房产 七、margin和padding属性 margin和padding值书写形式 margin外边距（边界） + 指的是元素与元素之间的距离 + 分写值形式 margin-left 左边距 margin-right 右边距 margin-top 上边距 margin-bottom 下边距 + 缩写值形式 + margin:值1; 表示上右下左四个方向都一样 + margin:值1 值2; 值1表示上下 值2表示左右 + margin:值1 值2 值3; 值1表示上 值2表示左右 值3表示下 + margin:值1 值2 值3 值4; 值1表示上 值2表示由 值3表示下 值4表示左 padding内边距（填充、补白） + 指的是元素内容到边框之间的距离 + 控制的内容的位置，设置了padding属性后会把元素本身给撑大，如果想要保持元素原有大小不变，需要从元素上面减去设置的padding值。左右padding从宽度上减去，上下padding从高度上减去 + 分写值形式 padding-left 左边距 padding-right 右边距 padding-top 上边距 padding-bottom 下边距 + 缩写值形式 + padding:值1; 表示上右下左四个方向都一样 + padding:值1 值2; 值1表示上下 值2表示左右 + padding:值1 值2 值3; 值1表示上 值2表示左右 值3表示下 + padding:值1 值2 值3 值4; 值1表示上 值2表示由 值3表示下 值4表示左 + 元素的内容分为文本和标记 + 当子元素是独占一行，自上而下排列的。容器（父元素）设置了宽度，子元素没有设置宽度的时候，它的宽度会跟随容器 + padding使用注意事项： 1、当元素的内容是文本的时候，想要控制内容的位置只能使用padding 2、当元素的内容是标记的时候，既可以使用margin也可以使用padding怎么选择呢？那个简单使用那个 3、那种情况下使用了padding值不需要减去。当子元素是独占一行自上而下排列的，它没有设置宽度，它自身的宽度根据容器来的，这个时候使用了padding也不需要减去 标记结构信息图 八、网页注意事项 知识点1：当容器没有设置高度的时候，容器里面有图片的情况下，图片会默认把容器底部撑大几像素 知识点2：input标记会默认自带2px边框，input默认带有蓝色的轮廓。取消边框border:none|0; 取消轮廓：outline:none; 知识点3：横向排列的元素，在代码排列的时候手动换行后，元素与元素之间会默认有间隙。清除间隙 float:left; 知识点4：浏览器默认支持的最小文字大小是12px，如果小于12px以12px显示 知识点5：a超链接标记的文本颜色不能继承父元素的，只能设置在自身上面 九、PS标尺工具 ps标尺工具可以帮助咱们获取参考线，ctrl+R如果快捷键不起作用，找到视图---标尺就可以 day05元素类型 一、元素类型 在css里面默认把元素（标记）划分成了三个类型 + 块级元素 block + 特点：独占一行，自上而下排列的，可以设置宽度和高度 + div、h1-h6、ul、li、ol、form、p、hr、br、table、dl、dt、dd等等 + 注意点：块级元素如果子元素没有设置宽度，它的宽度默认会跟随容器（父元素） + 内联（行内）元素 inline + 特点：横向排列的，不能设置宽度和高度 + span、em、i、b、strong、font等等 + 注意点：内联元素设置了浮动属性后可以设置宽度和高度，因为float属性改变了span标记原有的规则 + 内联（行内）块元素 inline-block + 特点：横向排列的，可以设置宽度和高度 + input（text、password、checkbox、radio、submit、button）类型、select、textarea、img、button等等 week2 day06-浮动、清除浮动与margin-top问题 一、浮动介绍 语法： float:left|right|none; 作用：让竖着的东西横着来，可以让一行排列多个元素 定义：文本如何环绕该元素显示 环绕现象效果图 css样式代码 *{margin:0;padding:0;} .box{ width:600px; height:200px; border:1px solid red; margin:50px auto; padding:20px; } .box img{ width:100px; height:100px; float:left; margin:10px; } .box p{ font-size:14px; line-height:26px; } html结构代码 进入2021年以来，世界格局暗流涌动，瞬息万变。风云激荡之间，国际社会充斥着若隐若现的危机。 正所谓，多行不义必自毙，出来混迟早是要还的！一向在中东地区横行霸道——经济制裁伊朗、空袭叙利亚领土、偷盗叙利亚石油、给伊拉克带去常年战争的美国，最近可算是尝到了“现世报”的滋味。 自从拜登上台以后，美国各州似乎经常进入紧急状态。有时候是因为自然灾害，有时候又是一天前，美军驻伊拉克阿萨德空军基地，和美国驻巴格达大使馆，分别遭遇火箭弹和无人机轰炸；一天后，伊拉克机场被炸，美军基地再次遇袭。因为遭受网络袭击。 二、认识流 流介绍 + 流在css里面指的是规则，层叠指的也是规则 + 标准（文档、普通）流，就是正常的网页排版顺序 规则： + 块级，独占一行，自上而下排列，可以设置宽和高 + 内联，横向排列的，不能设置宽和高 + 内联块，横向排列的，可以设置宽和高 + 浮动流，一个标记设置了float属性就成为浮动流（脱离文档流 --- 脱标） 浮动背后的故事 float属性最开始设计出来的作用就是做文本环绕的，后面随着大家使用越来越多突然发现它还有其他的功能，可以让自上而下排列的元素横向排列 生活中的例子，可乐，一开始是一个医生研制的一款糖浆针对于治疗某种疾病，结果发现没有多大作用这个医生发现它的口感还不错，最后就发展了一款饮料 浮动的使用注意事项 两个div，第一个设置了浮动属性，第二个没有设置，这个时候第一个会把第二个给覆盖掉。原因：第一个div设置了浮动后脱离文档流，原先的位置会发生改变，浮动流是漂浮在标准流之上的，标准流之前没有东西了后面的元素要上去进行补位操作 两个div，第二个设置了浮动属性，第一个没有设置，这个时候它们的位置保持不变。原因：第一个div是标准流会继续占文档中的位置，所以第二个浮动的元素它的位置保持不变，但是它会影响它自己后面的元素 两个div，都设置了浮动属性，如果容器的宽度不够的情况下第二个div依旧会被挤到第二行排列 三、清除浮动 为什么清除浮动 清除浮动并不是把设置的浮动直接删除而是清除浮动给咱们带来的负面影响。负面影响，高度塌陷和高度塌陷引起的元素重叠问题。 高度塌陷：在实际的开发中容器的高度要求自适应，当容器没有设置高度的时候子元素设置了浮动会引起高度失效（塌陷），把这种现象称之为高度塌陷问题 清除浮动方法 使用clear:both|left|right;清除浮动，提前条件是在需要清除浮动的同级元素下设置一个空（除了设置clear以外不能有其他任何属性）元素，然后给其设置clear属性 直接给容器设置overflow:hidden;属性 注意点：并不是只要设置了浮动就需要清除浮动，而是发生了高度塌陷这种问题才需要清除浮动 四、overflow溢出属性 语法： overflow:visible; 默认值，不隐藏 overflow:auto; 如果溢出则出现滚动条，出现横向或者纵向滚动条主要看内容，如果没有溢出不会出现任何滚动条样式 overflow:scroll; 出现滚动条，无论内容溢出与否都会出现滚动条的样式（横向、纵向的） overflow:inherit; 继承 作用： 可以让内容溢出后隐藏 清除浮动 解决margin-top兼容问题 五、margin-top问题 问题： 当给子元素设置了margin-top后，浏览器在解析的时候会误认为给容器设置的所以会出现整体往下掉的情况 前提条件： 必须是元素嵌套元素的情况下 注意点： 只会在标准流中出现 解决方案： 直接给容器设置overflow:hidden; 如果子元素或者父元素设置了浮动属性也不会出现问题 只要触发了BFC都可以解决 给父元素添加padding-top：0.1px；使子元素与父元素分离也可以解决 标准流中出现问题的条件（了解）： 子元素和父元素都是背景颜色的时候会出现 父元素是背景颜色，子元素是边框的时候会出现 父元素设置了边框，子元素是背景颜色的时候不会出现 父元素和子元素都是边框的时候不会出现 day07-文本、列表属性与盒模型、省略号 一、文本属性 字体大小问题： 浏览器默认字体大小是16px，最小支持的字体大小是12px（谷歌浏览器下，ie浏览器可以变得更小） 同样字号的文字，如果字体不同最终在页面里面呈现的效果不一样 单位问题： px像素，是网页最基本的单位，也是使用最多的 pt点（磅），这个是打印行业里面的一个单位，可以保证打印出来的东西不改变 9pt=12px 3/4 0.75 em相对于容器字体大小的一个单位，是可以动态改变的 1em = 16px 颜色值问题： 英文单词形式（red、orange、blue、white、green、yellow、pink、purple、black等等） 十六进制颜色值 例如：#fff #000 #ccc rgb()形式 计算机三原色 red、green、blue 相关属性： font-family:字体1，字体2，字体3 说明：浏览器首先会寻找字体1、如存在就使用改字体来显示内容，如在字体1不存在的情况下，则会寻找字体2，如字体 2也不存在，按字体3显示内容，如果字体3 也不存在；则按系统默认字体显示； 当字体是中文字体时，需加双引号； 当英文字体中有空格时，需加双引号如（“Times New Roman”） 当英文字体只有一个单词组成时不加双引号；如：（Arial）； Windows中文版本操作系统下，中文默认字体为宋体或者新宋体，英文字体默认为Arial font-weight:bolder(更粗的)/bold（加粗）/normal（常规）/100—900; 说明：在css规范中，把字体的粗细分为9个等级，分别为100——900，其中100对应最轻的字体变形，而900对应最重的字体变形， 100-400 一般 500常规字体 600-900加粗字体 font-style：italic/oblique/normal（取消倾斜，常规显示）; 说明： italic和oblique都是向右倾斜的文字, 但区别在于Italic是指斜体字，而Oblique是倾斜的文字，对于没有斜体的字体应该使用Oblique属性值来实现倾斜的文字效果. 文字属性简写：font:12px/24px \"宋体\"; font属性的简写：字号，行高，字体 font-size:12px; line-height:24px; font-family:”宋体”； font属性的简写： 说明:font的属性值应按以下次序书写(各个属性之间用空格隔开) 顺序: font-style font-weight font-size / line-height font-family (1)简写时 , font-size和line-height只能通过斜杠/组成一个值，不能分开写。 (2) 顺序不能改变 ,这种简写法只有在同时指定font-size和font-family属性时才起作用,而且,你没有设定font-weight , font-style , 他们会使用缺省值（默认值） 文本修饰 text-decoration:none/underline/overline/line-through 说明： none:没有修饰 underline:添加下划线 overline:添加上划线 line-through:添加删除线 首行缩进：{text-indent:value;} 说明：首行缩进2个字 text-indent:2em; A）text-indent可以取负值； B）text-indent属性只对第一行起作用。 字间距 letter-spacing:value; 控制英文字母或汉字的字距。（英文字母和字母） 二、列表属性 1)定义列表符号样式 list-style-type：disc(实心圆)/circle(空心圆)/square(实心方块)/none(去掉列表符号)；list-style-type:none===list-style:none; 2)使用图片作为列表符号 list-style-image：url(所使用图片的路径及全称)； 3)定义列表符号的位置 list-style-position:outside(外边)/inside(里边)； list-style:none;去掉列表符号 三、常见图片格式 jpg :有损压缩格式，靠损失图片本身的质量来减小图片的体积，适用于颜色丰富的图像;(像素点组成的，像素点越多会越清晰 ) gif：有损压缩格式，靠损失图片的色彩数量来减小图片的体积，支持透明，支持动画，适用于颜色数量较少的图像; png:无损压缩格式,图片本身质量没有损失，支持透明，不支持动画，是fireworks的 源文件格式，适用于颜色数量较少的图像; 四、盒模型 概念：css规定把所有HTML元素都可以看作成一个盒子，在CSS中，盒模型是用来设计和布局时使用的。 盒模型本质上是一个盒子，它的作用是封装周围的HTML元素。盒模型组成：边框（border）、边界（margin）、填充（padding）、内容区（content）。 盒模型计算： 盒模型的宽度 = 左右margin + 左右padding + 左右border + width 盒模型的高度 = 上下margin + 上下padding + 上下border + height 盒模型的宽度和高度才是一个标记真正在网页所占的位置的大小 空余空间(了解)： 说明： white-space：normal/nowrap/pre/pre-wrap /pre-line /inherit 该属性用来设置如何处理元素内的空白； normal：默认值，空白会被浏览器忽略， nowrap:文本不会换行，文本会在同一行上继续，直到遇到标签为止； pre：空白会被浏览器保留，其行为方式类似HTML中的pre标签； pre-wrap：保留空白符序列，但是正常的进行换行； pre-line:合并空白符序列，但是保留换行符； inherit：规定应该从父元素继承White-space属性的值；(ie浏览器不支持此属性值) 五、省略号 1、容器宽度：width：value； 2、强制文本在一行内显示:white-space：nowrap; 3、溢出内容为隐藏：overflow：hidden； 4、溢出文本显示省略号：text-overflow：ellipsis; /*第一步：元素必须设置宽度*/ width:200px; height:200px; border:1px solid; margin:30px; /*第二步：文本强制不换行*/ white-space:nowrap; /*第三步：文本溢出隐藏*/ overflow:hidden; /*第四步：出现省略号*/ text-overflow:ellipsis; 六、 markdown文档 markdown介绍： + markdown文档和word还有ppt等等是类似的文档，后缀名是.md + 支持图片、文本、超链接、标记的使用，markdown格式可以转换成其他的文档类型 + 网站中的博客、微信公众号、还有公司里面很多的技术文章都是采用markdown文档格式，使用非常普通 markdown编写工具： + 专门直接下载其他的 + vscode、HBuilderX都可以编写 + typora工具（目前是使用最多的） GitHub 这个是世界上最大的同性交友中心，交流技术 七、元素类型转换 元素类型转换 + 在实际开发中开发需要是多样的，所以有时候需要把一种类型转成其他类型 + 使用display属性进行元素类型换行 + display属性 1、block 把其他类型转成块级元素，让隐藏的元素显示 2、inline 3、inline-block 4、none 让显示的元素隐藏 5、组合使用 display:block; display:none; + 注意点：内联块元素不能转成内联元素，因为内联块元素默认都有内置的样式 + display需要了解的值 1、list-item 列表类型 2、table 表格类型 3、inline-table 行内表格类型 4、table-cell 单元格类型 元素类型使用注意事项 + 不要在p标记里面嵌套其他的块级元素 + margin和padding上下值给内联元素设置的时候有问题的，不会起作用 背后的故事： 1、最早的时候css把标记默认类型划分成了两种，块级元素、内联（行内）元素 2、随着大家的使用发现inline和inline-block有不同的区别，所以在css2.1里面新增了一个内联块元素 块级、内联、内联块 3、有人提出不从元素的特点上进行划分，直接把元素划分成两种类型，置换元素和非置换元素 a、置换元素指的是html标记默认带有css格式化以外（没有通过css设置样式，标记默认自带的）的样式的标记 input所有的类型、select、textarea、button、img等等 b、非置换元素，除了置换元素以外的其他元素 day08笔记 一、导航 home about us home about us home about us home .nav3{ width:800px; height:20px; border-bottom:8px solid #db4e18; margin:50px auto; } .nav3 li{ font-size:14px; line-height:20px; float:left; width:80px; height:20px; background-color:#dfdfdf; text-align:center; margin-right:1px; } .nav3 .first{ margin-left:10px; } .nav3 li a{ color:black; display:block; } .nav3 li a b{ font-weight:normal; display:none; } .nav3 li:hover a span{ display:none; } .nav3 li:hover a b{ display:block; } home首页 home首页 home首页 home首页 home首页 home首页 home首页 二、vertical属性 vertical-align垂直居中属性 + 属性值：top、bottom、middle、baseline（基线） + 注意点：只对内联元素和内联块元素起作用 + 解决图片底部间隙问题 day09-position定位与层级 一、position定位属性 1、定位介绍 解释：定位简单来说就是让元素的位置发生改变或者叫做移动 语法：position:static（默认值，静态定位）|absolute（绝对定位）|relative（相对定位）| fixed（固定定位）; 定位属性必须配合这几个值一起使用left、right、top、bottom才会起作用 定位属性具有层叠性（规则）--- 叠加（可以让元素与元素之间进行叠加） 最后面定位的元素，排列在最上面 二、absolute绝对定位 特点： 脱离文档流的，所以它不占空间（位置） 不区分元素类型（设置了绝对定位后，不管元素以前是什么类型的，现在都要遵循定位的规则） 相对于祖先元素进行定位的（绝对定位要进行定位有一个查找规则，优先去找父级，看父级有没有定位流，如果有就以父元素进行定位，如果没有就继续往上一级进行查找，直到找到body还是没有定位流就以body进行定位） 三、relative相对定位 特点： 不脱离文档流的，所以要占位置 相对于自己以前在标准流的位置进行定位 区分元素类型（设置了相对定位，你以前是什么类型现在依旧是什么类型） 相对定位作用：可以对元素进行微调、最常用的是配合绝对定位一起使用（子绝父相） 四、fixed固定定位 特点： 脱离文档流，不占位置（空间） 不区分元素类型 相对于body进行定位的 不会随着滚动条的滚动而滚动 五、z-index定位层级属性 定位属性都有层级的特性，后面定位的会把前面定位的给覆盖 z-index属性是专门控制层级关系的 z-index:auto|number; 没有单位 可以为负值 day10-透明度兼容、精灵图与序号选择器 一、锚点 点击对应a标签可以跳转到对应id的div 瓜娃子 日脓包 神戳戳 胎神 猪儿虫 二、透明度兼容 opacity属性 IE低版本的浏览器不支持opacity filter:alpha(opacity=value); value取值范围1-100，相当于opacity=0~1 opacity取值范围0-1 0.5 --- .5 opacity透明度问题 opacity会让子元素继承父元素的透明度 css3新增了一个方法 rgba() ，最后一个值表示透明度 三、字幕滚动属性 欢迎，肖宇哥哥来到我的直播间 谢谢！肖宇哥哥送的大保健 direction:滚动方向 scrollamount：滚动速度 四、CSS精灵图 图片整合技术 名称：css精灵、css sprite、雪碧图 把很多张小图整合成一张图，然后使用background-position去调整它的位置 网络请求问题： http超文本传输协议，规定了咱们如何去上网，做了统一的规范，在浏览器地址栏输入域名直接可以访问网站 http和https区别，https是比http要安全，因为它加密过 如合请求数据 1、当咱们在浏览器的地址栏（url）输入网址的时候并回车 --- 向服务器发送了请求（报文） 2、服务器接收到请求，进行判断（如果有这个资源，就返回需要的信息，如果没有也返回的提示）404 你的网页走丢了 3、浏览器接收到服务器返回的请求（html---图片、css、js） 图片加载问题： 一个网站里面有很多图片，图片在加载的时候特别的耗费网络带宽资源 针对于网站中的小图，需要做优化提供加载速度，而图片整合技术就可以做到 五、序号选择器 不区分类型： :first-child; 选中同级别中的第一个标签 :last-child; 选中同级别中的最后一个标签 :nth-last-child(n); 选中同级别中倒数第n个标签 :nth-child(n); 选中同级别中的第n个标签 :only-child; 选中同级别中唯一子元素标签 区分类型： :first-of-type; 选中同级别中同类型的第一个标签 :last-of-type; 选中同级别中同类型的最后一个标签 :nth-of-type(n); 选中同级别中同类型的第n个标签 :nth-last-of-type(n); 选中同级别中同类型的倒数第n个标签 :only-of-type; 选中同级别中同类型的唯一标签 奇偶选择： :nth-child(odd); 选中同级别中同类型的奇数标签 :nth-child(even); 选中同级别中同类型的偶数标签 :nth-child(nx+y); 选中同级别中同类型的第（nx+y）个标签（n从第0开始递增计数，到元素的总个数上限停止 week3 day11笔记 一、宽高自适应 1、 在实际开发中，大家发现每次把元素的宽度和高度直接固定的话不方便后期的扩展和内容增加，所以有人提出了宽高自适应的概念 2、 实现宽高自适应 不设置宽度和高度或者width:auto; height:auto; 宽高自适应其他方式 3、宽高自适应的新增属性 min-width 最小宽度 max-width 最大宽度 min-height 最小高度 元素一开始有一个固定的高度，当内容溢出时高度会自适应 max-height 最大高度 元素设置了一个最大高度，开始时元素高度是自适应的，当内容超出最大高度时会溢出 二、最小高度兼容 min-height兼容问题 描述：最小高度min-height在IE低版本的浏览器下是不支持的，正常的高度height在亲爱的的IE浏览器下相当于是最小高度 解决方案：利于IE浏览器的漏洞，使用下划线的过滤器的东西 min-height:100px; _height:100px; 在普通浏览器中只能识别min-height，不会识别 _height这个属性，而ie6等低版本浏览器不支持min-height，使用只有它能识别的 _height属性作为min-height来使用 最高优先级 关键字过滤器 !important，它表示所附加的声明具有最高优先级 语法：选择符（属性：属性值 !important;) 下划线过滤器：属性值前面增加一个下划线，符合标准的浏览器不能识别带有下划线的属性而忽略了这个声明，而IE6及更低版本可以解析 表示最高权重，覆盖一些别人的样式 三、百分比单位 介绍：百分比可以让元素实现自适应，比px单位更为灵活 应用：元素的最外层使用百分比，移动端 注意点：百分比是自适应的，但是需要参照物 1、font-size 相对于父元素的font-size来计算，如果父元素（以及它的祖先元素）未显式设置font-size值的话，将会以浏览器的默认值16px为基准。 2、line-height 基于元素自身的font-size的值来计算。如果元素自身未显式设置font-size，则会基于元素继承过来的font-size的值计算。 3、vatical-align 基于元素自身的line-height值计算。如果元素自身未显式设置line-height的值，那么元素会继承其父元素（或祖先元素）的line-height值。 4、text-inent CSS的text-indent属性可以让一个块元素首行文本内容的缩进量。有的时候也会使用该方法实现图像替换文本 它的计算是相对于元素块width（或height）计算，如果是逻辑属性的话，相对于inline-size（或block-size）计算。具体相对于width（inline-size）还是height（block-size）取决于CSS的书写模式（即受writing-mode和direction）。 5、width/height 相对于父元素的width/height。 6、magin/padding 相对于父元素的width 元素设置margin-left和margin-right值，而且都同时为正值时，元素自身的空间会被margin-left和margin-right挤压，当margin-left和margin-right两个属性的值之和等元素元素width时，该元素将在视图中不可见 元素margin-right的值为正值时且大到一定的值（一般容器剩余空间），那么将会挤压元素自身的width 7、position 当元素position的取值为relative或absolute时，那么元素的偏移属性的%值计算相对于离元素最近的设置了position为非static的元素的width和height。其中top和bottom相对于height计算；left和right相对于width计算。 如果元素的position显式设置值为sticky，那么偏移属性取%值的计算是相对于相关的滚动端口（Scrollport）的大小计算 滚动端口（Scrollport）是指文档（Document）中滚动容器（Scroll Container）的可视窗口。显式给元素设置overflow: scroll或overflow: auto（在内容足够导出溢出时产生）可以创建滚动容器。 8、border-radius 在border-radius使用%值时，它计算的相对值是需要分开来算的，其中 x轴的%值相对于元素的width值计算；y轴的%值相对于元素的height值计算 9、border-image border-image也是一个简写属性，它的子属性有 border-image-source、 border-image-slice、 border-image-width、 border-image-outset 和 border-image-repeat。其中border-image-slice和border-image-width取值也可以是% 相对于border-image-source引入的图像源尺寸进行计算，其中x方向相对于图像的width计算，y方向相对于图像的height计算 10、background-position 水平方向（x轴），相对于元素的width与背景图片的width差 background-position-x=(容器w-图片w)百分比 垂直方向（y轴），相对于元素的height与背景图片的height差 background-position-y=(容器h-图片h)百分比 特别声明，背景图片的大小将会受background-size值的影响，上面提到的图片的尺寸是指backgroud-size的值为100% 100%的情景下的尺寸，即背景图片的初始尺寸（原始尺寸）。 11、background-size background-size的第一个值是x轴方向，其计算相对于元素的width计算；background-size的第二个值是y轴方向，其计算相对于元素的height计算。 四、元素显示和隐藏 显示和隐藏： 1、visibility:hidden; 占位隐藏，虽然占位置但是元素是隐藏了的 2、display:none; 直接隐藏，元素的位置也会随着消失 3、opacity:0; 不叫隐藏，只是透明度为0了，你看不见它，类似于隐藏了，元素的功能依旧存在 溢出隐藏： overflow:hidden; 当内容超出时，隐藏超出的部分，并不是直接把元素进行隐藏处理 五、伪对象选择器 伪对象选择器： ::after：与content属性一起使用，定义在对象后的内容 ::before：与content属性一起使用，定义在对象前的内容 ::first-letter：定义对象内第一个字符的样式（只能用于块级元素） ::first-line：定义对象内第一行的样式（只能用于块级元素，ie6以下不支持) 让css选择器可以直接给标记添加内容 添加内容的行为变的多样了 权重为1 div::after{ /*必须设置，为空也要设置不然不起作用。添加的元素是内联类型*/ /* content: \"肖宇\"; */ /* content: url(images/11.jpg); */ content: \"\"; width: 50px; height: 50px; background-color: green; display: block; } 六、浏览器兼容问题 浏览器大战： window系统市场占用率是非常高的，IE浏览器是捆绑在window系统里面的，所以一开始使用的人非常多 软件捆绑，一不小心下载了全家桶，微软才是这方面的鼻祖 那个时候IE浏览器算比较好用的东西了，微软把浏览器的团队给解散了，这个网景（JavaScript）公司出了一个马赛克浏览器 争夺市场，没有结果，到了后面谷歌、欧朋、火狐这些浏览器的出现比所谓的马赛克还有IE浏览器更好用了，所以它们争夺市场 微软发现如果再不做出更新估计要凉了，所以把之前的团队的召集起来了做出了IE9，IE9和其他的浏览器基本上都差不多了 做兼容，以IE8作为分界线，以上问题不大，以下问题很大 五大浏览器内核 ​ •Trident （MSHTML） （三叉戟；三叉线；三齿鱼叉） ​ •Gecko （壁虎） ​ •Presto （ 迅速的） ​ •Webkit （Safari内核,Chrome内核原型,它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核） ​ •Blink (由Google和Opera Software开发的浏览器排版引擎)。 CSS Hack：CSS中，Hack是指一种兼容CSS在不同浏览器中正确显示的技巧方法 图片间隙问题： 描述：当容器没有设置高度的时候，图片会默认把容器底部撑大几像素 解决方案： display:block; vertical-align:top; float:left; 蓝色边框问题： 描述：当超链接里面放了图片标记，在IE浏览器下图片会出现蓝色边框 解决方案： border:none; border:0; 表单问题1： 描述：表单元素默认距离浏览器顶部不一致 解决方案： 使用float:left;属性 表单问题2： 描述：按钮标记在各个浏览器里面样式不一样 解决方案： 使用背景图 重新设置样式 使用a标记模拟 表单问题3： 描述：在低版本的IE浏览器下表单中的文字是以顶部对齐的 解决方案： 设置line-height cursor兼容问题： 描述：cursor:hand; 表示鼠标手型，在高版本的浏览器里面不支持，IE低版本的浏览器支持 解决方案： cursor:pointer; margin-top问题 问题： 当给子元素设置了margin-top后，浏览器在解析的时候会误认为给容器设置的所以会出现整体往下掉的情况 前提条件： 必须是元素嵌套元素的情况下 注意点： 只会在标准流中出现 解决方案： 直接给容器设置overflow:hidden; 如果子元素或者父元素设置了浮动属性也不会出现问题 标准流中出现问题的条件（了解）： 子元素和父元素都是背景颜色的时候会出现 父元素是背景颜色，子元素是边框的时候会出现 父元素设置了边框，子元素是背景颜色的时候不会出现 父元素和子元素都是边框的时候不会出现 opacity透明度问题 问题描述： IE低版本的浏览器不支持opacity 解决方案： 使用过滤器filter:alpha(opacity=value); 取值范围1-100 opacity取值范围0-1 0.5 --- .5 注意点 opacity会让子元素继承父元素的透明度 css3新增了一个方法 rgba() ，最后一个值表示透明度 day12笔记 一、form表单相关 文本框 密码框 单选按钮 注意点：同一组的单选按钮的name属性必须设置，属性值必须一样，不同组的单选按钮name的属性值不一样 复选框 disabled禁用，给按钮使用比较多 checked默认选中 下拉菜单 option的html属性 value给js使用的 selected是option那个选项排列在第一位 1990 1990 1990 多行文本域 按钮 提交按钮 H5新增表单内容 上传文本框 图像按钮 标签 用户名： 使用for属性绑定input的id，点击lable标签，可以是对应的input输入框获取焦点 表单字段集 可以嵌套使用 作用：用来给表单进行分组的，根据内容不同进行分组, 字段集标题 align:left|center|right 个人信息 用户名 电子邮箱 密码 二、表格相关 完整的表格组成 table ：表格 显示数据 caption ：表格的标题，属性caption-side：top|bottom定义标题的位置，left和right有兼容问题很少使用 注意点：要放table里面才会起作用 thead ：表头 ，tr th表头的标题 tbody ：表体 tr td 注意点：当咱们不写tbody的时候，表格会默认给在咱们添加一个 tfoot ：表尾 tr td cellspacing属性：表示单元格与单元格之间的间隙 cellpadding属性：表示单元格内容到边框之间的距离 rules属性：规定内侧边框的哪个部分是可见的。 rules：none没有线条|groups行组和列组之间的线条|rows行之间的线条|cols列之间的线条|all行和列之间的线条 border-spacing属性：指的是单元格与单元格之间的间隙 border-collapse:collapse：合并单元格的边框，会忽略 border-spacing 和 empty-cells 属性。（默认值separate） table-layout:fixed; ：表格固定属性，单元格大小不会随内容而改变（默认值automatic） enpty-cells:hide; ：单元格为空时隐藏，无内容隐藏（默认值show） 行分组 thead、tbody、tfoot 学员信息 姓名 性别 年龄 学号 肖宇 男 18 6666666 肖宇 男 18 6666666 张必聪 男 16 8888888 吴亦凡 男 32 3333333 都美竹 女 19 6666666 王思聪 男 36 0000000 列分组 html用属性span来把表格分成几组 --> 三、关于标题 使用borde-top+h3定位来实现 四、关于站点 1、站点作用：用来归纳网站里面的素材，方便开发使用 2、站点的简单目录结构 3、简单的站点的目录结构在实际的开发中不会使用，目前公司里面的开发都是采用的工程化形式和叫做模块化 工程化：不会直接采用传统的引入文件什么东西，会让工具帮助咱们做一些事情，代码需要压缩和打包，gulp工具 模块化：目前框架里面都是使用的模块化的开发思维、vue、react都是这种的 要采用实际开发中的目录结构 src目录表示源代码（文件）目录 img目录 放图片资源的 css目录 放样式文件的 js目录 放js文件的 html目录 放html文件的 font目录 放字体文件的 libs目录 放引入的一些库或者框架的第三方文件目录 video目录 放视频资源的目录 dis目录是源代码（文件）打包压缩后的文件，在实际的开发中不需要自己创建，类似于gulp打包工具可以帮助咱们自动创建和修改代码 五、网站状态栏图标 rel=\"shortcut icon\" 网站快捷图标 属性和属性值必须写 六、网站头部信息优化 欢迎来到吴签签的网站 七、网站代码复用和重置样式 1、网站代码复用 2、重置样式 将其放在一个css文件中引入，可以直接使用其中定义好的类名从而避免重复写相同的代码 /*重置样式*/ html, body, div, p, ul, ol, li, dl, dt, dd, h1, h2, h3, h4, h5, h6, form{ margin: 0; padding: 0; } img{ vertical-align: top; border: none; } ul, ol{ list-style: none; } b, strong, em, i{ font-weight: normal; font-style: normal; } a{ text-decoration: none; color: #000000; } /*清除浮动*/ .clear-float{ overflow: hidden; } /*元素垂直居中*/ .ele-middle-parent{ position: relative; } .ele-middle-son{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } /*网站头部样式代码*/ .header{ width: 100%; height: 80px; background-color: #ccc; font-size: 20px; text-align: center; line-height: 80px; } /*按钮样式*/ .btn{ width: 120px; height: 25px; color: green; background-color: #E5E5E5; font-size: 14px; border: none; outline: none; cursor: pointer; } .btn:hover{ background-color: yellow; color: red; } /*网站尾部样式代码*/ .footer{ width: 100%; height: 100px; background-color: black; font-size: 20px; text-align: center; line-height: 80px; color: #fff; } 八、图片优化 1、给图片尽量设置title和alt属性，当图片加载失败或者搜索引擎查找的时候给一个指引 2、针对于小图标使用css精灵，雪碧图 3、使用base64编码方式，编码解析速度肯定图片本身要快 base64使用情况：图片足够小且因为用处的特殊性无法被制作成精灵图，在整个网站的复用性很高且基本不会被更新，体积较大的图片不要使用base64编码，因为编码后字符太多，体积可能更大 data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAOCAMAAAAhfX2ZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTExNTRFMDc2RkQzMTFFOUE3MzM4Mjc5NjY0N0E3QkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTExNTRFMDg2RkQzMTFFOUE3MzM4Mjc5NjY0N0E3QkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5MTE1NEUwNTZGRDMxMUU5QTczMzgyNzk2NjQ3QTdCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5MTE1NEUwNjZGRDMxMUU5QTczMzgyNzk2NjQ3QTdCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgZ4YTQAAAAtUExURf///0FBQXh3dRUUF/Hx8IWFhL29vfr5+lxbW/7+/qGgn5iYmFBNRmZmZY+PjureQysAAABDSURBVHjapI63EcAwEMMYrOiw/7h6vQsPYFY4NARO6TJNEpJ6kB0IjIYGJOaOD3/a8VoVzUk6j1Vr3w1P2f6OniXAAEYdAP+Kw3zbAAAAAElFTkSuQmCC 注意点：base64格式只需要找对应的工具去把图片转换就行 day13笔记 一、H5介绍 html超文本标记语言 超文本，就是网页中除了文字以外其他的东西，例如：图片、超链接、音频、视频、js程序等等 标记最大的意义就是语义化，表示的是某种意义，见名知意，你见到它就知道它是干什么呢 学习编程语言，最终的目的是人机交互，是让计算机能明白你要让它做什么，而不是让你觉得计算机应该直接做什么 html发展历史 html1.0-html4.0 xhtml可扩展超文本标记语言 html5 二、怪异盒模型 + w3c标准盒模型 盒模型宽度 = 左右margin + 左右padding + 左右border + content(width) + IE怪异盒模型 盒模型宽度 = 左右margin + content（width包含了padding和border） 怪异盒模型怎么触发 在IE低版本的浏览器下当咱们不定义doctype的时候会触发怪异盒模型 在css3新的标准中，新增了一个属性可以在高版本的浏览器里面触发怪异盒模型的机制，把标准盒模型转成怪异盒模型 box-sizing:border-box（怪异盒模型）|content-box（标准盒模型，默认值）; 使用怪异盒模型时width不会被padding和边框撑开，从而避免布局变形或者网页出现滚动条 三、H5新增标记 网页头部 导航 主要内容标记，一个页面里面只能有一个 块 网页尾部 表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 标记文档中的图像 定义图像标题 文本高亮标记 内联标记 画布标记 内联块标记，可以使用它画很多东西，必须配合js一起使用 带有下拉菜单提示信息的输入框 使用H5新增的标记实现的效果和之前使用其他标记是一样的，不同的是语义化对于浏览器来说意义非凡。 四、H5多媒体标记 object标记，作用是引入flash使用的 param标记，引入flash的路径 后缀名为.swf的表示的是flash动画 video标记，视频，很多巨头公司放弃flash支持H5，多媒体播放（视频播放）使用的就是video标记 video标记支持的视频格式：mp4、ogg（ogv）、webm video视频标记的html属性 src 路径 controls 视频控件（播放、静音、进度条） loop 循环播放 autoplay 自动播放，谷歌浏览器以影响浏览器的性能为由把autoplay给禁用了 muted 静音 poster 封面 preload 预加载，当视频开始播放的时候进行缓存，当网不好的时候直接可以流畅播放 auto - 当页面加载后载入整个视频 meta - 当页面加载后只载入元数据 none - 当页面加载后不载入视频 source标记，引入视频资源的路径 多个source标记的原因是视频支持的格式有多个 音频标记 embed标记 embed可以用来插入各种媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等 五、H5新增表单 电子邮箱 电话号码 网址 搜索 进度条 取色器 数字 日历 月份 周 上传文件 图像按钮 placeholder 当用户输入内容时提示信息消失 autofocus 让表单的第一个自动获取焦点，设置多个只能第一个起作用 + autocomplete 关闭表单自动提示功能，自动提示功能是表单设置了name属性后才会有 off 关闭 on 打开 required 表单为空不能提交 pattern 属性值里面可以写正则表达式 novalidate 表单不验证自动提交 六、:focus焦点选择器 input:focus：可以设置input获取焦点时的样式 七、交集选择器 语法：选择器1选择器2{} 作用：限定样式的范围 div.p1{ background-color: red; } 这是小pp同学1 这是小pp同学2 这是小pp同学3 这是小pp同学4 这是小pp同学5 这是小pp同学6 这是网页布局使用的1 这是网页布局使用的2 这是网页布局使用的3 day14笔记 一、序列选择器 同级别，不能被其他类型的标记给隔开，只能选择同一类型的标记 同类型，选择的时候只找同一类型的，不同类型的可以绕过，说明可以被其他的类型给隔开 注意点：无论是同级别的还是同类型的序列选择器都建议使用的时候不要在最外层使用 不区分类型： :first-child; 选中同级别中的第一个标签 :last-child; 选中同级别中的最后一个标签 :nth-last-child(n); 选中同级别中倒数第n个标签 :nth-child(n); 选中同级别中的第n个标签 :only-child; 选中同级别中唯一子元素标签 区分类型： :first-of-type; 选中同级别中同类型的第一个标签 :last-of-type; 选中同级别中同类型的最后一个标签 :nth-of-type(n); 选中同级别中同类型的第n个标签 :nth-last-of-type(n); 选中同级别中同类型的倒数第n个标签 :only-of-type; 选中同级别中同类型的唯一标签 奇偶选择： :nth-child(odd); 选中同级别中同类型的奇数标签 :nth-child(even); 选中同级别中同类型的偶数标签 :nth-child(nx+y); 选中同级别中同类型的第（nx+y）个标签（n从第0开始递增计数，到元素的总个数上限停止 二、属性选择器 通过标记自身上面的html属性选取标记 减少了对于类名或者id名称的依赖 ```css /通过标记的属性获取元素/ input[id]{ border: 1px solid red; } /通过标记的属性的属性值获取元素/ input[type=\"text\"]{ width: 200px; height: 30px; border: 1px solid red; } /*通过标记的属性的属性值的开头内容选取元素*/ a[href^=\"#\"]{ background-color: red; } /*通过标记的属性的属性值的结尾内容选取元素*/ a[href$=\"l\"]{ background-color: orange; } /*通过标记的属性的属性值的任意内容选取元素*/ a[href*=\".\"]{ background-color: yellow; } ``` 三、UI元素状态伪类 /*给没有禁用的表单标记设置样式*/ /* input:enabled{ border: 1px solid red; } */ /*给禁用的表单标记设置样式*/ /* input:disabled{ width: 200px; height: 30px; } */ /*给默认选中的表单标记设置样式*/ input:checked{ width: 50px; height: 50px; } /*文字选中效果 注意点：必须两个冒号才起作用*/ p::selection{ background-color: red; color: #fff; /* font-size: 20px; */ } 哈哈嘻嘻哈哈呵呵 四、否定和根选择器 否定选择器 给一个标记设置样式，除了它自己没有样式以外，其他的标记都会有 input:not([type=\"text\"]){ width: 200px; height: 30px; border: 1px solid red; } 根选择器（用处不大） 根标记html root表示的就是html :root{ background-color: yellow; } 五、层次（层级）选择器、子选择器、兄弟选择器 层次选择器 后代（包含）选择器，只要是它的后代样式都会继承 子选择器，只针对子元素起作用 .nav{ width: 800px; height: 40px; background-color: #E5E5E5; margin: 50px auto; } /*只对子元素起作用*/ .nav>li{ float: left; line-height: 40px; padding: 0 20px; } .nav>li:nth-child(3){ position: relative; } 无痛针灸 无痛火罐 无痛火罐 2.子选择器，只针对子元素起作用 语法：选择器1>选择器{} .nav>li:nth-child(3){ position: relative; } 无痛针灸 无痛火罐 无痛火罐 3.相邻兄弟选择器:只对紧跟在它后面的第一个元素起作用，不能被其他类型标记给隔开 语法：选择器1+选择器{} div+p{ background-color: yellow; } 4.通用兄弟选择器，只要是它后面的标记都会起作用 语法：选择器1~选择器{} div~p{ background-color: orange; } 六、浏览器私有前缀 介绍：一个新的属性刚出来的时候，还没有成为标准的一部分，大部分的浏览器是不支持的 想要使用这个新的属性，所以浏览器给出了一个方法，为了作为区分，第二个方便你自己去用 + 浏览器私有前缀，其实是一种身份的验证，主要是过渡使用的 浏览器私有前缀有哪些 -webkit- 谷歌浏览器 -moz- 火狐浏览器 -ms- 亲爱的的IE -o- 欧朋 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 34px 55px 153px 57px; 七、阴影效果 1.文字阴影 /*值1表示水平位置 值2表示垂直位置 值3表示模糊程度 值4表示阴影颜色，可以设置多个*/ text-shadow: 5px 5px 5px green, 10px 10px 5px yellow, 15px 15px 5px red; 2.盒子阴影 /*值1表示水平位置 值2表示垂直位置 值3表示模糊程度 值4表示阴影颜色 inset表示内阴影*/ box-shadow: 0px 1px 10px black, 2px 2px 10px blue; transition动画过度属性（只对变化的属性有效果） /*需要参与过渡的属性*/ /* transition-property: box-shadow, margin-top, background-color; */ /*all表示所有要参与过渡的属性*/ transition-property: all; /*过渡时间*/ transition-duration: 1s; 八、英文换行属性 word-break:break-all; 英文句子会自动换行，英文字母不会换行，所以可以使用该属性让英文字符串强制换行，但不能控制换行位置，还不如使用 换行 九、大小写转换属性 p:nth-child(1){ /*把单词首字母大写*/ text-transform: capitalize; } p:nth-child(2){ /*把单词大写转成小写*/ text-transform:lowercase; } p:nth-child(3){ /*把单词首字母小写转成大写*/ text-transform:uppercase; } p:nth-child(4){ /*小型大写单词*/ font-variant: small-caps; } hello world HELLO WORLD hello world hello 十、粘性定位 粘性定位：介于相对定位和固定定位之间的一个定位，可相对可固定，要达到一定的条件 指定坐标 position: sticky; /*距离浏览器顶部有50px的时候变成固定定位，开始是相对定位*/ top: 50px; 使用粘性定位可以实现吸顶效果，即当元素位置满足设置的position坐标时，该元素变成固定定位 十一、背景属性 background-origin:content-box;|padding-box;(默认值)|border-box; padding-box:从padding区域开始进行渲染，背景图包含padding区域和content区域 content-box:从content区域开始进行渲染，背景图只包含content区域 border-box:从border区域开始进行渲染，背景图包含border区域，padding区域和content区域 background-clip:content-box;|padding-box;|border-box; 使用此属性则背景图片只包含指定的区域，超出的区域会被裁剪 例如：background-clip:content-box;表示padding和border区域的背景会被裁剪 background-size:数值|百分比|cover|contain;(推荐大家使用数值或者百分比) 表示背景图的尺寸 cover:把背景拉伸到整个容器大小，完全覆盖容器区域，如果图片不规则的情况下图片会变形 contain:把图片进行拉伸，拉伸的时候会根据容器的大小把图片按着比例进行拉伸 多重背景：background:url(img/niu.png) no-repeat right bottom, url(img/c.webp.jpg) no-repeat; 注意点：前面的背景会覆盖在后面的背景上 推荐分开去写 day15笔记 一、弹性盒布局介绍 1)弹性盒也叫伸缩布局盒模型 它是css3引入的一种新的布局模式——flexbox布局，即伸缩布局盒模型，用来提供一个更有效的方式制定、调整和分布一个容器里的项目布局。相比之前的布局方式，更便利于开发。 2)主要思想是让容器有能力让其子项目能够改变其宽度、高度（甚至顺序），以最佳的方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）。flex容器会使子项目扩展来填充可用空间，或缩小他们以防止溢出容器。 3)专业术语解释 a、主轴-水平方向或者X轴 b、侧轴-垂直方向或者Y轴 c、伸缩容器（父元素）和伸缩项目（子元素） 二、弹性盒属性 direction：flex; 1)伸缩流方向 flex-direction 给容器伸缩设置，主要用来创建主轴，定义伸缩项目在伸缩容器中的方向，给伸缩容器设置 row：从左向右 row-reverse：与row相反，从右向左 column：从上到下 column-reverse：与column相反 2)主轴对齐 justify-content 给容器伸缩设置，主要用来定义伸缩项目沿主轴线的对齐方式 flex-start：伸缩项目向一行的起始位置靠齐（默认） flex-end：伸缩项目向一行的结束位置靠齐 center：伸缩项目向一行的中间位置靠齐 space-between：伸缩项目会平均的分布在行里 space-around：伸缩项目会平均的分布在行里，两端保留一半的空间 space-evenly：项目均匀分布，所有项目之间及项目与边框之间距离相等（新增的属性值，会存在兼容问题，低版本的浏览器不支持） 3)侧轴对齐 align-items 给容器伸缩设置，定义伸缩项目行在侧轴上的对齐方式 flex-start：伸缩项目在侧轴起点边的外边距 紧靠住 该行在侧轴起始边 flex-end：伸缩项目在侧轴终点边的外边距 紧靠住 该行在侧轴终点边 center：伸缩项目的外边距盒 在该行的侧轴上居中放置 baseline：伸缩项目根据伸缩项目的基线对齐（基线对齐不能给元素设置高度，可以用行高调整高度） stretch：伸缩项目拉伸填充整个伸缩容器(默认值) 当容器里面的子元素没有设置高度的时候，子项目它的高度会默认进行拉伸，宽度同理 （如果没有设置高度，项目会默认拉伸，如果设置了高度，设置了stretch也不起作用） （当项目没有设置高度而align-items设置了其他值时，项目不会被拉伸，而不设置align-items时，会默认拉伸） 4)换行 flex-wrap 给容器伸缩设置 nowrap 不换行 默认值，不管超出还是不超出都不会换行 当容器设置了弹性盒且不换行，当容器的宽度或者高度不够的情况下，子项目会默认自带压缩 wrap 换行 一旦伸缩项目超出伸缩容器，那么就会换行 如果容器设置了高度，给弹性盒设置了换行属性后，子项目行与行之间会有默认的行距 wrap-reverse 换行反向 主轴水平时，上下反向，主轴垂直时，左右反向 5)伸缩流方向属性与换行属性缩写形式 flex-flow flex-flow：换行 伸缩方向; 两个值同时定义或者单独定义都生效，不分先后顺序 6)align-self（加在子元素上） 主要用来设置单独伸缩项目在侧轴的对齐方式。注意点：align-self可以覆盖align-items，两者特性是一样的 flex-start：伸缩项目在侧轴起点边的外边距 紧靠住 该行在侧轴起始边；（元素位于容器的开头） flex-end：伸缩项目在侧轴终点边的外边距 紧靠住 该行在侧轴终点边；（元素位于容器的结尾） center：伸缩项目的外边距盒 在该行的侧轴上居中放置；（元素位于容器的中间） stretch：伸缩项目拉伸填充整个伸缩容器。（元素被拉伸以适应容器）（同样不能设置高度） 7)堆栈伸缩行 align-content(行与行之间的对齐方式) 定义多个伸缩行的对齐方式； 往往要与换行同时应用，没有换行就不存在多行的情况 与align-items的区别是align-content可以消除行距，只针对伸缩行，而align-items可以对项目起作用 flex-start：各行向伸缩容器的起点位置堆叠；（没有行距） flex-end：各行向伸缩容器的结束位置堆叠；（底部对其没有行距） center：各行向伸缩容器的中间位置堆叠；（居中没有行距） space-between：各行在伸缩容器中平均分布；（两端对齐，中间自动分配） space-around：各行在伸缩容器中平均分布，两端保留一半的空间；（自动分配距离） 8)显示顺序 order （加在子元素上） 默认状态是按照标准流的顺序排列，在flexbox模型里，可以通过order改变伸缩项目的顺序 a、不定义order的伸缩项目会排到前面 b、order：1； 排第一 order：2； 排第二 9)flex（设置在子元素上） 作用：可以让元素自动占用容器的可用空间，所有项目等比划分 flex:1; flex:2; ... 10)flex-grow属性 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大，会在原有大小的基础上分配剩余空间， 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍，即将剩余空间分成flex-grow的数值之和的份数，然后flow-grow为1的分1份，为2的分两份 11)flex-shrink属性 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 12)flex-basis属性 定义了在分配多余空间之前，项目占据的主轴空间（main size） 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。不常用，还在不断变化中。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto 三列布局 需求：一个容器里面有三个元素，两边的元素宽度是固定的，中间元素要求宽度自适应 在三列布局的基础衍生出了其他的布局方式，双飞翼和圣杯布局 双飞翼和圣杯布局 + 需求1：一个容器里面有三个元素，两边的元素宽度是固定的，中间元素要求宽度自适应 + 需求2：希望浏览器优先渲染中间内容区域，在网页效果呈现的时候中间的内容区域依旧在中间 圣杯布局：页眉、页脚、中间分为左中右三栏 三、iconfont字体图标 字体图标把图标当成字体去使用，在开发中用起来非常便利 把图进行编码化，直接把图变成代码形式使用，效率比直接使用图片会高 做图片优化 字体图标在移动端有大量的使用 使用方法： 从iconfont网站选择需要的图标，将包下载到本地并解压放在项目中 在HTML中引入字体图标的样式文件iconfont.css 打开字体图标包中的demo_index.html，查看图标的font class 给需要添加字体图标的标签设置类名class=\"iconfont 图标对应的fontclass\" svg图标 矢量图，放大或缩小不会失真 svg是H5新增的，语法使用的是xml（标记语言、它的标记是自定义、数据格式） font-face服务器字体 浏览器有些字体是支持的有些不支持，css3新增了服务器字体语 服务器字体语法可以帮助咱们实现支持其他字体 字体可以自定义名称 @font-face { font-family:\"肖宇\"; src: url(\"img/灵动指书手机字体.ttf\"); } h1{ font-family: \"肖宇\"; } week4 day16笔记 一、rem单位 1、rem介绍： (font size of the root element) 是指相对于根元素的字体大小的单位。 2、为什么web app要使用rem？ 实现强大的屏幕适配布局(淘宝,腾讯,网易等网站都是rem布局适配)rem能等比例适配所有屏幕,根据变化html的字体大小来控制rem的大小, 3、适配方案 使用rem.js 已经准备好一个rem的js相关文件，咱们只要把对应的js文件引入的到页面中直接可以使用 srcipt标记，这个标记的作用就是在内部编写js代码或者可以通过它的src属性引入一个外部的js文件 srcipt标记可以理解为它是js代码执行的一个环境 js里面为了方便计算，rem的值使用的是 100px=1rem 使用vw 二、em单位 1、em介绍：是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 2、em特点： em的值并不是固定的 em会继承父级元素的字体大小 三、vw、vh单位 1、单位介绍： css新增的一个单位 vw表示的是视窗，指的是浏览器宽度和高度 vw把视窗默认进行了份数的一个划分 默认情况下把视窗划分成了100vw，1vw占了1% 为了做屏幕适配，可以实现自适应 比百分比方便，因为它不需要参照物（只需要参照视窗） vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。 vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持 2、px转vw公式: Vw = 元素所展示的大小（设计图固定大小）*100/设计稿宽度 vw默认把屏幕划分成了100vw，100vw = 750px，求出1px等于多少vw呢？ 1px = 0.1333333vw 3、vw适配rem单位 设计稿的宽度是750px，100vw = 750px 1px = 0.133333vw，使用js适配rem的时候比例1rem = 100px 已经知道1px等于0.133333vw，求出100px等于0.133333*100 = 13.3333vw 四、移动端布局 移动端布局区域 可视区域（就是你看见的区域，也可以理解为屏幕区域） 布局区域（指的是整个网页） 理想区域：可视区域 = 布局区域 时就是理想区域 五、媒体查询 css3新增的一个语法 可以让css具有判断的功能，在大于1024px的宽度执行或者小于1024px的宽度执行代码 根据条件可以设置不同的样式 媒体查询判断使用的两个条件 max-width min-width 当媒体为真就执行，为假就不执行 /*all表示所有媒体类型：笔记本、移动端设备、投影设备、打印机等等*/ /*and 和 表示连接 ()括号里面放的是条件*/ /*注意点：最后数值+px里面不能有分号*/ /*当宽度大于900px的时候条件成立，触发代码执行*/ /* @media all and (min-width:900px){ div{ height: 200px; background-color: red; } } */ /*在500px --- 1000px之间执行代码*/ /* @media all and (min-width:500px) and (max-width:1000px) { div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } } */ /*not表示排除某种设备*/ /* @media not all and (min-width:900px) { div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } } */ /*only表示限定为某种设备 screen屏幕（笔记本设备）*/ @media only screen and (min-width:900px){ div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } 一、媒体查询 1、媒体查询介绍: 媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 2、媒体查询操作方式： 实际操作为：对设备提出询问（称作表达式）开始，如果表达式结果为真(符合当前条件)，媒体查询中的CSS被应用，如果表达式结果为假(不符合)，媒体查询内的CSS将被忽略。 二、媒体查询示例 1、语法： /*表示设备宽度小于320px时就不执行蓝色背景了。*/ @media all and (min-width:320px) { div{ background-color:blue;} } /*表示设宽度到640px------300px之间显示桔色背景。*/ @media only screen and (min-width: 300px) and (max-width: 640px) { div{ background-color: orange; } } /* 竖屏 */ @media screen and (orientation:portrait) {对应样式} /* 横屏 */ @media screen and (orientation:landscape){对应样式} 2、媒体类型: 3、名词解释： screen 是媒体类型里的一种，CSS2.1定义了10种媒体类型 and 被称为关键字，其他关键字还包括 not(排除某种设备)，only(限定某种设备) (min-width: 400px) 就是媒体特性，其被放置在一对圆括号中 4、断点介绍： 无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点） 5、css2媒体查询语法: 其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码 ; 想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 第一段的代码也用CSS2来实现，让它一样可以在页面宽度小于960的执行指定的样式文件： 三、常见的布局方案 固定布局：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸； 可切换的固定布局：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局； 弹性布局（流式布局）：以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果； 混合布局：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。 布局响应：对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：pc优先（从pc端开始向下设计）；移动优先（从移动端向上设计）； 四、响应式布局方案 1、基于媒体查询实现 2、响应式布局特点 设计特点： a、面对不同分辨率设备灵活性强 b、能够快捷解决多设备显示适应问题 缺点： a、兼容各种设备工作量大，效率低下 b、代码累赘，会出现隐藏无用的元素，加载时间加长 c、其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 五、Meta标签的设置 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale： 初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） day17笔记 一、多列布局 css3新增的布局，类似于生活中的报纸的版面布局 /*列宽*/ /* column-width: ; */ /*列数*/ /* column-count: ; */ columns:200px 5; /*列间隙*/ column-gap: 20px; /*列边框*/ column-rule:1px dashed orange; /*表示标题要不要跨列显示*/ column-span: all; 二、logo优化 logo优化 logo是一个网站比较重要的东西，代表的是这个品牌 logo也是在网站最显眼的地方 所以需要浏览器在查找一个网站的时候，把搜索权重提供 h1一个网站里面只能有一个，因为它的搜索权重比较高的 使用h1做logo的优化 由于搜索引擎无法识别图片上面的文字，所以一般需要浏览器解析到网站的文字所以选择手动设置 图片优化 由于搜索引擎无法识别图片上面的文字，所以一般需要浏览器解析到网站的文字所以选择手动设置 图片标记上面的title属性和alt属性必须设置，及时为空也建议设置 三、CSS3 渐变 1、简单介绍：CSS3 渐变（gradient）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果，现在通过使用 CSS3 的渐变（gradients）即可实现。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 2、线性渐变： 概念：线性渐变是从“一个方向”向“另一个方向”的颜色渐变 语法： background: linear-gradient(direction, color-stop1, color-stop2, ...); 说明： direction：默认为to bottom，即从上向下的渐变； stop：颜色的分布位置，默认均匀分布，例如有3个颜色，各个颜色的stop均为33.33%。 线性渐变方向示例代码： /*以下代码分别产生“从右到左”、“从左到右”、“从上到下”、“从下到上”的“红色–绿色”渐变*/ div { background:linear-gradient(to left, red , blue) } div { background:linear-gradient(to right, red , blue) } /* 浏览器默认值 */ div { background:linear-gradient(to bottom, red , blue) } div { background:linear-gradient(to top, red , blue) } 效果示例： 线性渐变角方向示例代码: /*分别产生到“右下角”、“右上角”、“左下角”、“左上角”的渐变*/ div { background: linear-gradient(to right bottom, red , blue); } div { background: linear-gradient(to right top, red , blue); } div { background: linear-gradient(to left bottom, red , blue); } div { background: linear-gradient(to left top, red , blue); } 效果示例: 线性渐变角度示例代码: /*0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。*/ div { background: linear-gradient(10deg, red, blue) } 3、径向渐变： 概念：径向渐变是从“一个点”向四周的颜色渐变 语法： div { background: radial-gradient(red, yellow, green); } 多颜色节点不均匀分布示例代码: div { background: radial-gradient(red 5%, green 15%, blue 60%); } 效果示例： 设置渐变形状示例代码: div { background: radial-gradient(circle, red, yellow, green); } div { background: radial-gradient(ellipse, red, yellow, green); } 效果示例: circle：渐变为最大的圆形； ellipse：根据元素形状渐变，元素为正方形是显示效果与circle无异。 4、重复性线性渐变 语法： /*10%的位置为yellow，20%的位置为green，然后按照这20%向下重复*/ div { background: repeating-linear-gradient(red, yellow 10%, green 20%); } 5、重复性径向渐变 语法： div { background: repeating-radial-gradient(red, yellow 10%, green 20%); } 四、过渡属性 过渡属性介绍： css3的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值 语法： 过渡属性分写形式： transition-property：检索或设置对象中的参与过渡的属性 transition-duration：检索或设置对象过渡的持续时间 transition-delay：检索或设置对象延迟过渡的时间 transition-timing-function：linear|ease|ease-in|ease-out|ease-in-out检索或设置对象中过渡的动画类型 简写： transition:all(全部或所有)/具体属性值 运动时间s/ms 延迟时间s/ms 动画类型; 动画类型示例图: 五、2D属性 transform 该属性允许我们对元素进行旋转、缩放、移动。 注意点：位移、旋转、缩放必须配合transform使用 位移语法: 1、translate() 将元素向指定的方向移动，类似于position中的relative。 transform:translateX(); 水平位移 transform:translateY(); 垂直位移 transform:translate(值1, 值2); 值1表示水平位移 值2表示垂直 注意点：如果使用的是分写形式，有两个transform的情况后面的属性会把前面的给覆盖掉 如：transform: translate(100px, 0px); 第一个参数:水平方向 第二个参数:垂直方向 元素垂直居中 position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 缩放属性语法: 2、scale() 让元素根据中心原点对对象进行缩放。默认的值1。因此0.01到0.99之间的任何值，使一个元素缩小；而任何大于或等于1.01的值，让元素显得更大。 transform:scaleX(); 水平缩放 transform:scaleY(); 垂直缩放 transform:scale(值1, 值2); 值1表示水平缩放 值2表示垂直缩放 如：transform: scale(0.5, 0.5); 第一个参数:水平方向 第二个参数:垂直方向 注意点: 如果取值是1, 代表不变 如果取值大于1, 代表需要放大 如果取值小于1, 代表需要缩小 如果水平和垂直缩放都一样, 那么可以简写为一个参数 transform: scale(1.5); 旋转语法： 3、rotate() 旋转rotate()通过指定的角度参数对元素根据对象原点指定一个2D旋转。它主要在二维空间内进行操作，接受一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。 注意点: 1.如果需要进行多个转换, 那么用空格隔开 2.2D的转换模块会修改元素的坐标系, 所以旋转之后再平移就不是水平平移的 如：transform: rotate(45deg); translate(100px, 0px) scale(1.5, 1.5); rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转 rotateZ() 方法，元素围绕其 Z轴以给定的度数进行旋转，默认就是Z轴旋转。 斜切、倾斜属性 transform: skewX(-26deg); transform: skewY(30deg); 变形原点属性，可以改变变形的轴线位置 transform-origin:50px top; 元素的变形原点默认在元素自己的中线位置，如rotateX则变形原点为水平中线,，50px表示Y轴变形原点为50px处，top表示x轴变形原点为top 景深属性语法: perspective: 数值；透视属性：近大远小 注意点：一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面 day18笔记 一、3D属性 1)什么是3d的场景呢？ 2d场景，在屏幕上水平和垂直的交叉线x轴和y轴 3d场景，在垂直于屏幕的方法，相对于2d多出个z轴 Z轴：靠近屏幕的方向是正向，远离屏幕的方向是反向 下图为3d场景坐标图 2)transform-style属性 ransform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。把2D转成3D 他主要有两个属性值：flat和preserve-3d translate3d位移属性 3D位移 CSS3中的3D位移主要包括: translateZ() translate3d(值1，值2，值3)两个功能函数； 值1：代表横向坐标位移向量的长度； 值2：代表纵向坐标位移向量的长度； 值3：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 4)rotate3d旋转属性 旋转后坐标轴会发生相应的变化 3D旋转 CSS3中的3D旋转主要包括: rotateX() rotateY() rotateZ() rotate3d(1,1,0,4deg)四个功能函数； 4个参数，前三个，对应x,y,z 轴，是标示你是否希望沿着该轴旋转，是为1，不是为0，最后一个标示旋转的角度。 5)scaleZ缩放属性: CSS3中的3D缩放主要包括: scaleZ()； 6)景深属性： 生活中的3d 区别于2d的地方 近大远小 景深 程序中实现的方法 perspective 元素距离 视线的距离（物体和眼睛的距离越小，近大远小的效果越明显） perspective: 1200px;(加在父元素上) transform:perspective(1200px) （在子元素中使用） 注意点： a、两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间 2、如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉 二、动画属性 动画执行三要素： 1.告诉系统需要执行那个动画 animation-name:动画名 2.告诉系统我们需要创建一个名称叫什么的动画 @keyframes mymove{ from{初始状态属性} to{结束状态属性} } @keyframes mymove{ 0%{初始状态属性} 100%{结束状态属性} }（中间再可以添加关键帧） 3.告诉系统动画持续的时长 animation-duration:3s; animation属性和语法： 1.animation-name 检索或设置对象所应用的动画名称 说明：必须与规则@keyframes配合使用， @keyframes mymove{} animation-name:mymove; 2.animation-duration 检索或设置对象动画的持续时间 说明：animation-duration:3s; 动画完成使用的时间为3s 3.animation-timing-function 检索或设置对象动画的过渡类型 说明： linear：线性过渡 ease：平滑过渡 ease-in：由慢到快 ease-out：由快到慢 ease-in-out：由慢到快再到慢 step-start:马上跳到动画每一结束桢的状态 4.animation-delay 检索或设置对象动画延迟的时间 说明：animation-delay:0.5s; 动画开始前延迟的时间为0.5s 5.animation-iteration-count 检索或设置对象动画的循环次数 说明： animation-iteration-count: infinite | number; infinite：无限循环 number: 循环的次数 6.animation-direction 检索或设置对象动画在循环中是否反向运动 说明： normal：正常方向 reverse：反方向运行 alternate：动画先正常运行再反方向运行，并持续交替运行 alternate-reverse：动画先反运行再正方向运行，并持续交替运行 7.animation-play-state 检索或设置对象动画的状态 说明： animation-play-state:running | paused; running:运动 paused: 暂停 animation和transition的区别： 相同点：都是随着时间改变元素的属性值。 不同点： transition需要触发一个事件(hover事件或click事件等)才会随时间改变其css属性； 而animation在不需要触发任何事件的情况下也可以显式的随着时间变化来改变元素css的属性值，从而达到一种动画的效果，css3的animation就需要明确的动画属性值。 animation缩写形式： 三、屏幕名称 1、什么是像素： 像素，又称画素，是图像显示的基本单位。 像素是网页布局的基础。一个像素就是计算机能够显示一种特定颜色的最小区域。当设备尺寸相同但像素变得更密集时，屏幕能显示的画面的过渡更细致，网站看起来更明快。 2、ppi是指屏幕上每英寸可以显示的像素点的数量，即屏幕像素密度 3、像素分类： a、设备像素(device independent pixels): 设备屏幕的物理像素，任何设备的物理像素的数量都是固定的 分辨率：是指宽度上和高度上最多能显示的物理像素点个数 点距：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小 b、CSS像素(CSS pixels): 又称为逻辑像素，是为web开发者创造的，比如我们css中使用的像素 在桌面端，css的1个像素往往都是对应着电脑屏幕的1个物理像素。而在手机端，由于屏幕尺寸的限制，缩放是经常性的操作。因而当用户进行缩小操作时，一个设备像素覆盖了多个CSS像素。当用户进行放大操作时，一个CSS像素覆盖了多个设备像素。不论我们进行缩小或放大操作，元素设置的CSS像素(如width:300px)是始终不变的，而一个CSS像素对应多少个设备像素是根据当前的缩放比例来决定的 1px边框问题 4、其他概念: 屏幕尺寸：指的是屏幕对角线的长度 PPI:屏幕像素密度，即每英寸(1英寸=2.54厘米)聚集的像素点个数，这里的一英寸还是对角线长度 DPI:每英寸像素点，印刷行业术语。对于电脑屏幕而言和PPI是一个意思 设备像素(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。 设备独立像素(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，这个点是没有固定下小的，越小越清晰，然后由相关系统转换为物理像素。 DPR(设备像素比)：设备像素比 = 设备像素 / 设备独立像素。(在Retina屏的iphone上，DPR为2，1个css像素相当于2个物理像素) --- 1px边框问题 5、dpr： 在早先的移动设备中，并没有DPR的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。从iphone4开始，苹果公司推出了所谓的retina视网膜屏幕，才有了这个概念。 四、BFC 1、概念：BFC 是 Block formatting context 的缩写，直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部的元素如何布局，并且与这个区域外部毫不相干。 在具体解释 BFC 前，我们了解一下常见的定位方案，通常有三种：普通流、浮动流、定位流。 普通流（文档流、标准流）：元素按照其在 HTML 中的先后位置至上而下布局，行内元素水平排列，当行被占满然后换行，块级元素则会被渲染为完整的一行。 浮动流：元素首先按照普通流的位置出现，然后根据浮动的方向向左边或右边偏移，其效果与印刷排版中的文本环绕类似 定位流：元素会整体脱离普通流，定位元素不会对其兄弟元素造成影响，而元素具体的位置由定位的坐标决定 FC，Formatting context 首字母的缩写，表示格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用，普通流其实就是指 FC。 注意点：BFC 是 FC 中的一种，具有 BFC 特性的元素可以看作是隔离了的独立容器（相当于就是一个大箱子），容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 BFC布局规则（特性） 1.内部的 box 会在垂直方向一个接一个的排列 2.box 垂直方向的距离由 margin 决定，同一个 BFC 中相邻的两个 box 的 margin 会发生重叠 3.每个元素的 margin-left 与包含块的 border-left 相接触 4.BFC 区域不会与 float box 重叠 5.计算 BFC 高度时，浮动元素会参与计算 6.容器内元素布局不影响外部元素，反之亦然 如何触发 BFC 1.根元素，即 html 元素 2.float 的值不为 none 3.overflow 的值不为 visible 4.display 的值为 flex、inline-block、table-cell、table-caption 5.position 的值为 absolute 或 fixed BFC的应用 1.解决浮动塌陷问题 2.自适应两栏布局（我们还可以运用BFC可以阻止元素被浮动元素覆盖的特性来实现自适应两栏布局。方法：给没有浮动的元素加overflow：hidden。） 3.解决设置margin值重叠问题。 总结：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。它规定了元素与其他元素的关系和相互作用。 五、万能清除浮动 .clear::after{ content: \"\"; display: block; clear: both; height: 0; visibility: hidden; } /*因为IE低版本的浏览器是不支持clear:both;属性，需要使用zoom属性触发它的机制让其支持*/ .clear{ zoom: 1; } 给需要清除浮动的元素添加类名clear即可 六、计算属性 width: calc(200px * 5 + 100px); css3新增计算属性，内部可以实现+、—、*、/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-13 21:46:45 "},"笔记/HTML与CSS基础/笔记.html":{"url":"笔记/HTML与CSS基础/笔记.html","title":"笔记","keywords":"","body":"笔记 CSS哪些属性可以继承哪些不可继承 可继承属性： 1.字体系列属性 font:组合字体 font-family:规定元素的字体系列 font-weight:设置字体的粗细 font-size:设置字体的尺寸 font-style:定义字体的风格 font-variant:偏大或偏小的字体 2.文本系列属性 text-indent:文本缩进 text-align:文本水平对刘 line-height:行高 word-spacing:增加或减少单词间的空白 letter-spacing：增加或减少字符间的空白 text-transform:控制文本大小写 direction:规定文本的书写方向 color:文本颜色 3.元素可见性 visibility 4.表格布局属性 caption-side定位表格标题位置 border-collapse合并表格边框 border-spacing设置相邻单元格的边框间的距离 empty-cells单元格的边框的出现与消失 table-layout表格的宽度由什么决定 5.列表布局属性 list-style-type文字前面的小点点样式 list-style-position小点点位置 list-style以上的属性可通过这属性集合 6.引用 quotes设置嵌套引用的引号类型 7.光标属性 cursor:箭头可以变成需要的形状 不可继承属性 1.displey 2.文本属性 vertical-align:垂直文本对齐 text-decoration:规定添加到文本的装饰 text-shadow:文本阴影效果 white-space:空白符的处理 3.盒子模型属性 width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4.背景属性 background、background-color、background-image、background-repeat、background-position、background-attachment 5.定位属性 float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index CSS优先级算法 1.原则 使用就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 2.优先级 同权重下： 内联样式(标签内部) > 嵌入样式表(当前文件中) > 外部样式表(外部文件中) （在实际代码中发现嵌入样式表优先级并没有大于外部样式表，而是后面的覆盖前面的） ！import > id > class >tag 备注：important比内联优先级高 元素居中 1.position：absolute； top:0;bottom:0;left:0;right:0; margin:auto; 2.position:absolute; top:50%;left:50%; margin:width的一半 height的一半 3.position:absolute; top:50%;left:50%; transform:translate(-50%,-50%); 4.display:flex; justify-content:center; align-items:center; week1 day01-课程简介 day01笔记 一、腾讯会议 1、每天上课共享使用，通过它看到老师的屏幕 2、连接方式：会议号：736 284 7423 密码：438679 二、飞秋使用 飞秋介绍： 1、飞秋它的功能和QQ还有微信是类似的，不同的是飞秋是局域网软件，不需要上外网下载速度会快一些 2、飞秋的版本2013版本的，这个版本是比较稳定的，最新的版本实际上不需要下载 3、作用：每天大家使用它下载资料 飞秋的具体使用 1、如果你电脑关过机或者断过网，有可能获取不到最新的消息和资料，这个时候不只需要刷新下飞秋就可以 2、获取资料和代码还有视频 第一步： 第二步： 3、如果遇到同学没有飞秋群里面可以做以下操作 第一步： 第二步: 三、前端 1、什么是前端？前端就是根据UI小姐姐给的设计稿使用代码的形式还原成网页 2、前端和H5有什么关系呢？ 以前的时候，前端能的做的东西非常的少，在公司里面的地位非常低，创造的价值没有其他的专业大，所以大家都把前端叫做页面仔或者切图仔，公司里面其实很少有专门做前端的人员，基本上都是后端人员兼职的做的 随着技术的发展，前端能做的东西越来越多了，甚至可以做后端的东西了，主要是由于HTML5（H5）标准的出现，导致行业技术巨变。前面前端人员非常少，现在的市场需要一下子就爆发了 HTML5指的是一项技术，前端指的是岗位，由于之前大家对前端的刻板的影响，所以有人提出了以H5作为前端的重新的名称，大树底下好乘凉 HTML5技术火了后，大家慢慢改变了对前端的认知，所以现在把HTML5称之为前端工程师或者H5工程师其实都是一回事儿 3、一个完整的网站包含两个部分，前端、后端（后台） 4、前端需要学习那些语言？ html css JavaScript（js） 前端具有唯一性，无论开发什么样的软件都需要界面，有界面的就需要前端。网站分为pc端还有移动端，电视应用，爱奇艺、优酷、芒果TV等等，游戏有界面、小程序 更新换代速度快 5、后端语言有哪些？ java（稳定）、python、php、Go、C#、c（嵌入式）、c++、node.js、.net、asp等等 后端主要和服务器还有数据库打交道。 服务器：它其实也是一台电脑，只不过它的配置和性能比普通电脑高不知道多少倍，一天24小时不能断电 服务器作用：存储数据和处理数据。网站还有软件都是放在服务器上面，要不然其他人访问不了 四、PS简单操作 1、快捷键 ctrl+O 打开文件 ctrl++ 放大 ctrl-- 缩小 缩放图片：按下alt+鼠标滚轮，也可以进行缩放图片的操作 拖动图片：点击空格键，当鼠标变成小手后，使用鼠标左键按着图片进行移动即可 量取尺寸：使用矩形选框工具 --- 先选中目标区域 --- 查看信息（宽度width和高度height，点击F8，如果F8快捷键不起作用不要纠结，直接找到窗口选项里面的信息点击即可）W表示宽度，H表示高度 修改PS默认单位：默认单位cm，修改成px（像素，网页单位） 第一步： 第二步： 调整矩形选框工具的选取位置：鼠标放在选取上面 --- 鼠标右键 --- 变换选取 --- 调整好 --- 直接回车 截图：使用矩形选框工具选中目标区域 --- 鼠标右键变换选取进行微调 --- ctrl+C（复制）--- ctrl+N（新建，注意点，不需要修改任何信息）--- ctrl—V（粘贴）--- 存储为web所用格式（可以修改大小，修改图片格式）--- 保存即可 吸取颜色值：使用吸管工具 --- 选中目标直接点击吸取 --- 找到取色器（前景色）--- 直接复制（颜色值默认是16进制 0-F 数字和字母的组合，#号是复制不上，需要自己手动添加）例如：#00ce41 五、DW简单使用 1、DW是代码编辑器，可以关闭代码提示，即使你开着代码提示，提示也非常少 2、公司里面更多的情况下使用vscode、hburlderX、sublime text这些工具，为什么还要使用更古老的DW呢？一开始学习的话，直接使用这些带有大量代码提示的工具，其实你能做出很多东西来，一旦离开工具你什么都没有记住，为了巩固学习成果一阶段前两周教学统一使用DW工具 3、DW操作 新建文件，第一种方式： 新建文件，第二种使用快捷键方式ctrl+N 进入新建文件后，默认在设计选项里面，需要点击代码选项 点击ctrl+S保存页面，后缀名为.html的文件（文档），表示的是网页类型的文件。有些同学看到的网页图标是谷歌的还有其他的，跟自己的默认浏览器相关 修改编辑器的字体大小，找到亲爱的小球 --- 选择编辑浏览器列表 --- 左边的选项里面找到字体 --- 要修改一起修改 关闭代码提示，找到亲爱的小球 --- 选择编辑浏览器列表 --- 左边的选项里面找到代码提示 --- 根据以下操作 day02-H5简介 day02笔记 一、学习建议 1、刚开始学习时，对于新手来说，先不要想那么多，做的比想的多 2、编程是慢慢积累而来的，不是一开始你立马变得很厉害的样子 3、摆正心态，先认识再练习然后理解 二、建站流程 1、所谓的建站流程就是一个网站从开发到上线能正常使用的过程 2、过程 域名注册：域名，其实就是网址（https//www.jd.com），网址理解为一个地址，作用是帮助咱们找到对应的网站 购买服务器： 把网站开发好以后放在对应的服务器上面，这样别人才能通过网络进行有效的访问 虚拟云主机，正常的服务器的价格是非常贵的，普通使用是没有必要花那么多钱的，所以有人就提出了虚拟服务器，钱节省了，你自己不需要去维护 购买网站：新网、西部数码、万网（阿里云）、腾讯云、百度云、华为云、新浪云等等 网站建设：确定网站主题、规划网站、搜集资料、制作页面（跟前端有关） 网站推广 网站维护 三、HTML语言 1、web标准，指的是网页制作要遵循的规范，在这个规范下有三个语言，分别是html（结构）、css（表现---样式）、JavaScript（js---行为） 2、html的作用是搭建网页的结构，css是用来美化html结构的，js是让网页有动态效果 3、html超文本标记语言 文本：指的是文字，文字不仅仅指的是英文、还包含中文还有其他语言 超文本：人加一个超，是超人，超人和人的区别是什么？内裤外穿，超人具有一些人没有的能力。超文本指的是网页中除了文本以外的其他东西，例如，超链接、图片、音频、视频、程序等等 标记：记号、标识，告诉你这个东西是什么意思 四、注释 1、什么是注释？注释就是语言里面提供给咱们作为解释代码意思的一个\"工具\" 2、注释特点，浏览器不识别它，写给自己看的 3、语法： 注意点：注释中间的杠可以有很多个，但是不能少于四个 五、HTML5基本结构 1、html5基本结构是html语言执行的一个环境 2、结构语法： 欢迎来到肖宇真爱有缘网 这是html语言的基本结构 3、乱码： 注意点：如果没有设置meta标记的话，在低版本的浏览器里面会出现乱码问题 六、HTML语法 1、html语法分为两种，常规（对儿、双）标记、单（空）标记 常规标记： 单标记： 2、说明： 把尖括号（<>）里面的第一个单词叫做标记、标签、元素 把尖括号里面的标记空格后面的单词称之为属性，属性和属性值是使用等号连接的，属性值是放在双引号里面。一个标记可以有多个属性，也可以没有属性。有多个属性的时候，属性和属性之间不分先后顺序 单标记必须使用斜杠结束 七、站点 1、站点其实就是归纳网站里面素材的地方 2、站点目录结构 目录结构解释： css文件夹，放css文件的地方 html文件夹，放子页面的地方 images文件夹，放图片的地方 js文件夹，放js文件的地方 index.html 主页面（首页） 注意点：首页必须命名为index，不然上传到服务器上面会不识别 3、命名规则 文件命名规则：用英文，不用中文 名称全部用小写英文字母、数字、下划线的组合，其中不得包含汉字、空格和特殊字符；必须以英文字母开头 首页必须命名为index.html 八、常用标记 基本标记 1、标记是告诉浏览器这个东西是什么意思，不是让你知道，因为学习的是计算机语言 2、h1-h6 标题 + h1一级标题一个网页中只能有一个，搜索权重比较高的 + 特点：独占一行，自上而下排列的 + 属性：align=\"left|center|right\" 文本水平对齐方式 3、p 段落 + 特点：独占一行，自上而下排列的 + 属性：align=\"left|center|right\" 文本水平对齐方式 4、br 换行 + 单标记 + 特点：独占一行，自上而下排列的 5、hr 水平线 + 单标记 + 特点：独占一行，自上而下排列的 + 属性：color=\"颜色值\" 水平线的颜色 6、em、i 倾斜 + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 7、b、strong 加粗 + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 8、预留字符 + 带有某种功能的符号 + &nbsp; 表示空格 + &times; 乘号 + &lt; 小于 + &gt; 大于 + &copy; 版权符号 圈c 列表标记 9、列表标记 a、导航、新闻 b、列表标记三大类 + 无序列表 ul li + 在实际开发中使用最多的 + 有序列表 ol li + 属性：type=\"number|A|a|I\" 列表符号类型 + 自定义列表 dl dt dd + dl dt放的是名词或者是图片 dd放的是解释 + 如果遇到标记嵌套标记的情况，把外层的标记称之为父标记（元素），里面的标记叫做子标记（元素） + 特点：独占一行，自上而下排列的 列表标记示例代码 千里跃进之挑战不可能 实现中华民族伟大复兴 胸怀千秋伟业 恰是百年风华 百年正道 专题 新华网评：今天的中国，多希望你们能看到 千里跃进之挑战不可能 实现中华民族伟大复兴 胸怀千秋伟业 恰是百年风华 百年正道 专题 新华网评：今天的中国，多希望你们能看到 美女 闭月羞花，沉鱼落雁。。。 日本美女 嘿嘿！肖宇最懂 超链接标记 10、a超链接 + 可以让咱们点击文本的时候进行页面跳转 + 属性：href=\"地址\" 要跳转的地址（路径） target=\"_blank|_self\" 新窗口打开 _blank 当前窗口（默认）_self + 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格 超链接示例代码 百度一下，还是不知道 东哥最喜欢奶茶 图片标记 11、img图片标记 特点：横向排列的，如果标记在代码里面手动换行后标记与标记之间有一个空格。单标记 属性： + src 路径 + width 宽度 + height 高度 + title 标题，当鼠标悬停在图片上面的时候显示，默认是隐藏的 + alt 提示信息，当图片由于某种特殊（路径错误、网络比较慢、被和谐了）原因无法加载的时候给用户一个提示 路径问题 + 绝对路径，带有盘符的路径、或者网络地址 + 相对路径，在一个大的目录下，分级进行操作 + 当前文件指的是网页，目标文件指的是图片 + ./表示当前目录（可以省略） ../表示返回上一级目录 a、当当前文件与目标文件在同一目录下时，直接写目标文件名+扩展名 b、当当前文件与目标文件的文件夹在同一目录下时，先写目标文件夹名/目标文件名+扩展名 c、当当前文件的文件夹与目标文件的文件夹在同一目录下时，先../目标文件夹名/目标文件名+扩展名 表格标记 12、table表格标记 + 特点：独占一行，自上而下排列的 + 表格作用：显示数据，后台页面使用比较多 + 表格组成：table tr（行） td（列---单元格） + 属性： border 边框 width 宽度 height 高度 align=\"left|center|right\" 水平对齐方式使用规则 a、如果设置在table上面表示的是整个表格的水平对齐方式 b、如果设置在tr上面表示整行的水平对齐方式 c、如果设置在td上面表示单元格的水平对齐方式 valign=\"top|middle|bottom\" 垂直对齐方式 不能给table设置 bgcolor背景颜色 使用规则： a、如果设置在table上面表示的是整个表格的背景颜色 b、如果设置在tr上面表示整行的背景颜色 c、如果设置在td上面表示单元格的背景颜色 bordercolor 边框颜色 只能给table设置 cellspacing 表示单元格与单元格之间的间隙 cellpadding 表示单元格内容到边框之间的距离 rowspan 合并行 合并上下 colspan 合并列 合并左右 day03-form表单、网页标记 day03笔记 一、form表单标记 1、form标记 作用：收集用户信息，发送给服务器 特点：form是独占一行，自上而下排列的 属性： name 表单的名称，用于区分不同的表单 method 表单提交方式 get post action 表单提交地址，在实际开发中是一个后台地址（login.php） 注意点：表单必须配合其他的表单标记一起使用 2、get和post区别 get是从服务器上面获取数据（百度搜索、其他网站搜索），post是向服务器传输数据（登陆、注册） get是没有经过加密的，所以安全性没有post高，post是通过http post机制加密过所以比较安全 get传输的数据在url（浏览器的地址栏）里面可以看得到，而post是看不见的 get传输的数据量有限定（一般2kb左右），post理论是没有限定的。get执行效率比post高 get数据量示意图: 3、input标记 input标记有不同的类型 input标记它的功能是由type属性的属性值决定的 特点：横向排列的 属性： name 表单的名称，为了区分不同的表单框 value 表单的值，表单默认显示的信息 placeholder 表单默认显示的信息 4、value和placeholder属性区别 value设置的信息，当用户输入内容的时候不会自动消失。value属性可以让js通过它拿到表单的内容 placeholder设置的信息，当用户输入内容的时候会自动消失。是H5标准里面新增的属性 5、表单标记 6、其他表单标记 肖宇真爱有缘网 欢迎张必聪来到，肖宇真爱有缘网 请花一分钟完善你的个人资料，请真实填写不能欺骗小姐姐 诚意宣言:&nbsp;我抱着严肃的态度，保证不偏财不偏财不骗人 我是: 男 女 生日： -请选择- 1990 1991 1992 年 -请选择- 1 2 3 月 -请选择- 1 2 3 日 兴趣爱好：吃饭 睡觉打豆豆 婚姻状况：未婚 离婚 丧偶 注册方式：手机注册 我的手机号: 验证码: 密码: 内容独白 按钮 二、网页布局标记 标记介绍 div网页布局标记 + 分割，区域。 + 特点：独占一行，自上而下排列的 + 作用：用于把网页划分成不同大小的区域，区块。主要用于网页结构的外层布局 浏览器控制台 + 浏览器控制台是浏览器提供给开发者的一个调试工具，可以在控制台里面可以看到源代码 + 打开控制台的方法 1、直接按下F12键，不能精确的定位需要的地方 2、把鼠标移动到目标区域，然后鼠标右键 --- 选择检查（审查元素）--- 点击进去 浏览器控制台示意图 三、文本结点标记 span文本结点标记 + 主要用于某个段落里面某个字或者词区分 + 特点：横向排列的 + 最大好处是自身没有带任何默认的样式 示例代码 html结构代码 警校生公交上抓贼被威胁后霸气回怼。近日，湖北一公交车上，女子发现钱包被偷，一中国人民公安大学学生挺身而出抓住小偷。面对小偷威胁，学生呵斥 css样式代码 span{font-size:30px;color:red;} 四、css介绍和语法 css层叠样式表 + 层叠在css里面表示的是规则，指的是css里面的一些规则 + 样式表，是css给咱们提供的编写css代码的一个环境。html和css是两个不同的语言，每个语言执行都有自己的规范，也需要自己的环境，样式就是css代码执行环境，也可以理解为是html和css代码之间沟通的一个\"桥梁\" + css是web表现标准语言，web标准指的是网页制作要遵循的规范，html结构、css是表现（样式）、js（行为） + css的作用是对网页信息显示进行控制，网页信息，文本、图片、音频、视频、超链接等等，无论是图片还是文字都是放在html里面的。解释，css的作用就是美化html标记使用的 css语法 + css语法由两部分组成，选择器（选择符）和声明组成 + 选择器表示要定义样式的对象（理解：你给谁加样式，谁就是那个对象），可以是标记名称也可以取名称的标记。选择器就是把标记选取出来给其设置样式，也一个\"小工具\" + 声明分为属性和属性值，属性和属性值是使用冒号连接的，分号结束的。当一个属性有多个属性值的时候，不分先后顺序 + 声明必须放在花括号里面 + 属性和属性之间换行空格不影响实际的效果 + 注意点：html属性和css属性不能混用 语法示意图 五、css样式表 1、内部样式表 通过一个style标记，在style标记内部编写css代码，style标记的作用就是执行css代码 属性：type=\"text/css\" 定义文档类型 可以省略，但是不能写错 适用于代码量较少的时候使用 代码示意图 div{ width:200px; height:200px; background-color:hotpink; } 2、外部样式表 通过一个link标记，引入一个外部的css文件，在css文件里面编写css代码 属性： rel=\"stylesheet\" 关联样式表，就是把html文件和css文件连接起来 type=\"text/css\" 定义文档类型 可以省略，但是不能写错 href=\"地址\" 路径 适用于代码量较多的时候，实际开发中使用最多的 代码示意图 3、内联样式表 内联样式表也叫行内样式表 通过一个style属性，在属性值里面编写css代码 偶尔使用 代码示意图 网页布局使用的 4、样式位置问题 代码是自上而下执行的，在本地环境下设置在头部区域或者其他区域是看不出效果的，如果在服务器环境下可以看出区别 在实际的开发中推荐设置head区域 六、选择器 1、选择器表示要定义样式的对象，可以是标记本身也可以是标记取名称。css给咱们提供了很多种选择器，帮助咱们解决各种冲突和问题 2、标记选择器（标签）、类型选择器 + 语法：标记{} + 可以给同一类型的标记都设置样式 3、class选择器 + 语法: css：.名称{} html： + 通过取名区分同一类型的标记，限定了样式起作用的范围 + class可以取多个名称 4、id选择器 + 语法: css：#名称{} html： + id选择器具有唯一性，一个标记对应的只能有一个id名称 5、包含（后代）选择器 + 语法: css：标记1 标记2{} html: + 限定样式起作用的范围 七、权重 + 权重是选择器的规则 + 权重是每一种选择器自带的一种特性，这种特性可以用于解决样式冲突问题 + 权重默认是以四位数表示 0 0 0 0 + 标记选择器权重：0 0 0 1 + class选择器权重：0 0 1 0 + id选择器权重：0 1 0 0 + 后代（包含）选择器权重：包含选择器之和 + 伪类选择器权重：0 0 1 0 + 内联样式表的权重：1 0 0 0 + 通配符的权重：0 0 0 0 通配符对权重没有贡献 + 权重具有就近原则 day04-css、选择器 day04笔记 一、css层叠性 概念：一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则， 这就是层叠。 这些规则中有些是没有冲突的可以同时起作用，然而有些规则是相互冲突的。当发生冲突的时候必须选出一条最高特殊性(权重)的规则来应用，以优先级高的权重为标准 注意点：在样式表里面叫做优先级，在选择器里面叫做权重 二、外部样式表补充 样式表分类 link标记直接引入外部css文件使用 结合内部样式表一起使用，然后引入外部css文件 import url() 样式表代码： @import url(css/a.css); link和import区别： 1、本质区别，link属于html（xhtml）提供的标记，而import属于css提供的一种方式 2、加载顺序，link可以让结构和样式同时加载，而import先加载结构再加载样式（跟代码顺序有关） 3、兼容问题，link是没有兼容问题的，import一些老版本的浏览器不支持（低版本的IE浏览器） 4、控制DOM（document object model 这是js给咱们提供操作标记的一种方式）时的区别，link可以被DOM操作或者控制，import无法被操作 三、HTML发展划分 从大范围进行划分，HTML是第一个版本，XHTML是第二个版本，HTML5是第三个版本（最新版本） HTML和XHTML的区别： XHTML是HTML的严格模式，语法更为规范或者严谨 XHTML区分大小写，标记必须闭合，声明文档类型更为复杂 XHTML要求必须有根标记 四、群组和伪类选择器 群组选择器 + 语法： css：选择器1,选择器2,选择器3...{} + 注意点：最后一个选择器不能有逗号 + 可以一次性给不同类型的标记设置样式 代码示意图 h1, p, span{color:red;} 伪类选择器 + 伪，假的意思。跟选择器很像但是又有区别 + 伪类其实描述的是某种状态 + 语法： a:link 鼠标的初始状态 a:visited 鼠标访问过后的状态 a:hover 鼠标悬停时的状态 使用最多的 a:active 鼠标激活（把鼠标按下去不动）时的状态 + 注意点：伪类选择器默认会把状态进行缓存，如果想要回到初始状态必须清除浏览器缓存才行 代码示意图 a:link{color:red;} a:visited{color:yellow;} a:hover{color:hotpink;} a:active{color:green;} 五、背景属性 + 分写形式 background-color 背景颜色 background-image:url(); 背景图 背景图显示规则： 1、当背景图小于容器大小时，背景图会默认平铺 2、当背景图大于容器大小时，背景图某些部分显示不完整 3、当背景图等于容器大小时，背景图刚好显示下 background-repeat:repeat（平铺）|no-repeat（不平铺）|repeat-x（水平平铺）|repeat-y（垂直平铺）; 平铺属性 background-position:left|center|right|top|bottom|number; 背景图位置属性 缩写形式 background-position-x 水平位置 background-position-y 垂直位置 background-attachment:fixed（固定）|scroll（滚动，默认值）; 背景图固定属性 + 缩写形式 background:值1 值2 值3 值4; 六、导航案例 效果图 css样式代码 /*清除内外边距*/ *{margin:0;padding:0;} ul{ width:800px; height:40px; background-color:#01204f; /*值1表示上下 值2表示左右*/ margin:0 auto; margin-top:50px; } ul li{ /*清除列表符号 li的点点*/ list-style:none; /*让竖着的东西横着排列*/ float:left; line-height:40px; font-size:14px; /*想要的效果是让元素左右有距离同时鼠标划过的时候让自身变大，padding表示的就是内容到元素边框的距离，填充*/ padding:0 10px; } ul li a{ /*清除超链接下划线*/ text-decoration:none; color:#fff; } ul .first{ padding-left:30px; background-color:#cc0000; background-image:url(images/icon.png); background-repeat:no-repeat; background-position:8px 8px; } /*当鼠标划过li标记时让其改变背景颜色*/ ul li:hover{ background-color:#cc0000; } html代码 首页 国内 军事 国际 财经 娱乐 体育 互联网 科技 游戏 女人 汽车 房产 七、margin和padding属性 margin和padding值书写形式 margin外边距（边界） + 指的是元素与元素之间的距离 + 分写值形式 margin-left 左边距 margin-right 右边距 margin-top 上边距 margin-bottom 下边距 + 缩写值形式 + margin:值1; 表示上右下左四个方向都一样 + margin:值1 值2; 值1表示上下 值2表示左右 + margin:值1 值2 值3; 值1表示上 值2表示左右 值3表示下 + margin:值1 值2 值3 值4; 值1表示上 值2表示由 值3表示下 值4表示左 padding内边距（填充、补白） + 指的是元素内容到边框之间的距离 + 控制的内容的位置，设置了padding属性后会把元素本身给撑大，如果想要保持元素原有大小不变，需要从元素上面减去设置的padding值。左右padding从宽度上减去，上下padding从高度上减去 + 分写值形式 padding-left 左边距 padding-right 右边距 padding-top 上边距 padding-bottom 下边距 + 缩写值形式 + padding:值1; 表示上右下左四个方向都一样 + padding:值1 值2; 值1表示上下 值2表示左右 + padding:值1 值2 值3; 值1表示上 值2表示左右 值3表示下 + padding:值1 值2 值3 值4; 值1表示上 值2表示由 值3表示下 值4表示左 + 元素的内容分为文本和标记 + 当子元素是独占一行，自上而下排列的。容器（父元素）设置了宽度，子元素没有设置宽度的时候，它的宽度会跟随容器 + padding使用注意事项： 1、当元素的内容是文本的时候，想要控制内容的位置只能使用padding 2、当元素的内容是标记的时候，既可以使用margin也可以使用padding怎么选择呢？那个简单使用那个 3、那种情况下使用了padding值不需要减去。当子元素是独占一行自上而下排列的，它没有设置宽度，它自身的宽度根据容器来的，这个时候使用了padding也不需要减去 标记结构信息图 八、网页注意事项 知识点1：当容器没有设置高度的时候，容器里面有图片的情况下，图片会默认把容器底部撑大几像素 知识点2：input标记会默认自带2px边框，input默认带有蓝色的轮廓。取消边框border:none|0; 取消轮廓：outline:none; 知识点3：横向排列的元素，在代码排列的时候手动换行后，元素与元素之间会默认有间隙。清除间隙 float:left; 知识点4：浏览器默认支持的最小文字大小是12px，如果小于12px以12px显示 知识点5：a超链接标记的文本颜色不能继承父元素的，只能设置在自身上面 九、PS标尺工具 ps标尺工具可以帮助咱们获取参考线，ctrl+R如果快捷键不起作用，找到视图---标尺就可以 day05元素类型 day05笔记 一、元素类型 在css里面默认把元素（标记）划分成了三个类型 + 块级元素 block + 特点：独占一行，自上而下排列的，可以设置宽度和高度 + div、h1-h6、ul、li、ol、form、p、hr、br、table、dl、dt、dd等等 + 注意点：块级元素如果子元素没有设置宽度，它的宽度默认会跟随容器（父元素） + 内联（行内）元素 inline + 特点：横向排列的，不能设置宽度和高度 + span、em、i、b、strong、font等等 + 注意点：内联元素设置了浮动属性后可以设置宽度和高度，因为float属性改变了span标记原有的规则 + 内联（行内）块元素 inline-block + 特点：横向排列的，可以设置宽度和高度 + input（text、password、checkbox、radio、submit、button）类型、select、textarea、img、button等等 week2 day06笔记 一、浮动介绍 语法： float:left|right|none; 作用：让竖着的东西横着来，可以让一行排列多个元素 定义：文本如何环绕该元素显示 环绕现象效果图 css样式代码 *{margin:0;padding:0;} .box{ width:600px; height:200px; border:1px solid red; margin:50px auto; padding:20px; } .box img{ width:100px; height:100px; float:left; margin:10px; } .box p{ font-size:14px; line-height:26px; } html结构代码 进入2021年以来，世界格局暗流涌动，瞬息万变。风云激荡之间，国际社会充斥着若隐若现的危机。 正所谓，多行不义必自毙，出来混迟早是要还的！一向在中东地区横行霸道——经济制裁伊朗、空袭叙利亚领土、偷盗叙利亚石油、给伊拉克带去常年战争的美国，最近可算是尝到了“现世报”的滋味。 自从拜登上台以后，美国各州似乎经常进入紧急状态。有时候是因为自然灾害，有时候又是一天前，美军驻伊拉克阿萨德空军基地，和美国驻巴格达大使馆，分别遭遇火箭弹和无人机轰炸；一天后，伊拉克机场被炸，美军基地再次遇袭。因为遭受网络袭击。 二、认识流 流介绍 + 流在css里面指的是规则，层叠指的也是规则 + 标准（文档、普通）流，就是正常的网页排版顺序 规则： + 块级，独占一行，自上而下排列，可以设置宽和高 + 内联，横向排列的，不能设置宽和高 + 内联块，横向排列的，可以设置宽和高 + 浮动流，一个标记设置了float属性就成为浮动流（脱离文档流 --- 脱标） 浮动背后的故事 float属性最开始设计出来的作用就是做文本环绕的，后面随着大家使用越来越多突然发现它还有其他的功能，可以让自上而下排列的元素横向排列 生活中的例子，可乐，一开始是一个医生研制的一款糖浆针对于治疗某种疾病，结果发现没有多大作用这个医生发现它的口感还不错，最后就发展了一款饮料 浮动的使用注意事项 两个div，第一个设置了浮动属性，第二个没有设置，这个时候第一个会把第二个给覆盖掉。原因：第一个div设置了浮动后脱离文档流，原先的位置会发生改变，浮动流是漂浮在标准流之上的，标准流之前没有东西了后面的元素要上去进行补位操作 两个div，第二个设置了浮动属性，第一个没有设置，这个时候它们的位置保持不变。原因：第一个div是标准流会继续占文档中的位置，所以第二个浮动的元素它的位置保持不变，但是它会影响它自己后面的元素 两个div，都设置了浮动属性，如果容器的宽度不够的情况下第二个div依旧会被挤到第二行排列 三、清除浮动 为什么清除浮动 清除浮动并不是把设置的浮动直接删除而是清除浮动给咱们带来的负面影响。负面影响，高度塌陷和高度塌陷引起的元素重叠问题。 高度塌陷：在实际的开发中容器的高度要求自适应，当容器没有设置高度的时候子元素设置了浮动会引起高度失效（塌陷），把这种现象称之为高度塌陷问题 清除浮动方法 使用clear:both|left|right;清除浮动，提前条件是在需要清除浮动的同级元素下设置一个空（除了设置clear以外不能有其他任何属性）元素，然后给其设置clear属性 直接给容器设置overflow:hidden;属性 注意点：并不是只要设置了浮动就需要清除浮动，而是发生了高度塌陷这种问题才需要清除浮动 四、overflow溢出属性 语法： overflow:visible; 默认值，不隐藏 overflow:auto; 如果溢出则出现滚动条，出现横向或者纵向滚动条主要看内容，如果没有溢出不会出现任何滚动条样式 overflow:scroll; 出现滚动条，无论内容溢出与否都会出现滚动条的样式（横向、纵向的） overflow:inherit; 继承 作用： 可以让内容溢出后隐藏 清除浮动 解决margin-top兼容问题 五、margin-top问题 问题： 当给子元素设置了margin-top后，浏览器在解析的时候会误认为给容器设置的所以会出现整体往下掉的情况 前提条件： 必须是元素嵌套元素的情况下 注意点： 只会在标准流中出现 解决方案： 直接给容器设置overflow:hidden; 如果子元素或者父元素设置了浮动属性也不会出现问题 只要触发了BFC都可以解决 给父元素添加padding-top：0.1px；使子元素与父元素分离也可以解决 标准流中出现问题的条件（了解）： 子元素和父元素都是背景颜色的时候会出现 父元素是背景颜色，子元素是边框的时候会出现 父元素设置了边框，子元素是背景颜色的时候不会出现 父元素和子元素都是边框的时候不会出现 day07笔记 一、文本属性 字体大小问题： 浏览器默认字体大小是16px，最小支持的字体大小是12px（谷歌浏览器下，ie浏览器可以变得更小） 同样字号的文字，如果字体不同最终在页面里面呈现的效果不一样 单位问题： px像素，是网页最基本的单位，也是使用最多的 pt点（磅），这个是打印行业里面的一个单位，可以保证打印出来的东西不改变 9pt=12px 3/4 0.75 em相对于容器字体大小的一个单位，是可以动态改变的 1em = 16px 颜色值问题： 英文单词形式（red、orange、blue、white、green、yellow、pink、purple、black等等） 十六进制颜色值 例如：#fff #000 #ccc rgb()形式 计算机三原色 red、green、blue 相关属性： font-family:字体1，字体2，字体3 说明：浏览器首先会寻找字体1、如存在就使用改字体来显示内容，如在字体1不存在的情况下，则会寻找字体2，如字体 2也不存在，按字体3显示内容，如果字体3 也不存在；则按系统默认字体显示； 当字体是中文字体时，需加双引号； 当英文字体中有空格时，需加双引号如（“Times New Roman”） 当英文字体只有一个单词组成时不加双引号；如：（Arial）； Windows中文版本操作系统下，中文默认字体为宋体或者新宋体，英文字体默认为Arial font-weight:bolder(更粗的)/bold（加粗）/normal（常规）/100—900; 说明：在css规范中，把字体的粗细分为9个等级，分别为100——900，其中100对应最轻的字体变形，而900对应最重的字体变形， 100-400 一般 500常规字体 600-900加粗字体 font-style：italic/oblique/normal（取消倾斜，常规显示）; 说明： italic和oblique都是向右倾斜的文字, 但区别在于Italic是指斜体字，而Oblique是倾斜的文字，对于没有斜体的字体应该使用Oblique属性值来实现倾斜的文字效果. 文字属性简写：font:12px/24px \"宋体\"; font属性的简写：字号，行高，字体 font-size:12px; line-height:24px; font-family:”宋体”； font属性的简写： 说明:font的属性值应按以下次序书写(各个属性之间用空格隔开) 顺序: font-style font-weight font-size / line-height font-family (1)简写时 , font-size和line-height只能通过斜杠/组成一个值，不能分开写。 (2) 顺序不能改变 ,这种简写法只有在同时指定font-size和font-family属性时才起作用,而且,你没有设定font-weight , font-style , 他们会使用缺省值（默认值） 文本修饰 text-decoration:none/underline/overline/line-through 说明： none:没有修饰 underline:添加下划线 overline:添加上划线 line-through:添加删除线 首行缩进：{text-indent:value;} 说明：首行缩进2个字 text-indent:2em; A）text-indent可以取负值； B）text-indent属性只对第一行起作用。 字间距 letter-spacing:value; 控制英文字母或汉字的字距。（英文字母和字母） 二、列表属性 1)定义列表符号样式 list-style-type：disc(实心圆)/circle(空心圆)/square(实心方块)/none(去掉列表符号)；list-style-type:none===list-style:none; 2)使用图片作为列表符号 list-style-image：url(所使用图片的路径及全称)； 3)定义列表符号的位置 list-style-position:outside(外边)/inside(里边)； list-style:none;去掉列表符号 三、常见图片格式 jpg :有损压缩格式，靠损失图片本身的质量来减小图片的体积，适用于颜色丰富的图像;(像素点组成的，像素点越多会越清晰 ) gif：有损压缩格式，靠损失图片的色彩数量来减小图片的体积，支持透明，支持动画，适用于颜色数量较少的图像; png:无损压缩格式,图片本身质量没有损失，支持透明，不支持动画，是fireworks的 源文件格式，适用于颜色数量较少的图像; 四、盒模型 概念：css规定把所有HTML元素都可以看作成一个盒子，在CSS中，盒模型是用来设计和布局时使用的。 盒模型本质上是一个盒子，它的作用是封装周围的HTML元素。盒模型组成：边框（border）、边界（margin）、填充（padding）、内容区（content）。 盒模型计算： 盒模型的宽度 = 左右margin + 左右padding + 左右border + width 盒模型的高度 = 上下margin + 上下padding + 上下border + height 盒模型的宽度和高度才是一个标记真正在网页所占的位置的大小 空余空间(了解)： 说明： white-space：normal/nowrap/pre/pre-wrap /pre-line /inherit 该属性用来设置如何处理元素内的空白； normal：默认值，空白会被浏览器忽略， nowrap:文本不会换行，文本会在同一行上继续，直到遇到标签为止； pre：空白会被浏览器保留，其行为方式类似HTML中的pre标签； pre-wrap：保留空白符序列，但是正常的进行换行； pre-line:合并空白符序列，但是保留换行符； inherit：规定应该从父元素继承White-space属性的值；(ie浏览器不支持此属性值) 五、省略号 1、容器宽度：width：value； 2、强制文本在一行内显示:white-space：nowrap; 3、溢出内容为隐藏：overflow：hidden； 4、溢出文本显示省略号：text-overflow：ellipsis; /*第一步：元素必须设置宽度*/ width:200px; height:200px; border:1px solid; margin:30px; /*第二步：文本强制不换行*/ white-space:nowrap; /*第三步：文本溢出隐藏*/ overflow:hidden; /*第四步：出现省略号*/ text-overflow:ellipsis; 六、 markdown文档 markdown介绍： + markdown文档和word还有ppt等等是类似的文档，后缀名是.md + 支持图片、文本、超链接、标记的使用，markdown格式可以转换成其他的文档类型 + 网站中的博客、微信公众号、还有公司里面很多的技术文章都是采用markdown文档格式，使用非常普通 markdown编写工具： + 专门直接下载其他的 + vscode、HBuilderX都可以编写 + typora工具（目前是使用最多的） GitHub 这个是世界上最大的同性交友中心，交流技术 七、元素类型转换 元素类型转换 + 在实际开发中开发需要是多样的，所以有时候需要把一种类型转成其他类型 + 使用display属性进行元素类型换行 + display属性 1、block 把其他类型转成块级元素，让隐藏的元素显示 2、inline 3、inline-block 4、none 让显示的元素隐藏 5、组合使用 display:block; display:none; + 注意点：内联块元素不能转成内联元素，因为内联块元素默认都有内置的样式 + display需要了解的值 1、list-item 列表类型 2、table 表格类型 3、inline-table 行内表格类型 4、table-cell 单元格类型 元素类型使用注意事项 + 不要在p标记里面嵌套其他的块级元素 + margin和padding上下值给内联元素设置的时候有问题的，不会起作用 背后的故事： 1、最早的时候css把标记默认类型划分成了两种，块级元素、内联（行内）元素 2、随着大家的使用发现inline和inline-block有不同的区别，所以在css2.1里面新增了一个内联块元素 块级、内联、内联块 3、有人提出不从元素的特点上进行划分，直接把元素划分成两种类型，置换元素和非置换元素 a、置换元素指的是html标记默认带有css格式化以外（没有通过css设置样式，标记默认自带的）的样式的标记 input所有的类型、select、textarea、button、img等等 b、非置换元素，除了置换元素以外的其他元素 day08笔记 一、导航 home about us home about us home about us home .nav3{ width:800px; height:20px; border-bottom:8px solid #db4e18; margin:50px auto; } .nav3 li{ font-size:14px; line-height:20px; float:left; width:80px; height:20px; background-color:#dfdfdf; text-align:center; margin-right:1px; } .nav3 .first{ margin-left:10px; } .nav3 li a{ color:black; display:block; } .nav3 li a b{ font-weight:normal; display:none; } .nav3 li:hover a span{ display:none; } .nav3 li:hover a b{ display:block; } home首页 home首页 home首页 home首页 home首页 home首页 home首页 二、vertical属性 vertical-align垂直居中属性 + 属性值：top、bottom、middle、baseline（基线） + 注意点：只对内联元素和内联块元素起作用 + 解决图片底部间隙问题 day09笔记 一、position定位属性 1、定位介绍 解释：定位简单来说就是让元素的位置发生改变或者叫做移动 语法：position:static（默认值，静态定位）|absolute（绝对定位）|relative（相对定位）| fixed（固定定位）; 定位属性必须配合这几个值一起使用left、right、top、bottom才会起作用 定位属性具有层叠性（规则）--- 叠加（可以让元素与元素之间进行叠加） 最后面定位的元素，排列在最上面 二、absolute绝对定位 特点： 脱离文档流的，所以它不占空间（位置） 不区分元素类型（设置了绝对定位后，不管元素以前是什么类型的，现在都要遵循定位的规则） 相对于祖先元素进行定位的（绝对定位要进行定位有一个查找规则，优先去找父级，看父级有没有定位流，如果有就以父元素进行定位，如果没有就继续往上一级进行查找，直到找到body还是没有定位流就以body进行定位） 三、relative相对定位 特点： 不脱离文档流的，所以要占位置 相对于自己以前在标准流的位置进行定位 区分元素类型（设置了相对定位，你以前是什么类型现在依旧是什么类型） 相对定位作用：可以对元素进行微调、最常用的是配合绝对定位一起使用（子绝父相） 四、fixed固定定位 特点： 脱离文档流，不占位置（空间） 不区分元素类型 相对于body进行定位的 不会随着滚动条的滚动而滚动 五、z-index定位层级属性 定位属性都有层级的特性，后面定位的会把前面定位的给覆盖 z-index属性是专门控制层级关系的 z-index:auto|number; 没有单位 可以为负值 day10笔记 一、锚点 点击对应a标签可以跳转到对应id的div 瓜娃子 日脓包 神戳戳 胎神 猪儿虫 二、透明度兼容 opacity属性 IE低版本的浏览器不支持opacity filter:alpha(opacity=value); value取值范围1-100，相当于opacity=0~1 opacity取值范围0-1 0.5 --- .5 opacity透明度问题 opacity会让子元素继承父元素的透明度 css3新增了一个方法 rgba() ，最后一个值表示透明度 三、字幕滚动属性 欢迎，肖宇哥哥来到我的直播间 谢谢！肖宇哥哥送的大保健 direction:滚动方向 scrollamount：滚动速度 四、CSS精灵图 图片整合技术 名称：css精灵、css sprite、雪碧图 把很多张小图整合成一张图，然后使用background-position去调整它的位置 ​ 网络请求问题： http超文本传输协议，规定了咱们如何去上网，做了统一的规范，在浏览器地址栏输入域名直接可以访问网站 http和https区别，https是比http要安全，因为它加密过 如合请求数据 1、当咱们在浏览器的地址栏（url）输入网址的时候并回车 --- 向服务器发送了请求（报文） 2、服务器接收到请求，进行判断（如果有这个资源，就返回需要的信息，如果没有也返回的提示）404 你的网页走丢了 3、浏览器接收到服务器返回的请求（html---图片、css、js） 图片加载问题： 一个网站里面有很多图片，图片在加载的时候特别的耗费网络带宽资源 针对于网站中的小图，需要做优化提供加载速度，而图片整合技术就可以做到 五、序号选择器 不区分类型： :first-child; 选中同级别中的第一个标签 :last-child; 选中同级别中的最后一个标签 :nth-last-child(n); 选中同级别中倒数第n个标签 :nth-child(n); 选中同级别中的第n个标签 :only-child; 选中同级别中唯一子元素标签 区分类型： :first-of-type; 选中同级别中同类型的第一个标签 :last-of-type; 选中同级别中同类型的最后一个标签 :nth-of-type(n); 选中同级别中同类型的第n个标签 :nth-last-of-type(n); 选中同级别中同类型的倒数第n个标签 :only-of-type; 选中同级别中同类型的唯一标签 奇偶选择： :nth-child(odd); 选中同级别中同类型的奇数标签 :nth-child(even); 选中同级别中同类型的偶数标签 :nth-child(nx+y); 选中同级别中同类型的第（nx+y）个标签（n从第0开始递增计数，到元素的总个数上限停止 week3 day11笔记 一、宽高自适应 1、 在实际开发中，大家发现每次把元素的宽度和高度直接固定的话不方便后期的扩展和内容增加，所以有人提出了宽高自适应的概念 2、 实现宽高自适应 不设置宽度和高度或者width:auto; height:auto; 宽高自适应其他方式 3、宽高自适应的新增属性 min-width 最小宽度 max-width 最大宽度 min-height 最小高度 元素一开始有一个固定的高度，当内容溢出时高度会自适应 max-height 最大高度 元素设置了一个最大高度，开始时元素高度是自适应的，当内容超出最大高度时会溢出 二、最小高度兼容 min-height兼容问题 描述：最小高度min-height在IE低版本的浏览器下是不支持的，正常的高度height在亲爱的的IE浏览器下相当于是最小高度 解决方案：利于IE浏览器的漏洞，使用下划线的过滤器的东西 min-height:100px; _height:100px; 在普通浏览器中只能识别min-height，不会识别 _height这个属性，而ie6等低版本浏览器不支持min-height，使用只有它能识别的 _height属性作为min-height来使用 ​ 最高优先级 关键字过滤器 !important，它表示所附加的声明具有最高优先级 语法：选择符（属性：属性值 !important;) 下划线过滤器：属性值前面增加一个下划线，符合标准的浏览器不能识别带有下划线的属性而忽略了这个声明，而IE6及更低版本可以解析 表示最高权重，覆盖一些别人的样式 三、百分比单位 介绍：百分比可以让元素实现自适应，比px单位更为灵活 应用：元素的最外层使用百分比，移动端 注意点：百分比是自适应的，但是需要参照物 1、font-size 相对于父元素的font-size来计算，如果父元素（以及它的祖先元素）未显式设置font-size值的话，将会以浏览器的默认值16px为基准。 2、line-height 基于元素自身的font-size的值来计算。如果元素自身未显式设置font-size，则会基于元素继承过来的font-size的值计算。 3、vatical-align 基于元素自身的line-height值计算。如果元素自身未显式设置line-height的值，那么元素会继承其父元素（或祖先元素）的line-height值。 4、text-inent CSS的text-indent属性可以让一个块元素首行文本内容的缩进量。有的时候也会使用该方法实现图像替换文本 它的计算是相对于元素块width（或height）计算，如果是逻辑属性的话，相对于inline-size（或block-size）计算。具体相对于width（inline-size）还是height（block-size）取决于CSS的书写模式（即受writing-mode和direction）。 5、width/height 相对于父元素的width/height。 6、magin/padding 相对于父元素的width 元素设置margin-left和margin-right值，而且都同时为正值时，元素自身的空间会被margin-left和margin-right挤压，当margin-left和margin-right两个属性的值之和等元素元素width时，该元素将在视图中不可见 元素margin-right的值为正值时且大到一定的值（一般容器剩余空间），那么将会挤压元素自身的width 7、position 当元素position的取值为relative或absolute时，那么元素的偏移属性的%值计算相对于离元素最近的设置了position为非static的元素的width和height。其中top和bottom相对于height计算；left和right相对于width计算。 如果元素的position显式设置值为sticky，那么偏移属性取%值的计算是相对于相关的滚动端口（Scrollport）的大小计算 滚动端口（Scrollport）是指文档（Document）中滚动容器（Scroll Container）的可视窗口。显式给元素设置overflow: scroll或overflow: auto（在内容足够导出溢出时产生）可以创建滚动容器。 8、border-radius 在border-radius使用%值时，它计算的相对值是需要分开来算的，其中 x轴的%值相对于元素的width值计算；y轴的%值相对于元素的height值计算 9、border-image border-image也是一个简写属性，它的子属性有 border-image-source、 border-image-slice、 border-image-width、 border-image-outset 和 border-image-repeat。其中border-image-slice和border-image-width取值也可以是% 相对于border-image-source引入的图像源尺寸进行计算，其中x方向相对于图像的width计算，y方向相对于图像的height计算 10、background-position 水平方向（x轴），相对于元素的width与背景图片的width差 background-position-x=(容器w-图片w)百分比 垂直方向（y轴），相对于元素的height与背景图片的height差 background-position-y=(容器h-图片h)百分比 特别声明，背景图片的大小将会受background-size值的影响，上面提到的图片的尺寸是指backgroud-size的值为100% 100%的情景下的尺寸，即背景图片的初始尺寸（原始尺寸）。 11、background-size background-size的第一个值是x轴方向，其计算相对于元素的width计算；background-size的第二个值是y轴方向，其计算相对于元素的height计算。 四、元素显示和隐藏 显示和隐藏： 1、visibility:hidden; 占位隐藏，虽然占位置但是元素是隐藏了的 2、display:none; 直接隐藏，元素的位置也会随着消失 3、opacity:0; 不叫隐藏，只是透明度为0了，你看不见它，类似于隐藏了，元素的功能依旧存在 ​ 溢出隐藏： overflow:hidden; 当内容超出时，隐藏超出的部分，并不是直接把元素进行隐藏处理 五、伪对象选择器 伪对象选择器： ::after：与content属性一起使用，定义在对象后的内容 ::before：与content属性一起使用，定义在对象前的内容 ::first-letter：定义对象内第一个字符的样式（只能用于块级元素） ::first-line：定义对象内第一行的样式（只能用于块级元素，ie6以下不支持) 让css选择器可以直接给标记添加内容 添加内容的行为变的多样了 权重为1 div::after{ /*必须设置，为空也要设置不然不起作用。添加的元素是内联类型*/ /* content: \"肖宇\"; */ /* content: url(images/11.jpg); */ content: \"\"; width: 50px; height: 50px; background-color: green; display: block; } 六、浏览器兼容问题 浏览器大战： window系统市场占用率是非常高的，IE浏览器是捆绑在window系统里面的，所以一开始使用的人非常多 软件捆绑，一不小心下载了全家桶，微软才是这方面的鼻祖 那个时候IE浏览器算比较好用的东西了，微软把浏览器的团队给解散了，这个网景（JavaScript）公司出了一个马赛克浏览器 争夺市场，没有结果，到了后面谷歌、欧朋、火狐这些浏览器的出现比所谓的马赛克还有IE浏览器更好用了，所以它们争夺市场 微软发现如果再不做出更新估计要凉了，所以把之前的团队的召集起来了做出了IE9，IE9和其他的浏览器基本上都差不多了 做兼容，以IE8作为分界线，以上问题不大，以下问题很大 ​ 五大浏览器内核 ​ •Trident （MSHTML） （三叉戟；三叉线；三齿鱼叉） ​ •Gecko （壁虎） ​ •Presto （ 迅速的） ​ •Webkit （Safari内核,Chrome内核原型,它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核） ​ •Blink (由Google和Opera Software开发的浏览器排版引擎)。 CSS Hack：CSS中，Hack是指一种兼容CSS在不同浏览器中正确显示的技巧方法 图片间隙问题： 描述：当容器没有设置高度的时候，图片会默认把容器底部撑大几像素 解决方案： display:block; vertical-align:top; float:left; 蓝色边框问题： 描述：当超链接里面放了图片标记，在IE浏览器下图片会出现蓝色边框 解决方案： border:none; border:0; 表单问题1： 描述：表单元素默认距离浏览器顶部不一致 解决方案： 使用float:left;属性 表单问题2： 描述：按钮标记在各个浏览器里面样式不一样 解决方案： 使用背景图 重新设置样式 使用a标记模拟 表单问题3： 描述：在低版本的IE浏览器下表单中的文字是以顶部对齐的 解决方案： 设置line-height cursor兼容问题： 描述：cursor:hand; 表示鼠标手型，在高版本的浏览器里面不支持，IE低版本的浏览器支持 解决方案： cursor:pointer; margin-top问题 问题： 当给子元素设置了margin-top后，浏览器在解析的时候会误认为给容器设置的所以会出现整体往下掉的情况 前提条件： 必须是元素嵌套元素的情况下 注意点： 只会在标准流中出现 解决方案： 直接给容器设置overflow:hidden; 如果子元素或者父元素设置了浮动属性也不会出现问题 标准流中出现问题的条件（了解）： 子元素和父元素都是背景颜色的时候会出现 父元素是背景颜色，子元素是边框的时候会出现 父元素设置了边框，子元素是背景颜色的时候不会出现 父元素和子元素都是边框的时候不会出现 opacity透明度问题 问题描述： IE低版本的浏览器不支持opacity 解决方案： 使用过滤器filter:alpha(opacity=value); 取值范围1-100 opacity取值范围0-1 0.5 --- .5 注意点 opacity会让子元素继承父元素的透明度 css3新增了一个方法 rgba() ，最后一个值表示透明度 day12笔记 一、form表单相关 文本框 密码框 单选按钮 注意点：同一组的单选按钮的name属性必须设置，属性值必须一样，不同组的单选按钮name的属性值不一样 复选框 disabled禁用，给按钮使用比较多 checked默认选中 下拉菜单 option的html属性 value给js使用的 selected是option那个选项排列在第一位 1990 1990 1990 多行文本域 按钮 提交按钮 H5新增表单内容 上传文本框 图像按钮 标签 用户名： 使用for属性绑定input的id，点击lable标签，可以是对应的input输入框获取焦点 表单字段集 可以嵌套使用 作用：用来给表单进行分组的，根据内容不同进行分组, 字段集标题 align:left|center|right 个人信息 用户名 电子邮箱 密码 二、表格相关 完整的表格组成 table ：表格 显示数据 caption ：表格的标题，属性caption-side：top|bottom定义标题的位置，left和right有兼容问题很少使用 注意点：要放table里面才会起作用 thead ：表头 ，tr th表头的标题 tbody ：表体 tr td 注意点：当咱们不写tbody的时候，表格会默认给在咱们添加一个 tfoot ：表尾 tr td cellspacing属性：表示单元格与单元格之间的间隙 cellpadding属性：表示单元格内容到边框之间的距离 rules属性：规定内侧边框的哪个部分是可见的。 rules：none没有线条|groups行组和列组之间的线条|rows行之间的线条|cols列之间的线条|all行和列之间的线条 border-spacing属性：指的是单元格与单元格之间的间隙 border-collapse:collapse：合并单元格的边框，会忽略 border-spacing 和 empty-cells 属性。（默认值separate） table-layout:fixed; ：表格固定属性，单元格大小不会随内容而改变（默认值automatic） enpty-cells:hide; ：单元格为空时隐藏，无内容隐藏（默认值show） 行分组 thead、tbody、tfoot 学员信息 姓名 性别 年龄 学号 肖宇 男 18 6666666 肖宇 男 18 6666666 张必聪 男 16 8888888 吴亦凡 男 32 3333333 都美竹 女 19 6666666 王思聪 男 36 0000000 列分组 html用属性span来把表格分成几组 --> 三、关于标题 使用borde-top+h3定位来实现 四、关于站点 1、站点作用：用来归纳网站里面的素材，方便开发使用 2、站点的简单目录结构 3、简单的站点的目录结构在实际的开发中不会使用，目前公司里面的开发都是采用的工程化形式和叫做模块化 工程化：不会直接采用传统的引入文件什么东西，会让工具帮助咱们做一些事情，代码需要压缩和打包，gulp工具 模块化：目前框架里面都是使用的模块化的开发思维、vue、react都是这种的 要采用实际开发中的目录结构 src目录表示源代码（文件）目录 img目录 放图片资源的 css目录 放样式文件的 js目录 放js文件的 html目录 放html文件的 font目录 放字体文件的 libs目录 放引入的一些库或者框架的第三方文件目录 video目录 放视频资源的目录 dis目录是源代码（文件）打包压缩后的文件，在实际的开发中不需要自己创建，类似于gulp打包工具可以帮助咱们自动创建和修改代码 五、网站状态栏图标 rel=\"shortcut icon\" 网站快捷图标 属性和属性值必须写 六、网站头部信息优化 欢迎来到吴签签的网站 七、网站代码复用和重置样式 1、网站代码复用 2、重置样式 将其放在一个css文件中引入，可以直接使用其中定义好的类名从而避免重复写相同的代码 /*重置样式*/ html, body, div, p, ul, ol, li, dl, dt, dd, h1, h2, h3, h4, h5, h6, form{ margin: 0; padding: 0; } img{ vertical-align: top; border: none; } ul, ol{ list-style: none; } b, strong, em, i{ font-weight: normal; font-style: normal; } a{ text-decoration: none; color: #000000; } /*清除浮动*/ .clear-float{ overflow: hidden; } /*元素垂直居中*/ .ele-middle-parent{ position: relative; } .ele-middle-son{ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } /*网站头部样式代码*/ .header{ width: 100%; height: 80px; background-color: #ccc; font-size: 20px; text-align: center; line-height: 80px; } /*按钮样式*/ .btn{ width: 120px; height: 25px; color: green; background-color: #E5E5E5; font-size: 14px; border: none; outline: none; cursor: pointer; } .btn:hover{ background-color: yellow; color: red; } /*网站尾部样式代码*/ .footer{ width: 100%; height: 100px; background-color: black; font-size: 20px; text-align: center; line-height: 80px; color: #fff; } 八、图片优化 1、给图片尽量设置title和alt属性，当图片加载失败或者搜索引擎查找的时候给一个指引 2、针对于小图标使用css精灵，雪碧图 3、使用base64编码方式，编码解析速度肯定图片本身要快 base64使用情况：图片足够小且因为用处的特殊性无法被制作成精灵图，在整个网站的复用性很高且基本不会被更新，体积较大的图片不要使用base64编码，因为编码后字符太多，体积可能更大 data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAOCAMAAAAhfX2ZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTExNTRFMDc2RkQzMTFFOUE3MzM4Mjc5NjY0N0E3QkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTExNTRFMDg2RkQzMTFFOUE3MzM4Mjc5NjY0N0E3QkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5MTE1NEUwNTZGRDMxMUU5QTczMzgyNzk2NjQ3QTdCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5MTE1NEUwNjZGRDMxMUU5QTczMzgyNzk2NjQ3QTdCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgZ4YTQAAAAtUExURf///0FBQXh3dRUUF/Hx8IWFhL29vfr5+lxbW/7+/qGgn5iYmFBNRmZmZY+PjureQysAAABDSURBVHjapI63EcAwEMMYrOiw/7h6vQsPYFY4NARO6TJNEpJ6kB0IjIYGJOaOD3/a8VoVzUk6j1Vr3w1P2f6OniXAAEYdAP+Kw3zbAAAAAElFTkSuQmCC 注意点：base64格式只需要找对应的工具去把图片转换就行 day13笔记 一、H5介绍 html超文本标记语言 超文本，就是网页中除了文字以外其他的东西，例如：图片、超链接、音频、视频、js程序等等 标记最大的意义就是语义化，表示的是某种意义，见名知意，你见到它就知道它是干什么呢 学习编程语言，最终的目的是人机交互，是让计算机能明白你要让它做什么，而不是让你觉得计算机应该直接做什么 html发展历史 html1.0-html4.0 xhtml可扩展超文本标记语言 html5 二、怪异盒模型 + w3c标准盒模型 盒模型宽度 = 左右margin + 左右padding + 左右border + content(width) + IE怪异盒模型 盒模型宽度 = 左右margin + content（width包含了padding和border） 怪异盒模型怎么触发 在IE低版本的浏览器下当咱们不定义doctype的时候会触发怪异盒模型 在css3新的标准中，新增了一个属性可以在高版本的浏览器里面触发怪异盒模型的机制，把标准盒模型转成怪异盒模型 box-sizing:border-box（怪异盒模型）|content-box（标准盒模型，默认值）; 使用怪异盒模型时width不会被padding和边框撑开，从而避免布局变形或者网页出现滚动条 三、H5新增标记 网页头部 导航 主要内容标记，一个页面里面只能有一个 块 网页尾部 表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 标记文档中的图像 定义图像标题 文本高亮标记 内联标记 画布标记 内联块标记，可以使用它画很多东西，必须配合js一起使用 带有下拉菜单提示信息的输入框 使用H5新增的标记实现的效果和之前使用其他标记是一样的，不同的是语义化对于浏览器来说意义非凡。 四、H5多媒体标记 object标记，作用是引入flash使用的 param标记，引入flash的路径 后缀名为.swf的表示的是flash动画 ​ video标记，视频，很多巨头公司放弃flash支持H5，多媒体播放（视频播放）使用的就是video标记 video标记支持的视频格式：mp4、ogg（ogv）、webm video视频标记的html属性 src 路径 controls 视频控件（播放、静音、进度条） loop 循环播放 autoplay 自动播放，谷歌浏览器以影响浏览器的性能为由把autoplay给禁用了 muted 静音 poster 封面 preload 预加载，当视频开始播放的时候进行缓存，当网不好的时候直接可以流畅播放 auto - 当页面加载后载入整个视频 meta - 当页面加载后只载入元数据 none - 当页面加载后不载入视频 source标记，引入视频资源的路径 多个source标记的原因是视频支持的格式有多个 音频标记 embed标记 embed可以用来插入各种媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等 五、H5新增表单 电子邮箱 电话号码 网址 搜索 进度条 取色器 数字 日历 月份 周 上传文件 图像按钮 placeholder 当用户输入内容时提示信息消失 autofocus 让表单的第一个自动获取焦点，设置多个只能第一个起作用 autocomplete 关闭表单自动提示功能，自动提示功能是表单设置了name属性后才会有 off 关闭 on 打开 required 表单为空不能提交 pattern 属性值里面可以写正则表达式 novalidate 表单不验证自动提交 六、:focus焦点选择器 input:focus：可以设置input获取焦点时的样式 七、交集选择器 语法：选择器1选择器2{} 作用：限定样式的范围 div.p1{ background-color: red; } 这是小pp同学1 这是小pp同学2 这是小pp同学3 这是小pp同学4 这是小pp同学5 这是小pp同学6 这是网页布局使用的1 这是网页布局使用的2 这是网页布局使用的3 day14笔记 一、序列选择器 同级别，不能被其他类型的标记给隔开，只能选择同一类型的标记 同类型，选择的时候只找同一类型的，不同类型的可以绕过，说明可以被其他的类型给隔开 注意点：无论是同级别的还是同类型的序列选择器都建议使用的时候不要在最外层使用 不区分类型： :first-child; 选中同级别中的第一个标签 :last-child; 选中同级别中的最后一个标签 :nth-last-child(n); 选中同级别中倒数第n个标签 :nth-child(n); 选中同级别中的第n个标签 :only-child; 选中同级别中唯一子元素标签 区分类型： :first-of-type; 选中同级别中同类型的第一个标签 :last-of-type; 选中同级别中同类型的最后一个标签 :nth-of-type(n); 选中同级别中同类型的第n个标签 :nth-last-of-type(n); 选中同级别中同类型的倒数第n个标签 :only-of-type; 选中同级别中同类型的唯一标签 奇偶选择： :nth-child(odd); 选中同级别中同类型的奇数标签 :nth-child(even); 选中同级别中同类型的偶数标签 :nth-child(nx+y); 选中同级别中同类型的第（nx+y）个标签（n从第0开始递增计数，到元素的总个数上限停止 二、属性选择器 通过标记自身上面的html属性选取标记 减少了对于类名或者id名称的依赖 ```css /通过标记的属性获取元素/ input[id]{ border: 1px solid red; } /通过标记的属性的属性值获取元素/ input[type=\"text\"]{ width: 200px; height: 30px; border: 1px solid red; } /通过标记的属性的属性值的开头内容选取元素/ a[href^=\"#\"]{ background-color: red; } /通过标记的属性的属性值的结尾内容选取元素/ a[href$=\"l\"]{ background-color: orange; } /通过标记的属性的属性值的任意内容选取元素/ a[href*=\".\"]{ background-color: yellow; } #### 三、UI元素状态伪类 ```html /*给没有禁用的表单标记设置样式*/ /* input:enabled{ border: 1px solid red; } */ /*给禁用的表单标记设置样式*/ /* input:disabled{ width: 200px; height: 30px; } */ /*给默认选中的表单标记设置样式*/ input:checked{ width: 50px; height: 50px; } /*文字选中效果 注意点：必须两个冒号才起作用*/ p::selection{ background-color: red; color: #fff; /* font-size: 20px; */ } 哈哈嘻嘻哈哈呵呵 四、否定和根选择器 否定选择器 给一个标记设置样式，除了它自己没有样式以外，其他的标记都会有 ```css input:not([type=\"text\"]){ width: 200px; height: 30px; border: 1px solid red; } ``` 根选择器（用处不大） 根标记html root表示的就是html :root{ background-color: yellow; } 五、层次（层级）选择器、子选择器、兄弟选择器 层次选择器 后代（包含）选择器，只要是它的后代样式都会继承 子选择器，只针对子元素起作用 .nav{ width: 800px; height: 40px; background-color: #E5E5E5; margin: 50px auto; } /*只对子元素起作用*/ .nav>li{ float: left; line-height: 40px; padding: 0 20px; } .nav>li:nth-child(3){ position: relative; } 无痛针灸 无痛火罐 无痛火罐 2.子选择器，只针对子元素起作用 语法：选择器1>选择器{} .nav>li:nth-child(3){ position: relative; } 无痛针灸 无痛火罐 无痛火罐 3.相邻兄弟选择器:只对紧跟在它后面的第一个元素起作用，不能被其他类型标记给隔开 语法：选择器1+选择器{} div+p{ background-color: yellow; } 4.通用兄弟选择器，只要是它后面的标记都会起作用 语法：选择器1~选择器{} div~p{ background-color: orange; } 六、浏览器私有前缀 介绍：一个新的属性刚出来的时候，还没有成为标准的一部分，大部分的浏览器是不支持的 想要使用这个新的属性，所以浏览器给出了一个方法，为了作为区分，第二个方便你自己去用 浏览器私有前缀，其实是一种身份的验证，主要是过渡使用的 浏览器私有前缀有哪些 -webkit- 谷歌浏览器 -moz- 火狐浏览器 -ms- 亲爱的的IE -o- 欧朋 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; -ms-border-radius: 50%; -o-border-radius: 50%; border-radius: 34px 55px 153px 57px; 七、阴影效果 1.文字阴影 /*值1表示水平位置 值2表示垂直位置 值3表示模糊程度 值4表示阴影颜色，可以设置多个*/ text-shadow: 5px 5px 5px green, 10px 10px 5px yellow, 15px 15px 5px red; 2.盒子阴影 /*值1表示水平位置 值2表示垂直位置 值3表示模糊程度 值4表示阴影颜色 inset表示内阴影*/ box-shadow: 0px 1px 10px black, 2px 2px 10px blue; transition动画过度属性（只对变化的属性有效果） /*需要参与过渡的属性*/ /* transition-property: box-shadow, margin-top, background-color; */ /*all表示所有要参与过渡的属性*/ transition-property: all; /*过渡时间*/ transition-duration: 1s; 八、英文换行属性 word-break:break-all; 英文句子会自动换行，英文字母不会换行，所以可以使用该属性让英文字符串强制换行，但不能控制换行位置，还不如使用换行 九、大小写转换属性 p:nth-child(1){ /*把单词首字母大写*/ text-transform: capitalize; } p:nth-child(2){ /*把单词大写转成小写*/ text-transform:lowercase; } p:nth-child(3){ /*把单词首字母小写转成大写*/ text-transform:uppercase; } p:nth-child(4){ /*小型大写单词*/ font-variant: small-caps; } hello world HELLO WORLD hello world hello 十、粘性定位 粘性定位：介于相对定位和固定定位之间的一个定位，可相对可固定，要达到一定的条件 指定坐标 position: sticky; /*距离浏览器顶部有50px的时候变成固定定位，开始是相对定位*/ top: 50px; 使用粘性定位可以实现吸顶效果，即当元素位置满足设置的position坐标时，该元素变成固定定位 十一、背景属性 background-origin:content-box;|padding-box;(默认值)|border-box; padding-box:从padding区域开始进行渲染，背景图包含padding区域和content区域 content-box:从content区域开始进行渲染，背景图只包含content区域 border-box:从border区域开始进行渲染，背景图包含border区域，padding区域和content区域 background-clip:content-box;|padding-box;|border-box; 使用此属性则背景图片只包含指定的区域，超出的区域会被裁剪 例如：background-clip:content-box;表示padding和border区域的背景会被裁剪 background-size:数值|百分比|cover|contain;(推荐大家使用数值或者百分比) 表示背景图的尺寸 cover:把背景拉伸到整个容器大小，完全覆盖容器区域，如果图片不规则的情况下图片会变形 contain:把图片进行拉伸，拉伸的时候会根据容器的大小把图片按着比例进行拉伸 多重背景：background:url(img/niu.png) no-repeat right bottom, url(img/c.webp.jpg) no-repeat; 注意点：前面的背景会覆盖在后面的背景上 推荐分开去写 day15笔记 一、弹性盒布局介绍 1)弹性盒也叫伸缩布局盒模型 它是css3引入的一种新的布局模式——flexbox布局，即伸缩布局盒模型，用来提供一个更有效的方式制定、调整和分布一个容器里的项目布局。相比之前的布局方式，更便利于开发。 2)主要思想是让容器有能力让其子项目能够改变其宽度、高度（甚至顺序），以最佳的方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）。flex容器会使子项目扩展来填充可用空间，或缩小他们以防止溢出容器。 3)专业术语解释 a、主轴-水平方向或者X轴 b、侧轴-垂直方向或者Y轴 c、伸缩容器（父元素）和伸缩项目（子元素） 二、弹性盒属性 direction：flex; 1)伸缩流方向 flex-direction 给容器伸缩设置，主要用来创建主轴，定义伸缩项目在伸缩容器中的方向，给伸缩容器设置 row：从左向右 row-reverse：与row相反，从右向左 column：从上到下 column-reverse：与column相反 2)主轴对齐 justify-content 给容器伸缩设置，主要用来定义伸缩项目沿主轴线的对齐方式 flex-start：伸缩项目向一行的起始位置靠齐（默认） flex-end：伸缩项目向一行的结束位置靠齐 center：伸缩项目向一行的中间位置靠齐 space-between：伸缩项目会平均的分布在行里 space-around：伸缩项目会平均的分布在行里，两端保留一半的空间 space-evenly：项目均匀分布，所有项目之间及项目与边框之间距离相等（新增的属性值，会存在兼容问题，低版本的浏览器不支持） 3)侧轴对齐 align-items 给容器伸缩设置，定义伸缩项目行在侧轴上的对齐方式 flex-start：伸缩项目在侧轴起点边的外边距 紧靠住 该行在侧轴起始边 flex-end：伸缩项目在侧轴终点边的外边距 紧靠住 该行在侧轴终点边 center：伸缩项目的外边距盒 在该行的侧轴上居中放置 baseline：伸缩项目根据伸缩项目的基线对齐（基线对齐不能给元素设置高度，可以用行高调整高度） stretch：伸缩项目拉伸填充整个伸缩容器(默认值) 当容器里面的子元素没有设置高度的时候，子项目它的高度会默认进行拉伸，宽度同理 （如果没有设置高度，项目会默认拉伸，如果设置了高度，设置了stretch也不起作用） （当项目没有设置高度而align-items设置了其他值时，项目不会被拉伸，而不设置align-items时，会默认拉伸） 4)换行 flex-wrap 给容器伸缩设置 nowrap 不换行 默认值，不管超出还是不超出都不会换行 当容器设置了弹性盒且不换行，当容器的宽度或者高度不够的情况下，子项目会默认自带压缩 wrap 换行 一旦伸缩项目超出伸缩容器，那么就会换行 如果容器设置了高度，给弹性盒设置了换行属性后，子项目行与行之间会有默认的行距 wrap-reverse 换行反向 主轴水平时，上下反向，主轴垂直时，左右反向 5)伸缩流方向属性与换行属性缩写形式 flex-flow flex-flow：换行 伸缩方向; 两个值同时定义或者单独定义都生效，不分先后顺序 6)align-self（加在子元素上） 主要用来设置单独伸缩项目在侧轴的对齐方式。注意点：align-self可以覆盖align-items，两者特性是一样的 flex-start：伸缩项目在侧轴起点边的外边距 紧靠住 该行在侧轴起始边；（元素位于容器的开头） flex-end：伸缩项目在侧轴终点边的外边距 紧靠住 该行在侧轴终点边；（元素位于容器的结尾） center：伸缩项目的外边距盒 在该行的侧轴上居中放置；（元素位于容器的中间） stretch：伸缩项目拉伸填充整个伸缩容器。（元素被拉伸以适应容器）（同样不能设置高度） 7)堆栈伸缩行 align-content(行与行之间的对齐方式) 定义多个伸缩行的对齐方式； 往往要与换行同时应用，没有换行就不存在多行的情况 与align-items的区别是align-content可以消除行距，只针对伸缩行，而align-items可以对项目起作用 flex-start：各行向伸缩容器的起点位置堆叠；（没有行距） flex-end：各行向伸缩容器的结束位置堆叠；（底部对其没有行距） center：各行向伸缩容器的中间位置堆叠；（居中没有行距） space-between：各行在伸缩容器中平均分布；（两端对齐，中间自动分配） space-around：各行在伸缩容器中平均分布，两端保留一半的空间；（自动分配距离） 8)显示顺序 order （加在子元素上） 默认状态是按照标准流的顺序排列，在flexbox模型里，可以通过order改变伸缩项目的顺序 a、不定义order的伸缩项目会排到前面 b、order：1； 排第一 order：2； 排第二 9)flex（设置在子元素上） 作用：可以让元素自动占用容器的可用空间，所有项目等比划分 flex:1; flex:2; ... 10)flex-grow属性 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大，会在原有大小的基础上分配剩余空间， 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍，即将剩余空间分成flex-grow的数值之和的份数，然后flow-grow为1的分1份，为2的分两份 11)flex-shrink属性 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 12)flex-basis属性 定义了在分配多余空间之前，项目占据的主轴空间（main size） 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。不常用，还在不断变化中。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto 三列布局 需求：一个容器里面有三个元素，两边的元素宽度是固定的，中间元素要求宽度自适应 在三列布局的基础衍生出了其他的布局方式，双飞翼和圣杯布局 双飞翼和圣杯布局 + 需求1：一个容器里面有三个元素，两边的元素宽度是固定的，中间元素要求宽度自适应 + 需求2：希望浏览器优先渲染中间内容区域，在网页效果呈现的时候中间的内容区域依旧在中间 圣杯布局：页眉、页脚、中间分为左中右三栏 三、iconfont字体图标 字体图标把图标当成字体去使用，在开发中用起来非常便利 把图进行编码化，直接把图变成代码形式使用，效率比直接使用图片会高 做图片优化 字体图标在移动端有大量的使用 使用方法： 从iconfont网站选择需要的图标，将包下载到本地并解压放在项目中 在HTML中引入字体图标的样式文件iconfont.css 打开字体图标包中的demo_index.html，查看图标的font class 给需要添加字体图标的标签设置类名class=\"iconfont 图标对应的fontclass\" svg图标 矢量图，放大或缩小不会失真 svg是H5新增的，语法使用的是xml（标记语言、它的标记是自定义、数据格式） font-face服务器字体 浏览器有些字体是支持的有些不支持，css3新增了服务器字体语 服务器字体语法可以帮助咱们实现支持其他字体 字体可以自定义名称 @font-face { font-family:\"肖宇\"; src: url(\"img/灵动指书手机字体.ttf\"); } h1{ font-family: \"肖宇\"; } week4 day16笔记 一、rem单位 1、rem介绍： (font size of the root element) 是指相对于根元素的字体大小的单位。 2、为什么web app要使用rem？ 实现强大的屏幕适配布局(淘宝,腾讯,网易等网站都是rem布局适配)rem能等比例适配所有屏幕,根据变化html的字体大小来控制rem的大小, 3、适配方案 使用rem.js 已经准备好一个rem的js相关文件，咱们只要把对应的js文件引入的到页面中直接可以使用 srcipt标记，这个标记的作用就是在内部编写js代码或者可以通过它的src属性引入一个外部的js文件 srcipt标记可以理解为它是js代码执行的一个环境 js里面为了方便计算，rem的值使用的是 100px=1rem 使用vw 二、em单位 1、em介绍：是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 2、em特点： em的值并不是固定的 em会继承父级元素的字体大小 三、vw、vh单位 1、单位介绍： css新增的一个单位 vw表示的是视窗，指的是浏览器宽度和高度 vw把视窗默认进行了份数的一个划分 默认情况下把视窗划分成了100vw，1vw占了1% 为了做屏幕适配，可以实现自适应 比百分比方便，因为它不需要参照物（只需要参照视窗） vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。 vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vmin：vw和vh中较小的那个。 vmax：vw和vh中较大的那个。 vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Android browser4.4+支持，chrome for android39支持 2、px转vw公式: Vw = 元素所展示的大小（设计图固定大小）*100/设计稿宽度 vw默认把屏幕划分成了100vw，100vw = 750px，求出1px等于多少vw呢？ 1px = 0.1333333vw 3、vw适配rem单位 设计稿的宽度是750px，100vw = 750px 1px = 0.133333vw，使用js适配rem的时候比例1rem = 100px 已经知道1px等于0.133333vw，求出100px等于0.133333*100 = 13.3333vw 四、移动端布局 移动端布局区域 可视区域（就是你看见的区域，也可以理解为屏幕区域） 布局区域（指的是整个网页） 理想区域：可视区域 = 布局区域 时就是理想区域 五、媒体查询 css3新增的一个语法 可以让css具有判断的功能，在大于1024px的宽度执行或者小于1024px的宽度执行代码 根据条件可以设置不同的样式 媒体查询判断使用的两个条件 max-width min-width 当媒体为真就执行，为假就不执行 /*all表示所有媒体类型：笔记本、移动端设备、投影设备、打印机等等*/ /*and 和 表示连接 ()括号里面放的是条件*/ /*注意点：最后数值+px里面不能有分号*/ /*当宽度大于900px的时候条件成立，触发代码执行*/ /* @media all and (min-width:900px){ div{ height: 200px; background-color: red; } } */ /*在500px --- 1000px之间执行代码*/ /* @media all and (min-width:500px) and (max-width:1000px) { div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } } */ /*not表示排除某种设备*/ /* @media not all and (min-width:900px) { div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } } */ /*only表示限定为某种设备 screen屏幕（笔记本设备）*/ @media only screen and (min-width:900px){ div{ height: 80px; background-color: red; font-size: 20px; text-align: center; } 一、媒体查询 1、媒体查询介绍: 媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 2、媒体查询操作方式： 实际操作为：对设备提出询问（称作表达式）开始，如果表达式结果为真(符合当前条件)，媒体查询中的CSS被应用，如果表达式结果为假(不符合)，媒体查询内的CSS将被忽略。 二、媒体查询示例 1、语法： /*表示设备宽度小于320px时就不执行蓝色背景了。*/ @media all and (min-width:320px) { div{ background-color:blue;} } /*表示设宽度到640px------300px之间显示桔色背景。*/ @media only screen and (min-width: 300px) and (max-width: 640px) { div{ background-color: orange; } } /* 竖屏 */ @media screen and (orientation:portrait) {对应样式} /* 横屏 */ @media screen and (orientation:landscape){对应样式} 2、媒体类型: 3、名词解释： screen 是媒体类型里的一种，CSS2.1定义了10种媒体类型 and 被称为关键字，其他关键字还包括 not(排除某种设备)，only(限定某种设备) (min-width: 400px) 就是媒体特性，其被放置在一对圆括号中 4、断点介绍： 无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点） 5、css2媒体查询语法: 其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码 ; 想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 第一段的代码也用CSS2来实现，让它一样可以在页面宽度小于960的执行指定的样式文件： 三、常见的布局方案 固定布局：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸； 可切换的固定布局：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局； 弹性布局（流式布局）：以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果； 混合布局：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。 布局响应：对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：pc优先（从pc端开始向下设计）；移动优先（从移动端向上设计）； 四、响应式布局方案 1、基于媒体查询实现 2、响应式布局特点 ​ 设计特点： ​ a、面对不同分辨率设备灵活性强 ​ b、能够快捷解决多设备显示适应问题 ​ 缺点： ​ a、兼容各种设备工作量大，效率低下 ​ b、代码累赘，会出现隐藏无用的元素，加载时间加长 ​ c、其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 五、Meta标签的设置 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale： 初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） day17笔记 一、多列布局 css3新增的布局，类似于生活中的报纸的版面布局 /*列宽*/ /* column-width: ; */ /*列数*/ /* column-count: ; */ columns:200px 5; /*列间隙*/ column-gap: 20px; /*列边框*/ column-rule:1px dashed orange; /*表示标题要不要跨列显示*/ column-span: all; 二、logo优化 logo优化 logo是一个网站比较重要的东西，代表的是这个品牌 logo也是在网站最显眼的地方 所以需要浏览器在查找一个网站的时候，把搜索权重提供 h1一个网站里面只能有一个，因为它的搜索权重比较高的 使用h1做logo的优化 由于搜索引擎无法识别图片上面的文字，所以一般需要浏览器解析到网站的文字所以选择手动设置 图片优化 由于搜索引擎无法识别图片上面的文字，所以一般需要浏览器解析到网站的文字所以选择手动设置 图片标记上面的title属性和alt属性必须设置，及时为空也建议设置 三、CSS3 渐变 1、简单介绍：CSS3 渐变（gradient）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果，现在通过使用 CSS3 的渐变（gradients）即可实现。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 2、线性渐变： 概念：线性渐变是从“一个方向”向“另一个方向”的颜色渐变 语法： background: linear-gradient(direction, color-stop1, color-stop2, ...); 说明： direction：默认为to bottom，即从上向下的渐变； stop：颜色的分布位置，默认均匀分布，例如有3个颜色，各个颜色的stop均为33.33%。 线性渐变方向示例代码： /*以下代码分别产生“从右到左”、“从左到右”、“从上到下”、“从下到上”的“红色–绿色”渐变*/ div { background:linear-gradient(to left, red , blue) } div { background:linear-gradient(to right, red , blue) } /* 浏览器默认值 */ div { background:linear-gradient(to bottom, red , blue) } div { background:linear-gradient(to top, red , blue) } 效果示例： 线性渐变角方向示例代码: /*分别产生到“右下角”、“右上角”、“左下角”、“左上角”的渐变*/ div { background: linear-gradient(to right bottom, red , blue); } div { background: linear-gradient(to right top, red , blue); } div { background: linear-gradient(to left bottom, red , blue); } div { background: linear-gradient(to left top, red , blue); } 效果示例: 线性渐变角度示例代码: /*0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。*/ div { background: linear-gradient(10deg, red, blue) } 3、径向渐变： 概念：径向渐变是从“一个点”向四周的颜色渐变 语法： div { background: radial-gradient(red, yellow, green); } 多颜色节点不均匀分布示例代码: div { background: radial-gradient(red 5%, green 15%, blue 60%); } 效果示例： 设置渐变形状示例代码: div { background: radial-gradient(circle, red, yellow, green); } div { background: radial-gradient(ellipse, red, yellow, green); } 效果示例: circle：渐变为最大的圆形； ellipse：根据元素形状渐变，元素为正方形是显示效果与circle无异。 4、重复性线性渐变 语法： /*10%的位置为yellow，20%的位置为green，然后按照这20%向下重复*/ div { background: repeating-linear-gradient(red, yellow 10%, green 20%); } 5、重复性径向渐变 语法： div { background: repeating-radial-gradient(red, yellow 10%, green 20%); } 四、过渡属性 过渡属性介绍： css3的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值 语法： 过渡属性分写形式： transition-property：检索或设置对象中的参与过渡的属性 transition-duration：检索或设置对象过渡的持续时间 transition-delay：检索或设置对象延迟过渡的时间 transition-timing-function：linear|ease|ease-in|ease-out|ease-in-out检索或设置对象中过渡的动画类型 简写： transition:all(全部或所有)/具体属性值 运动时间s/ms 延迟时间s/ms 动画类型; 动画类型示例图: 五、2D属性 transform 该属性允许我们对元素进行旋转、缩放、移动。 注意点：位移、旋转、缩放必须配合transform使用 位移语法: 1、translate() 将元素向指定的方向移动，类似于position中的relative。 transform:translateX(); 水平位移 transform:translateY(); 垂直位移 transform:translate(值1, 值2); 值1表示水平位移 值2表示垂直 注意点：如果使用的是分写形式，有两个transform的情况后面的属性会把前面的给覆盖掉 如：transform: translate(100px, 0px); 第一个参数:水平方向 第二个参数:垂直方向 元素垂直居中 position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 缩放属性语法: 2、scale() 让元素根据中心原点对对象进行缩放。默认的值1。因此0.01到0.99之间的任何值，使一个元素缩小；而任何大于或等于1.01的值，让元素显得更大。 transform:scaleX(); 水平缩放 transform:scaleY(); 垂直缩放 transform:scale(值1, 值2); 值1表示水平缩放 值2表示垂直缩放 如：transform: scale(0.5, 0.5); 第一个参数:水平方向 第二个参数:垂直方向 注意点: 如果取值是1, 代表不变 如果取值大于1, 代表需要放大 如果取值小于1, 代表需要缩小 如果水平和垂直缩放都一样, 那么可以简写为一个参数 transform: scale(1.5); 旋转语法： 3、rotate() 旋转rotate()通过指定的角度参数对元素根据对象原点指定一个2D旋转。它主要在二维空间内进行操作，接受一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。 注意点: 1.如果需要进行多个转换, 那么用空格隔开 2.2D的转换模块会修改元素的坐标系, 所以旋转之后再平移就不是水平平移的 如：transform: rotate(45deg); translate(100px, 0px) scale(1.5, 1.5); rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转 rotateZ() 方法，元素围绕其 Z轴以给定的度数进行旋转，默认就是Z轴旋转。 斜切、倾斜属性 transform: skewX(-26deg); transform: skewY(30deg); 变形原点属性，可以改变变形的轴线位置 transform-origin:50px top; 元素的变形原点默认在元素自己的中线位置，如rotateX则变形原点为水平中线,，50px表示Y轴变形原点为50px处，top表示x轴变形原点为top 景深属性语法: perspective: 数值；透视属性：近大远小 注意点：一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面 day18笔记 一、3D属性 1)什么是3d的场景呢？ 2d场景，在屏幕上水平和垂直的交叉线x轴和y轴 3d场景，在垂直于屏幕的方法，相对于2d多出个z轴 Z轴：靠近屏幕的方向是正向，远离屏幕的方向是反向 下图为3d场景坐标图 2)transform-style属性 ransform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。把2D转成3D 他主要有两个属性值：flat和preserve-3d 3) translate3d位移属性 3D位移 CSS3中的3D位移主要包括: translateZ() translate3d(值1，值2，值3)两个功能函数； 值1：代表横向坐标位移向量的长度； 值2：代表纵向坐标位移向量的长度； 值3：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 4)rotate3d旋转属性 旋转后坐标轴会发生相应的变化 3D旋转 CSS3中的3D旋转主要包括: rotateX() rotateY() rotateZ() rotate3d(1,1,0,4deg)四个功能函数； 4个参数，前三个，对应x,y,z 轴，是标示你是否希望沿着该轴旋转，是为1，不是为0，最后一个标示旋转的角度。 5)scaleZ缩放属性: CSS3中的3D缩放主要包括: scaleZ()； 6)景深属性： 生活中的3d 区别于2d的地方 近大远小 景深 程序中实现的方法 perspective 元素距离 视线的距离（物体和眼睛的距离越小，近大远小的效果越明显） perspective: 1200px;(加在父元素上) transform:perspective(1200px) （在子元素中使用） 注意点： a、两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间 2、如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉 二、动画属性 动画执行三要素： 1.告诉系统需要执行那个动画 animation-name:动画名 2.告诉系统我们需要创建一个名称叫什么的动画 @keyframes mymove{ from{初始状态属性} to{结束状态属性} } @keyframes mymove{ 0%{初始状态属性} 100%{结束状态属性} }（中间再可以添加关键帧） 3.告诉系统动画持续的时长 animation-duration:3s; animation属性和语法： 1.animation-name 检索或设置对象所应用的动画名称 说明：必须与规则@keyframes配合使用， @keyframes mymove{} animation-name:mymove; 2.animation-duration 检索或设置对象动画的持续时间 说明：animation-duration:3s; 动画完成使用的时间为3s 3.animation-timing-function 检索或设置对象动画的过渡类型 说明： linear：线性过渡 ease：平滑过渡 ease-in：由慢到快 ease-out：由快到慢 ease-in-out：由慢到快再到慢 step-start:马上跳到动画每一结束桢的状态 4.animation-delay 检索或设置对象动画延迟的时间 说明：animation-delay:0.5s; 动画开始前延迟的时间为0.5s 5.animation-iteration-count 检索或设置对象动画的循环次数 说明： animation-iteration-count: infinite | number; infinite：无限循环 number: 循环的次数 6.animation-direction 检索或设置对象动画在循环中是否反向运动 说明： normal：正常方向 reverse：反方向运行 alternate：动画先正常运行再反方向运行，并持续交替运行 alternate-reverse：动画先反运行再正方向运行，并持续交替运行 7.animation-play-state 检索或设置对象动画的状态 说明： animation-play-state:running | paused; running:运动 paused: 暂停 animation和transition的区别： 相同点：都是随着时间改变元素的属性值。 不同点： transition需要触发一个事件(hover事件或click事件等)才会随时间改变其css属性； 而animation在不需要触发任何事件的情况下也可以显式的随着时间变化来改变元素css的属性值，从而达到一种动画的效果，css3的animation就需要明确的动画属性值。 animation缩写形式： 三、屏幕名称 1、什么是像素： 像素，又称画素，是图像显示的基本单位。 像素是网页布局的基础。一个像素就是计算机能够显示一种特定颜色的最小区域。当设备尺寸相同但像素变得更密集时，屏幕能显示的画面的过渡更细致，网站看起来更明快。 2、ppi是指屏幕上每英寸可以显示的像素点的数量，即屏幕像素密度 3、像素分类： a、设备像素(device independent pixels): 设备屏幕的物理像素，任何设备的物理像素的数量都是固定的 分辨率：是指宽度上和高度上最多能显示的物理像素点个数 点距：像素与像素之间的距离，点距和屏幕尺寸决定了分辨率大小 b、CSS像素(CSS pixels): 又称为逻辑像素，是为web开发者创造的，比如我们css中使用的像素 在桌面端，css的1个像素往往都是对应着电脑屏幕的1个物理像素。而在手机端，由于屏幕尺寸的限制，缩放是经常性的操作。因而当用户进行缩小操作时，一个设备像素覆盖了多个CSS像素。当用户进行放大操作时，一个CSS像素覆盖了多个设备像素。不论我们进行缩小或放大操作，元素设置的CSS像素(如width:300px)是始终不变的，而一个CSS像素对应多少个设备像素是根据当前的缩放比例来决定的 1px边框问题 4、其他概念: 屏幕尺寸：指的是屏幕对角线的长度 PPI:屏幕像素密度，即每英寸(1英寸=2.54厘米)聚集的像素点个数，这里的一英寸还是对角线长度 DPI:每英寸像素点，印刷行业术语。对于电脑屏幕而言和PPI是一个意思 设备像素(又称为物理像素): 指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。 设备独立像素(也叫密度无关像素或逻辑像素)：可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，这个点是没有固定下小的，越小越清晰，然后由相关系统转换为物理像素。 DPR(设备像素比)：设备像素比 = 设备像素 / 设备独立像素。(在Retina屏的iphone上，DPR为2，1个css像素相当于2个物理像素) --- 1px边框问题 5、dpr： 在早先的移动设备中，并没有DPR的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。从iphone4开始，苹果公司推出了所谓的retina视网膜屏幕，才有了这个概念。 四、BFC 1、概念：BFC 是 Block formatting context 的缩写，直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部的元素如何布局，并且与这个区域外部毫不相干。 在具体解释 BFC 前，我们了解一下常见的定位方案，通常有三种：普通流、浮动流、定位流。 普通流（文档流、标准流）：元素按照其在 HTML 中的先后位置至上而下布局，行内元素水平排列，当行被占满然后换行，块级元素则会被渲染为完整的一行。 浮动流：元素首先按照普通流的位置出现，然后根据浮动的方向向左边或右边偏移，其效果与印刷排版中的文本环绕类似 定位流：元素会整体脱离普通流，定位元素不会对其兄弟元素造成影响，而元素具体的位置由定位的坐标决定 FC，Formatting context 首字母的缩写，表示格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用，普通流其实就是指 FC。 注意点：BFC 是 FC 中的一种，具有 BFC 特性的元素可以看作是隔离了的独立容器（相当于就是一个大箱子），容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 BFC布局规则（特性） 1.内部的 box 会在垂直方向一个接一个的排列 2.box 垂直方向的距离由 margin 决定，同一个 BFC 中相邻的两个 box 的 margin 会发生重叠 3.每个元素的 margin-left 与包含块的 border-left 相接触 4.BFC 区域不会与 float box 重叠 5.计算 BFC 高度时，浮动元素会参与计算 6.容器内元素布局不影响外部元素，反之亦然 如何触发 BFC 1.根元素，即 html 元素 2.float 的值不为 none 3.overflow 的值不为 visible 4.display 的值为 flex、inline-block、table-cell、table-caption 5.position 的值为 absolute 或 fixed BFC的应用 1.解决浮动塌陷问题 2.自适应两栏布局（我们还可以运用BFC可以阻止元素被浮动元素覆盖的特性来实现自适应两栏布局。方法：给没有浮动的元素加overflow：hidden。） 3.解决设置margin值重叠问题。 总结：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。它规定了元素与其他元素的关系和相互作用。 五、万能清除浮动 .clear::after{ content: \"\"; display: block; clear: both; height: 0; visibility: hidden; } /*因为IE低版本的浏览器是不支持clear:both;属性，需要使用zoom属性触发它的机制让其支持*/ .clear{ zoom: 1; } 给需要清除浮动的元素添加类名clear即可 六、计算属性 width: calc(200px * 5 + 100px); css3新增计算属性，内部可以实现+、—、*、/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-02-11 11:31:12 "},"笔记/Vue/VUE基础.html":{"url":"笔记/Vue/VUE基础.html","title":"VUE基础","keywords":"","body":"MVVM M - Model，模型，数据 V - View，视图 VM - ViewModel 采用数据双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 Vue 官网 v2.x v3.x Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 （Object.defineProperty()）特性 安装两种版本： 开发版本：包含了警告与调试信息 生产版本：删除了与调试相关的信息，作了压缩混淆 声明式渲染 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统 { { message }} const vm = new Vue({ el: '#app', // element，代表了 view data: { // 代表了 Model message: 'Hello' } }) el 表示关联的视图 data 表示要渲染的数据 创建的 Vue() 实例相当于是 MVVM 架构中的 VM （ViewModel） 所有东西都是响应式的（数据被修改后，视图会自动重新渲染） Vue 实例 数据与方法 数据： 当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中，即会将 data 中定义的各属性直接挂载到 Vue 实例下，可以使用 Vue 实例直接调用到 data 中定义的各属性（如果 data 对象中有以 $ 或 _ 开头的属性，不会直接挂载到 Vue 实例下），当data中数据被更新时，会自动更新页面渲染。 只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。 在 vue 实例下有 $data 属性，代表的就是 data 对象。 在 vue 实例下有 $options 属性，代表的是创建 Vue 实例时的选项对象。 方法： 创建 Vue 实例时，在 methods 选项中定义的方法也会被直接挂载到 Vue 实例下。 模板语法 插值 文本 { { expression }} 双花括号之间书写的是 JS 表达式，主要用于绑定渲染文本数据。 双大括号会将数据解释为普通文本，而非 HTML 代码。（对于 HTML 文本，{ { }} 语法会进行转义处理，目的是为了避免出现 XSS 攻击） html v-html 指令 attrubutes v-bind 指令 指令 就是在 HTML 标签中新添加的一些（以 v-* 开头的）有特殊意义的属性，利用这些属性，在 Vue 中可以实现相应的功能处理。 v-html: 渲染 HTML 文本 v-text: 渲染纯文本 v-bind: 动态绑定属性值，在标签中绑定属性值是不能使用 { {}} 语法，而是需要使用 v-bind 指令。可简写为 : v-on: 注册事件监听，可简写为 @，可以使用修饰符,v-on可以接受JavaScript代码，也可以接收一个方法名，还可以再内联JavaScript语句中调用方法,有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： Add 1 Greet Say hi 事件修饰符：使用事件修饰符可以实现事件方法，避免了在方法中处理Dom事件细节，从而只需要考虑纯粹的数据逻辑。 .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 事件修饰符可以串联，有先后顺序，前面的先执行，后面的后执行 如：用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 按键修饰符：Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 常用按键码别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta Do something 与条件渲染相关： v-if: 操作的是 DOM 树中节点的销毁、重建 v-else-if: v-else: v-show: 操作的是 CSS 样式中的 display A B Not A/B 要在多个元素上使用v-if，可以使用元素包裹，并在上面使用v-if，最终渲染将不包含元素 Paragraph 1 Paragraph 2 v-if vs v-show（面试）：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 与列表渲染相关： v-for: v-for 与 v-if 一起使用（面试）：不推荐同时使用 v-if 和 v-for。2.x 中当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；而 3.x 的版本中则反过来。 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。使用了key属性后，Vue会检测key来复用元素，而不是每次都重复渲染。 在自定义组件中使用v-for必须使用ke v-once: 只渲染元素和组件一次 v-pre: 原样显示 v-cloak: 这个指令保持在元素上直到关联实例结束编译。通常结合 css 规则：[v-cloak] { display: none } 一起使用，避免看到未经编译的视图模板内容。 v-model: v-model 指令在表单 、 及 元素上替代value、option等创建双向数据绑定。 v-solt: 具名插槽使用，可简写为# 计算属性与侦听器 计算属性 特点： 对复杂的逻辑表达式进行简化运算，方便阅读 计算属性值能够被缓存，只要依赖项不发生变化，就会一直使用缓存的值。只在相关响应式依赖发生改变时它们才会重新求值。 computed: { attrbute: { // 计算属性的 getter get: function () { return this.activeClass === 'active' }, //设置setter属性后计算属性就可以使用 = 赋值 set: function (val) { return val } } } vs method（面试） 计算属性可被缓存，方法不能被缓存 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要依赖项还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数，而方法每调用一次都会执行一次函数。 为什么需要缓存？ 假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 侦听器（侦听属性） 当需要在数据变化时执行异步或开销较大的操作时，使用侦听器这个方式是最有用的。 watch: { message: function (val) { this.msg = 'change' + val } } vs 计算属性（面试） 计算属性可被缓存，侦听属性不能被缓存 侦听属性中可包含异步操作等动作，而计算属性中不能包含 计算属性通常是由一个或多个响应式数据计算出一个值返回；而侦听属性通常是监听一个数据的变化，由这一个数据的变化可能影响到另外的一个或多个数据的变化 class 与 style 绑定 vue 对节点绑定 class 与 style 进行了功能增加，除了可以绑定字符串外，也可以绑定对象或数组。 class绑定 其中active这个class存在与否将取决于isActive的布尔值，v-bind:class也可以与普通的class attribute共存，也可以绑定计算属性来定义class对象，计算属性最后返回一个class对象值即可； 也可以把一个数组传给v-bind:class，数组中可以使用对象语法和三元运算符 当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。 Vue.component('my-component', { template: 'Hi' }) 使用组件时添加一些class： Hi style绑定 data: { activeColor: 'red', fontSize: 30 } css属性名可以使用小驼峰或者短横线分隔 直接绑定到一个样式对象上通常更好，这样模板更清晰 data: { styleObject: { color: 'red', fontSize: '13px' } } 对象语法常常结合返回对象的计算属性使用 使用数组语法可以将多个样式对象应用到同一个元素上 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 条件渲染 v-if、v-show 指令 v-if vs v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 列表渲染 v-for 指令 绑定 key 数组更新检测 变更方法（变异方法） 调用这些方法后，原数组本身会受影响： push() pop() unshift() shift() splice() sort() reverse() 调用变更方法后修改数组后，页面会响应式渲染 替换数组 如 slice() 、concat() 这类方法，调用后原数组本身不受影响，页面没有响应式渲染，如果需要将调用结果响应式渲染，可使用替换数组的方式，即利用 = 赋值运算符重新将数组数据值修改。 事件处理 v-on 指令 内联处理器中的方法 可以传递 $event 代表事件对象 事件修饰符： .stop .prevent 表单处理 v-model 指令 v-model 是语法糖。 v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 new Vue({ el: '...', data: { checkedNames: [] } }) 请选择 A 修饰符： .lazy：在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步 .number：将用户的输入值转为数值类型 .trim：自动过滤用户输入的首尾空白字符 过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： { { message | capitalize }} 你可以在一个组件的选项中定义本地的过滤器： filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } 或者在创建 Vue 实例之前全局定义过滤器： Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) new Vue({ // ... }) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 组件系统 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。 定义组件 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 选项 const options = { // template 是关联视图的html模板 template: ` 自定义的组件 `, data: function () { return { message: 'hello' } } } 一个组件的data选项必须是一个函数，因此每个对象实例可以维护一份被返回对象的独立的拷贝，如果不这样，一个组件实例被改变就会影响到其他组件实例。 注册组件 全局： Vue.component(name, options) //或者通过字面量 Vue.component(name, { // template 是关联视图的html模板 template: ` 自定义的组件 ` }) 局部： new Vue({ el: '#app', data: { message: 'hello' }, components: { 'sub-header': { template: ` 自定义的组件 ` } } }) 在父组件的选项对象中添加 components 字段，注册父组件中可以使用到的子组件（即局部注册） 使用组件 将组件名作为自定义标签名来使用，使用标签名时，采用短横线命名规范（即多个单词之间使用 - 分隔） 组件的data 为什么必须是一个函数（面试） 组件是可被复用的，同一个组件创建出的不同实例彼此之间应该是相互独立的。对象是引用数据类型，如果组件选项中的 data 属性是一个普通对象，则同一个组件所创建出来的所有实例会共享（共用）同一个data对象的数据，则任意一个实例对 data 中数据修改时，其它实例都会受影响。 将 data 定义为一个函数，在该函数体内部返回一个普通对象，这样，当创建组件实例时，会调用 data() 方法，获取返回的新数据对象，则各组件实例间就有自己独立的数据对象了（互不受影响），这与实际开发更符合。 组件通信（面试） 组件与组件之间传递数据 父子组件通信： 父传子：利用 props 属性传递 使用组件时数据不会自动传递到组件里，因为组件有自己独立的作用域。要将数据传到子组件里，我们要使用prop，在子组件中注册： const options = { template: ` { {abc}} `, props: ['todos'] } 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。 一个prop被注册之后，你就可以在父组件中把数据作为一个自定义attribute传递进来： 子传父：利用事件。在父组件中使用子组件时，绑定一个自定义事件；在子组件中需要传递数据时，触发($emit())在父组件中绑定的事件即可。 handleAdd() { // 在子组件的事件处理函数中触发父组件中绑定的 add 事件，向父组件传递数据,父组件通过事件处理函数接收并处理数据 this.$emit('add', this.inputVlaue) } 跨组件跨层级通信： 转换为父子组件通信 event-bus（事件总线）：借助事件，将数据从一个组件中传递到另一个组件中。 利用 Vue 对象实例的 $on() 与 $emit() 方法 $on() 用于注册事件监听 $emit() 用于触发指定的事件 通信（传递数据）：在 Vue 原型上添加 $bus 属性；在需要接收数据的组件中，调用 $on() 注册事件监听，在需要传递数据的组件中，调用 $emit() 触发事件并传递数据 //1.向Vue 的原型中添加一个自定义的 $bus 属性用于在组件间传递数据（event-bus） //在Vue的原型中添加的属性，在每个Vue实例及组件实例中都可以通过原型链调用到该属性(在相应的js文件而不是.vue组件文件中) Vue.prototype.$bus = new Vue() //2.在接收数据的组件中调用$on注册事件监听，在生命周期中如created方法中注册，即当组件创建完成后执行 created() { //在实例创建完成后执行 this.$bus.$on('remove', this.removeTodoItem)//监听remove事件，调用removeTodoItem方法 } //3.在发送数据的组件中调用$emit触发自定义的事件，传递数据 handleRemve() { this.$bus.$emit('remove', this.item.id) } 使用vuex Props 属性 Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。 props 是组件从父组件接收到的数据: { props: ['propName1', 'propName2'] } 可以简单定义一个数组，声明组件所能接收并处理的属性名称。 组件 props 属性中接收到的数据也会被直接挂载到组件实例下，可以直接打点调用 也可以将 props 定义为一个对象，可实现对属性的验证 { props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } } } 注意： props 应该是只读的，即不要修改组件获得到的属性值 如果业务中涉及到可能修改属性的值，则需要尝试转换为 data 或 computed 计算属性的方式重新设计。 单个根元素 当构建一个组件时，你的模板如果包含多个元素，Vue会报错：every component must have a single root element (每个组件必须只有一个根元素)。你可以将模板的内容包裹在一个父元素内，来修复这个问题 单文件组件 后缀名为 *.vue 的文件，在 webpack 中处理该类型的文件，会使用 vue-loader 的 loader 来处理。 // JS 交互逻辑 /* 样式 */ 在 vs-code 中可安装 Vetur 插件，在 *.vue 文件中才会有代码高亮及部分代码提示功能。 插槽 作用：在使用组件时，向组件内部分发内容。可以是字符串、HTML标签或其他组件 使用：`` 相当于是一个占位符，如果是非命名插槽，只能传一组数据，而命名插槽可以通过name传多组数据，当组件渲染时，solt标签内的内容将会被替换为传进来的内容。 solt标签内可以设置内容作为后备（默认）内容，当使用组件时没有传递任何数据就会使用默认内容渲染 规则：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。所以插槽中传递的数据只能是父作用域下的 命名插槽（具名插槽） 在使用具名插槽分发内容时，可以使用 slot 属性或 v-slot 指令 slot 属性是 v2.6 之前版本中使用的 v-slot 指令是 v2.6 中新增的语法，现在推荐使用 v-slot 指令 v-slot 指令需要用在 标签内部，即： v-slot 可以简写为 # 在组件中定义插槽 在父组件中使用插槽： Here might be a page title A paragraph for the main content. And another one. Here's some contact info 注意 v-slot 只能添加在 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。 独占默认插槽的缩写语法：当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上： 生命周期 生命周期：指的是一个 Vue 实例或组件从开始创建，到最终销毁，全阶段所经历的所有过程。 生命周期钩子（函数）（面试） 就是在组件正常的生命周期过程中，提供了一些回调函数，在这些回调函数中可以添加用户自己的代码，完成特定的自定义功能。 create 阶段 beforeCreate()：在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用 created() - 可以调用到 data 中的数据，在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。 mount 阶段 beforeMount()：在挂载开始之前被调用：相关的 render 函数首次被调用。 该钩子在服务器端渲染期间不被调用。 mounted() - 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 vm.$nextTick 到该生命周期钩子函数中，才可以获取到渲染后的 DOM 节点 update 阶段 当数据发生变化时，会进行 update 更新阶段 beforeUpdate()：在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。 updated()：在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick 该钩子在服务器端渲染期间不被调用。 destroy 阶段 通常在销毁阶段会销毁哪些资源（面试）：启动的定时器、主动注册的事件监听、未完成的网络请求、打开的 socket 连接等 beforeDestroy()：实例销毁之前调用。在这一步，实例仍然完全可用。 该钩子在服务器端渲染期间不被调用。 destroyed()：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。 该钩子在服务器端渲染期间不被调用。 渲染函数（render）-了解 简单的说，在vue中我们使用模板HTML语法来组建页面的，使用render函数我们可以用js语言来构建DOM。因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。 当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。官网上给他起了个名字叫createElement。还有约定它的简写叫h render(createElement) { // render } createElement() 创建的虚拟节点元素 createElement() 有三个参数：标签、属性、孩子节点 在组件中可以这样使用： Vue.component('anchored-heading', { render: function (createElement) { return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) }, props: ['level'] }) 虚拟DOM vue核心之虚拟DOM(vdom) - 简书 (jianshu.com) span_1 链接 会被编译为 render() 渲染函数中的内容： render(createElement) { return createElement( 'div', { className: 'container' }, [ createElement( 'span', { title: '提示', className: '_span' }, ['span_1'] ), createElement( 'a', { href: '/' }, ['链接'] ), ] ) } 调用后，返回一个对象： { tag: 'div', props: { className: 'container' }, children: [ { tag: 'span', props: { title: '提示', className: '_span' }, children: ['span_1'] }, { tag: 'a', props: { href: '/' }, children: ['链接'] }, ] } 这是一个保存在内存中的虚拟 DOM 元素结构，这个结构与实体 DOM 树结构映射。Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码： return createElement('h1', this.blogTitle) createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。 我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 Vnode必须唯一：组件树中的所有VNode必须是唯一的，如果需要重复多次的元素/组件，可以使用工厂函数来实现 使用JavaScript代替模板功能，如v-if、v-for、v-model 事件&按键修饰符：对于 .passive、.capture 和 .once 这些事件修饰符，Vue 提供了相应的前缀可以用于 on JSX：通过Babel插件，可以在Vue中使用JSX语法，他可以让我们回到接近模板的语法上 render: function (h) { // h 表示createElement的别名 return ( Hello world! ) } 响应式原理（了解） 数据劫持 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 // 数据 const data = { message: 'Hello' } // 布局模板 const htmlTemplate = document.querySelector('#app').innerHTML // 渲染函数 function render() { document.querySelector('#app').innerHTML = htmlTemplate.replace('{ { message }}', data.message) } render() // 数据劫持处理 let _message = data.message Object.defineProperty(data, 'message', { configurable: true, enumerable: true, get() { // 用于获取属性值 // TODO.... return _message }, set(val) { // 用于设置属性值 _message = val // TODO....... render() } }) v2.x 版本中，使用 Object.defineProperty() 实现数据劫持 v3.x 版本中，使用 Proxy 实现数据劫持 声明响应式property 由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值： var vm = new Vue({ data: { // 声明 message 为一个空值字符串 message: '' }, template: '{ { message }}' }) // 之后设置 `message` vm.message = 'Hello!' 如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的 property。 异步更新队列 可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 nextTick()--面试 在下次 DOM 更新循环结束之后执行延迟回调。 在修改数据之后立即使用这个方法，获取更新后的 DOM。 Vue CLI Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，其内部封装了 webpack 的相关配置。 安装 版本问题： 2.x 版本创建的项目，会在项目根目录中有多余的关于 webpack 配置的目录及文件。通常是 config 与 build 目录及目录内的文件。 3.x/4.x 版本创建的项目，是将 webpack 的配置专门封装到npm包中，在项目根目录下没有相关的 webpack 配置文件存在。 全局安装 vue-cli: $ npm install -g @vue/cli 安装成功后，可在 cmd 命令提示符下执行 vue --version 测试查看版本信息： $ vue --version 创建项目 图形化用户界面（GUI）： $ vue ui 命令行： 执行创建项目命令： $ vue create vue-cli-demo 开始利用向导选择项目中使用到的特性： Please pick a preset: > Manually select features 确认项目中的特性： Check the features needed for your project: (Press to select, to toggle all, to invert selection) >(*) Choose Vue version >(*) Babel >(*) CSS Pre-processors >(*) Linter / Formatter 选择 vue 版本： Choose a version of Vue.js that you want to start the project with (Use arrow keys) > 2.x 选择 css 预处理器： Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) > Sass/SCSS (with node-sass) 选择 ESLint Pick a linter / formatter config: (Use arrow keys) > ESLint + Standard config 保存代码时验证代码是否符合规范 Pick additional lint features: (Press to select, to toggle all, to invert selection) >(*) Lint on save 选择在独立文件中保存配置文件 Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys) > In dedicated config files 是否将此前步骤中的选择保存为模板供以后创建项目使用 Save this as a preset for future projects? (y/N) N 自动根据前述选择，开始创建项目结构并安装依赖资源 package.json npm scripts { \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\" }, } serve：启动开发环境的任务，会打开开发环境下的 webpack-dev-server 服务器，默认监听 8080 端口 build：启动构建任务，主要用于构建生产环境下的代码 lint：启动规范格式化任务，可将不满足规范的代码格式化 可以使用 npm run 执行 关于 @vue/cli-service 包 内部封装了 webpack 配置，npm scripts 中的任务执行就依赖于这个包。 项目目录结构 |--project |--public # 单页面应用页面所在目录 |--src # 源代码 |--|--main.js # 应用的入口JS文件 |--|--App.vue # 单文件组件 |--.eslintrc.js # eslint 规范配置文件 |--babel.config.js # babel 配置文件 |--package.json # 应用配置文件 Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 通常使用 vuex 来管理应用中各组件会共享共用的数据。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 概念 store：仓库，是一个容器，包含着你的应用中大部分的状态 (state) state：状态，组件需要共享的数据 getter：是 store 中的计算属性，相当于组件中的 computed，Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数,也可以接受其他getter作为第二个参数 getters: { doneTodos: (state, getters) => { return state.todos.filter(todo => todo.done) } } getter可以通过属性访问，在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的；也可以通过方法访问，通过getter返回一个函数，来实现给getter传参 store.getters.doneTodos // 通过属性访问 getters: { // ... getTodoById: (state) => (id) => { // 在getter中返回函数 return state.todos.find(todo => todo.id === id) } } store.getters.getTodoById(2) // 通过方法访问 mutation：是函数结构，修改状态数据，用于进行 state 的同步更新，约定，mutation 是唯一能够进行状态更新的位置 Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) mutation更像是事件注册，不能直接调用，要以相应的type调用sotre.commit方法 store.commit('increment') 提交mutation 的另一种方式是直接使用包含type属性的对象，当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变 mutations: { increment (state, payload) { state.count += payload.amount } } store.commit({ type: 'increment', amount: 10 }) 在组件中使用 this.$store.commit('xxx') 提交 mutation 提交载荷：你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload），载荷可以是一个变量，但大多数情况应该是一个对象： mutations: { increment (state, payload) { state.count += payload.amount } } store.commit('increment', { amount: 10 }) action：是函数结构，类似于mutation，区别是： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Action 通过 store.dispatch 方法触发： store.dispatch('increment') 在组件中使用 this.$store.dispatch('xxx') 分发 action mutation 必须同步执行，而Action 就不受约束！我们可以在 action 内部执行异步操作： actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() => { commit('someOtherMutation') }) } } 注意：一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 module：模块，可将 store 分割成一个个的小的 module，各 module 有自己的 state、getter、mutation、action，甚至子 module 使用 安装 $ npm i vuex 创建 store import Vue from 'vue' import Vuex from 'vuex' // 使用核心插件 Vuex Vue.use(Vuex) // 创建 Store const store = new Vuex.Store({ state: { // todos 中保存所有待办事项，在 todo-input、todo-list 组件中都会使用到 todos: [{ id: 1, title: '复习 JavaScript', completed: false }] }, getters: {}, mutations: { // 唯一进行状态更新的地方 removeTodoItem(state, id) { state.todos = state.todos.filter(todo => todo.id !== id) }, addTodoItem(state, title) { state.todos.push({ id: state.length + 1, title, completed: false }) }, actions: {}, modules: {} }) // 导出 export default store 注入到 Vue 根实例中 import Vue from 'vue' import store from './store' new Vue({ // ... store }) 将 store 注入 Vue 根实例后，在所有的组件实例中，都可以使用 this.$store 调用到 store 对象 handleModify() { // 调用 store 中 mutation 方法，实现状态更新 // mutation 方法不能直接被调用到，而是需要使用 // $store.commit(type, payload) 来提交 mutation this.$store.commit('toggleTodoItem', this.item.id) } 编写 state及更新 state 的mutation mutations: { modifyState (state, id) { state.todos.forEach(current => { if (current.id === id) { current.state = !current.state } }) }, removeItem (state, id) { state.todos = state.todos.filter(current => { return current.id !== id }) } } 组件中调用 state 及 mutation { computed: { todos() { this.$store.state.todos } }, methods: { handler() { this.$store.commit('mutation-type', 'payload') } } } 注意，在组件中不能直接调用到 mutation 方法，而是需要使用 $store.commit() 来提交 mutation （类似于使用 $emit() 触发事件） 也可以使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store） import { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } } 严格模式 SPA Single Page Application 单页面应用 是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。 前端路由 前端路由，不会发送 html 页面请求到服务器，就能直接实现界面切换（是在 JS 中完成）。 由于是单页面应用，服务器上只保存了一个 html 页面，所以浏览器访问到该页面时，也会将引用的 js 下载到浏览器本地。 在页面中仍然存在超级链接可以点击切换页面，但这种切换页面并不是真正访问服务器上的 html 页面，而是通过 JS 来实现界面切换（DOM操作）。 window.onhashchange = function() { console.log('hash change', location.hash) switch(location.hash) { case '#home': document.querySelector('.page').innerHTML = '这是首页' break default: document.querySelector('.page').innerHTML = '404' } } 模式 hash：在URL中采用#号来作为当前视图的地址，改变#号后的参数，页面并不会重载。 history：利用 h5 中 history 新增的 API: pushState()、replaceState() ，在调用这些 API 时不会发送新的请求到后端（页面不会重新加载）。 history 模式的路由表面上与访问服务端的路由一致（相比 hash 模式来说，没有 #） history 模式的路由使用需要在服务器上进行相关配置 Vue Router Vue.js 官方的路由管理器 使用 安装 $ npm i vue-router 创建 VueRouter 实例 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home' import About from '../views/About' import Profile from '../views/Profile' // 使用 vue-router 核心插件 Vue.use(VueRouter) // 创建 VueRouter 实例 const router = new VueRouter({ mode: 'hash', // 前端路由模式：hash、history routes: [ // 静态路由配置信息 { path: '/home', component: Home } ] }) export default router 注入到 Vue 根实例中 import Vue from 'vue' import App from './App.vue' import router from './router' Vue.config.productionTip = false new Vue({ router, render: h => h(App) }).$mount('#app') 将 router 注入 Vue 根实例后，可在后代组件中使用到两个属性（面试）： $router：指代的是 VueRouter 实例 $route：当前激活的路由 两个组件 ：链接，导航，默认会渲染为 超级链接 ：占位，将满足路径中当前访问路由对应的 component 组件进行渲染。 路由元信息 在进行路由相关功能开发时，需要与当前路由相关使用到的数据，可以携带在元信息中，使用meta字段表示。 命名视图 有时候想同时(同级)展示多个视图，而不是嵌套展示，例如创建一个布局， 有sidebar (侧导航)和main (主内容)两个视图,这个时候命名视图就派上用场了。 为组件添加name属性(即命名视图)， 可使用对应名称指定在视图中 渲染的组件。如果没有name属性,其name值默认为default 命名路由 是在路由配置项中添加 name 属性，有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候 编程式的导航 除了使用创建 a 标签来订导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 router.push(location) - 会添加历史记录 router.replace(location) - 不会添加历史记录 router.back() router.forward() router.go() 参数： 可取字符串 this.$router.push('/home') 也可取对象this.$router.push({}) {path, query} {name, params} 注意： params 必须与 name 配合，不能与 path 共存 通常query这个单词与传递查询字符串（？）参数有关，params这个单词与传递动态路由参数(/path/to/:params)有关 路由重定向 在路由中配置 const routes = [ ... { path: '/', redirect: '/home'， // 访问根路径时重定向到/home } ] 嵌套路由 通常对应组件的嵌套结构 导航守卫 作用：守卫导航 导航守卫主要用来通过跳转或取消的方式守卫导航 钩子函数 全局 beforeEach(callback) - 全局前置守卫，可以在这个钩子函数中进行用户权限拦截 回调函数有三个参数：to、from、next to：即将进入的目标路由对象 from：正要离开的路由 next：下一步，是在导航解析流程中的“下一步”，是一个函数结构。 next()：正常走下一步 next(false)：中断导航 next(path)：重新跳转到新地址 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。 beforeResolve() afterEach() 路由独享 beforeEnter() 组件内 beforeRouteEnter() - 不能独 this 获取到组件实例，如果需要使用组件实例，则在 next(callback) 的回调函数中会传递组件实例作为参数 beforeRouteUpdate() - 在重用的组件中被调用到 beforeRouteLeave() UI 组件库 常见UI组件库 PC端 Element UI iView ant design of vue 移动端 mint-ui vant 使用 以 Element-UI 组件库为例： 安装 $ npm i element-ui 引入 全部引入 将组件库中的所有组件一次性引入项目中，在使用组件时，不需要再考虑引入哪些就可以直接使用。 缺点：在打包构建时，项目中未使用到的组件也会打包进最后的 bundle 中，会增大代码包的体积。 // 在 main.js 中引入： // ...... import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) 按需引入 是组件库中使用到哪个组件时，才引入使用，未使用到的不需要引入。 优点：可以有效的保证打包后代码包的体积最优 缺点：比较繁琐 安装 babel 插件包： $ npm install babel-plugin-component -D 配置 babel 相关（修改 babel.config.js 配置文件）： module.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ [ 'component', { libraryName: 'element-ui', styleLibraryName: 'theme-chalk' } ] ] } 在自定义的组件中引入 ElementUI 组件： // main.js // 按需引入 import { Button, DatePicker, Badge } from 'element-ui' // 全局注册组件 Vue.component(Button.name, Button) // 也可以写作： Vue.use(DatePicker) Vue.use(Badge) // 在组件中仍然使用 来使用到 ElementUI 组件 注意：全部引入与按需引入通常不能共存 vue-element-admin 文档 演示地址 网络请求 ajax fetch API axios vue-resource axios 浏览器中对 XMLHttpRequest 进行封装 支持 Promise API 支持请求/响应拦截处理 支持取消请求 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/Vue/npm命令.html":{"url":"笔记/Vue/npm命令.html","title":"Npm命令","keywords":"","body":"npm 查看安装了哪些包 指令1： npm list --depth=0 –depth 表示深度，我们使用的模块会有依赖，深度为零的时候，不会显示依赖模块 这个指令可以用来 显示 出我们的项目中安装了哪些模块，其实就是 package.json 文件中 的 dependencies 和 devDependencies 的和 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list --depth=0 当然我们可以在加参数 npm list --depth=0 [--dev | --production] 指令2： npm list --depth --global 这个指令用来查看全局安装了哪些工具 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list --depth=0 --global C:\\Users\\by\\AppData\\Roaming\\npm +-- chrome-remote-interface@0.25.4 +-- create-react-app@1.4.0 +-- eslint@4.17.0 +-- jshint@2.9.4 +-- less@2.7.2 +-- live-server@1.2.0 +-- mysql@2.15.0 +-- sass@1.0.0-beta.1 +-- sequelize-auto@0.4.29 +-- vue-cli@2.8.2 `-- webpack@3.6.0 指令3： npm list 这个指令用来查看某个模块是否安装了 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list element-ui awesome_pos@1.0.0 C:\\Users\\by\\Desktop\\jsPang\\awesomePos `-- element-ui@2.2.2 官网详情 这篇文章目的在于推荐下几个常用的指令 传送门 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-02-15 23:20:13 "},"笔记/Vue/如何理解vue数据双向绑定原理.html":{"url":"笔记/Vue/如何理解vue数据双向绑定原理.html","title":"如何理解Vue数据双向绑定原理","keywords":"","body":"Vue 数据双向绑定原理是通过数据劫持结合发布者-订阅者模式的方式来实现的，首先是对数据进行监听，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图 MVC 模式 以往的 MVC 模式是单向绑定，即 Model 绑定到 View，当我们用 JavaScript 代码更新 Model 时，View 就会自动更新 MVVM 模式 MVVM 模式就是 Model–View–ViewModel 模式。它实现了 View 的变动，自动反映在 ViewModel，反之亦然。对于双向绑定的理解，就是用户更新了 View，Model 的数据也自动被更新了，这种情况就是双向绑定。再说细点，就是在单向绑定的基础上给可输入元素 input、textare 等添加了 change(input)事件,(change 事件触发，View 的状态就被更新了)来动态修改 model。 双向绑定原理 vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 Watcher 看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令（如 v-model，v-on）对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 因此接下去我们执行以下 3 个步骤，实现数据的双向绑定： （1）实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 （2）实现一个订阅者 Watcher，每一个 Watcher 都绑定一个更新函数，watcher 可以收到属性的变化通知并执行相应的函数，从而更新视图。 （3）实现一个解析器 Compile，可以扫描和解析每个节点的相关指令（v-model，v-on 等指令），如果节点存在 v-model，v-on 等指令，则解析器 Compile 初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。 实现一个 Observer Observer 是一个数据监听器，其实现核心方法就是 Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行 Object.defineProperty( )处理 如下代码实现了一个 Observer。 function Observer(data) { this.data = data; this.walk(data); } Observer.prototype = { walk: function(data) { var self = this; //这里是通过对一个对象进行遍历，对这个对象的所有属性都进行监听 Object.keys(data).forEach(function(key) { self.defineReactive(data, key, data[key]); }); }, defineReactive: function(data, key, val) { var dep = new Dep(); // 递归遍历所有子属性 var childObj = observe(val); Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function getter () { if (Dep.target) { // 在这里添加一个订阅者 console.log(Dep.target) dep.addSub(Dep.target); } return val; }, // setter，如果对一个对象属性值改变，就会触发setter中的dep.notify(), //通知watcher（订阅者）数据变更，执行对应订阅者的更新函数，来更新视图。 set: function setter (newVal) { if (newVal === val) { return; } val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); dep.notify(); } }); } }; function observe(value, vm) { if (!value || typeof value !== 'object') { return; } return new Observer(value); };// 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数 function Dep () { this.subs = []; } Dep.prototype = { /** * [订阅器添加订阅者] * @param {[Watcher]} sub [订阅者] */ addSub: function(sub) { this.subs.push(sub); }, // 通知订阅者数据变更 notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; Dep.target = null; 在 Observer 中，当初我看别人的源码时，我有一点不理解的地方就是 Dep.target是从哪里来的，相信有些人和我会有同样的疑问。这里不着急，当写到 Watcher 的时候，你就会发现，这个 Dep.target是来源于 Watcher。 实现一个 Watcher Watcher 就是一个订阅者。用于将 Observer 发来的 update 消息处理，执行 Watcher 绑定的更新函数。 如下代码实现了一个 Watcher function Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; this.value = this.get(); // 将自己添加到订阅器的操作} Watcher.prototype = { update: function() { this.run(); }, run: function() { var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); } }, get: function() { Dep.target = this; // 缓存自己 var value = this.vm.data[this.exp] // 强制执行监听器里的get函数 Dep.target = null; // 释放自己 return value; } }; 在我研究代码的过程中，我觉得最复杂的就是理解这些函数的参数，后来在我输出了这些参数之后，函数的这些功能也容易理解了。vm，就是之后要写的 SelfValue 对象，相当于 Vue 中的 new Vue 的一个对象。exp 是 node 节点的 v-model 或 v-on：click等指令的属性值。 上面的代码中就可以看出来，在 Watcher 的 getter 函数中，Dep.target指向了自己，也就是 Watcher 对象。在 getter 函数中， var value = this.vm.data[this.exp] // 强制执行监听器里的get函数。 这里获取vm.data[this.exp] 时，会调用Observer中Object.defineProperty中的get函数 get: function getter () { if (Dep.target) { // 在这里添加一个订阅者 console.log(Dep.target) dep.addSub(Dep.target); } return val; }, 从而把 watcher 添加到了订阅器中，也就解决了上面 Dep.target是哪里来的这个问题。 实现一个 Compile Compile 主要的作用是把 new SelfVue 绑定的 dom 节点，（也就是 el 标签绑定的 id）遍历该节点的所有子节点，找出其中所有的 v-指令和\" { {}} \". （1）如果子节点含有 v-指令，即是元素节点，则对这个元素添加监听事件。（如果是 v-on，则 node.addEventListener('click'），如果是 v-model，则 node.addEventListener('input'))。接着初始化模板元素，创建一个 Watcher 绑定这个元素节点。 （2）如果子节点是文本节点，即\" { { data }} \",则用正则表达式取出\" { { data }} \"中的 data，然后 var initText = this.vm[exp]，用 initText 去替代其中的 data。 实现一个 MVVM 可以说 MVVM 是 Observer，Compile 以及 Watcher 的“boss”了，他需要安排给 Observer，Compile 以及 Watche 做的事情如下 （1）Observer 实现对 MVVM 自身 model 数据劫持，监听数据的属性变更，并在变动时进行 notify （2）Compile 实现指令解析，初始化视图，并订阅数据变化，绑定好更新函数 （3）Watcher 一方面接收 Observer 通过 dep 传递过来的数据变化，一方面通知 Compile 进行 view update。 最后，把这个 MVVM 抽象出来，就是 vue 中 Vue 的构造函数了，可以构造出一个 vue 实例。 最后写一个 html 测试一下我们的功能 self-vue #app { text-align: center; } { {title}} { {name}} click me! var app = new SelfVue({ el: '#app', data: { title: 'hello world', name: 'canfoo' }, methods: { clickMe: function () { this.title = 'hello world'; } }, mounted: function () { window.setTimeout(() => { this.title = '你好'; }, 1000); } }); 先执行 mvvm 中的 new SelfVue(...)，在 mvvm.js 中， observe(this.data); new Compile(options.el, this); 先初始化一个监听器 Observer，用于监听该对象 data 属性的值。 然后初始化一个解析器 Compile，绑定这个节点，并解析其中的 v-，\" { {}} \"指令，（每一个指令对应一个 Watcher）并初始化模板数据以及初始化相应的订阅者，并把订阅者添加到订阅器中（Dep）。这样就实现双向绑定了。 如果 v-model 绑定的元素， 即输入框的值发生变化，就会触发 Compile 中的 node.addEventListener('input', function(e) { var newValue = e.target.value; if (val === newValue) { return; } self.vm[exp] = newValue; val = newValue; }); self.vm[exp] = newValue;这个语句会触发 mvvm 中 SelfValue 的 setter，以及触发 Observer 对该对象 name 属性的监听，即 Observer 中的 Object.defineProperty（）中的 setter。setter 中有通知订阅者的函数 dep.notify,Watcher 收到通知后就会执行绑定的更新函数。 最后的最后就是效果图啦： 以上就是如何理解 vue 数据双向绑定原理的详细内容，更多请关注我！！！！！！！ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/Vue/手摸手，带你用vue撸后台 系列一（基础篇） - 掘金.html":{"url":"笔记/Vue/手摸手，带你用vue撸后台 系列一（基础篇） - 掘金.html","title":"手摸手，带你用Vue撸后台 系列一（基础篇）   掘金","keywords":"","body":"完整项目地址：vue-element-admin 系列文章： 手摸手，带你用 vue 撸后台 系列一（基础篇） 手摸手，带你用 vue 撸后台 系列二(登录权限篇) 手摸手，带你用 vue 撸后台 系列三 (实战篇) 手摸手，带你用 vue 撸后台 系列四(vueAdmin 一个极简的后台基础模板) 手摸手，带你用 vue 撸后台 系列五(v4.0 新版本) 手摸手，带你封装一个 vue component 手摸手，带你优雅的使用 icon 手摸手，带你用合理的姿势使用 webpack4（上） 手摸手，带你用合理的姿势使用 webpack4（下） 前言 说好的教程终于来了，第一篇文章主要来说一说在开始写实际业务代码之前的一些准备工作吧，但这里不会教你 webpack 的基础配置，热更新原理是什么，webpack速度优化等等，有需求的请自行 google，相关文章已经很多了。 目录结构 ├── build // 构建相关 ├── config // 配置相关 ├── src // 源代码 │ ├── api // 所有请求 │ ├── assets // 主题 字体等静态资源 │ ├── components // 全局公用组件 │ ├── directive // 全局指令 │ ├── filtres // 全局 filter │ ├── icons // 项目所有 svg icons │ ├── lang // 国际化 language │ ├── mock // 项目mock 模拟数据 │ ├── router // 路由 │ ├── store // 全局 store管理 │ ├── styles // 全局样式 │ ├── utils // 全局公用方法 │ ├── vendor // 公用vendor │ ├── views // view │ ├── App.vue // 入口页面 │ ├── main.js // 入口 加载组件 初始化等 │ └── permission.js // 权限管理 ├── static // 第三方不打包资源 │ └── Tinymce // 富文本 ├── .babelrc // babel-loader 配置 ├── eslintrc.js // eslint 配置项 ├── .gitignore // git 忽略项 ├── favicon.ico // favicon图标 ├── index.html // html模板 └── package.json // package.json 复制代码 这里来简单讲一下src文件 api 和 views 简单截取一下公司后台项目，现在后台大概有四五十个 api 模块 如图可见模块有很多，而且随着业务的迭代，模块还会会越来越多。 所以这里建议根据业务模块来划分 views，并且 将views 和 api 两个模块一一对应，从而方便维护。如下图： 如 article 模块下放的都是文章相关的 api，这样不管项目怎么累加，api和views的维护还是清晰的，当然也有一些全区公用的api模块，如七牛upload，remoteSearch等等，这些单独放置就行。 components 这里的 components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。如图： store 这里我个人建议不要为了用 vuex 而用 vuex。就拿我司的后台项目来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，文章模块和评论模块几乎是俩个独立的东西，所以根本没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token,用户信息，或者是一些全局个人偏好设置等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！ webpack 这里是用 vue-cli 的 webpack-template 为基础模板构建的，如果你对这个有什么疑惑请自行google，相关的配置绍其它的文章已经介详细了，这里就不再展开了。简单说一些需要注意到地方。 jquery (本项目已移除) 管理后台不同于前台项目，会经常用到一些第三方插件，但有些插件是不得不依赖 jquery 的，如市面很多富文本基都是依赖 jquery 的，所以干脆就直接引入到项目中省事(gzip之后只有34kb，而且常年from cache,不要考虑那些吹毛求疵的大小问题，这几kb和提高的开发效率根本不能比)。但是如果第三方库的代码中出现则会直接报错。要达到类似的效果，则需要使用 webpack 内置的 ProvidePlugin 插件，配置很简单，只需要 new webpack.ProvidePlugin({ $: 'jquery' , 'jQuery': 'jquery' }) 复制代码 这样当 webpack 碰到 require 的第三方库中出现全局的$、jQeury和window.jQuery 时，就会使用 node_module 下 jquery 包 export 出来的东西了。 alias 当项目逐渐变大之后，文件与文件直接的引用关系会很复杂，这时候就需要使用alias 了。 有的人喜欢alias 指向src目录下，再使用相对路径找文件 resolve: { alias: { '~': resolve(__dirname, 'src') } } //使用 import stickTop from '~/components/stickTop' 复制代码 或者也可以 alias: { 'src': path.resolve(__dirname, '../src'), 'components': path.resolve(__dirname, '../src/components'), 'api': path.resolve(__dirname, '../src/api'), 'utils': path.resolve(__dirname, '../src/utils'), 'store': path.resolve(__dirname, '../src/store'), 'router': path.resolve(__dirname, '../src/router') } //使用 import stickTop from 'components/stickTop' import getArticle from 'api/article' 复制代码 没有好与坏对与错，纯看个人喜好和团队规范。 ESLint 不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。这所谓工欲善其事，必先利其器，个人推荐 eslint+vscode 来写 vue，绝对有种飞一般的感觉。效果如图： 每次保存，vscode就能标红不符合eslint规则的地方，同时还会做一些简单的自我修正。安装步骤如下： 首先安装eslint插件 安装并配置完成 ESLint 后，我们继续回到 VSCode 进行扩展设置，依次点击 文件 > 首选项 > 设置 打开 VSCode 配置文件,添加如下配置 \"files.autoSave\":\"off\", \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", { \"language\": \"vue\", \"autoFix\": true } ], \"eslint.options\": { \"plugins\": [\"html\"] } 复制代码 这样每次保存的时候就可以根据根目录下.eslintrc.js你配置的eslint规则来检查和做一些简单的fix。这里提供了一份我平时的eslint规则地址，都简单写上了注释。每个人和团队都有自己的代码规范，统一就好了，去打造一份属于自己的eslint 规则上传到npm吧，如饿了么团队的 config，vue的 config。 vscode 插件和配置推荐 封装 axios 我们经常遇到一些线上 的bug，但测试环境很难模拟。其实可以通过简单的配置就可以在本地调试线上环境。 这里结合业务封装了axios ，线上代码 import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config => { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error => { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response => response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() => { // store.dispatch('FedLogOut').then(() => { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error => { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service 复制代码 import request from '@/utils/request' //使用 export function getInfo(params) { return request({ url: '/user/info', method: 'get', params }); } 复制代码 比如后台项目，每一个请求都是要带 token 来验证权限的，这样封装以下的话我们就不用每个请求都手动来塞 token，或者来做一些统一的异常处理，一劳永逸。 而且因为我们的 api 是根据 env 环境变量动态切换的，如果以后线上出现了bug，我们只需配置一下 @/config/dev.env.js 再重启一下服务，就能在本地模拟线上的环境了。 module.exports = { NODE_ENV: '\"development\"', BASE_API: '\"https://api-dev\"', //修改为'\"https://api-prod\"'就行了 APP_ORIGIN: '\"https://wallstreetcn.com\"' //为公司打个广告 pc站为vue+ssr } 复制代码 妈妈再也不用担心我调试线上bug了。 当然这里只是简单举了个例子，axios还可以执行多个并发请求，拦截器什么的，大家自行去研究吧。 多环境 vue-cli 默认只提供了dev和prod两种环境。但其实正真的开发流程可能还会多一个sit或者stage环境，就是所谓的测试环境和预发布环境。所以我们就要简单的修改一下代码。其实很简单就是设置不同的环境变量 \"build:prod\": \"NODE_ENV=production node build/build.js\", \"build:sit\": \"NODE_ENV=sit node build/build.js\", 复制代码 之后在代码里自行判断，想干就干啥 var env = process.env.NODE_ENV === 'production' ? config.build.prodEnv : config.build.sitEnv 复制代码 新版的 vue-cli 也内置了 webpack-bundle-analyzer 一个模块分析的东西，相当的好用。使用方法也很简单，和之前一样封装一个 npm script 就可以。 //package.json \"build:sit-preview\": \"cross-env NODE_ENV=production env_config=sit npm_config_preview=true npm_config_report=true node build/build.js\" //之后通过process.env.npm_config_report来判断是否来启用webpack-bundle-analyzer var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin()) 复制代码 效果图 webpack-bundle-analyzer这个插件还是很有用的，对后期的代码优化什么的，最重要的是它够装逼~ 前后端交互 每个公司都有自己一套的开发流程，没有绝对的好与坏。这里我来讲讲我司的前后端交互流程。 跨域问题 首先前后端交互不可避免的就会遇到跨域问题，我司现在全是用 cors来解决的，如果你司后端嫌麻烦不肯配置的话，dev环境也可以通过 webpack-dev-server的proxy来解决，开发环境用nginx反代理一下就好了，具体配置这里就不展开了。 前后端的交互问题 其实大家也知道，平时的开发中交流成本占据了我们很大一部分时间，但前后端如果有一个好的协作方式的话能解决很多时间。我司开发流程都是前后端和产品一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才是对接接口的。这里推荐一个文档生成器 swagger。 swagger是一个REST APIs文档生成工具，可以在许多不同的平台上从代码注释中自动生成，开源，支持大部分语言，社区好，总之就是一个强大，如下图的api 文档(swagger自动生成，ui忽略) api 地址，需要传是没参数，需要的传参类型，返回的数据格式什么都一清二楚了。 前端自行mock 如果后端不肯来帮你 mock 数据的话，前端自己来 mock 也是很简单的。你可以使用mock server 或者使用 mockjs + rap 也是很方便的。 不久前出的 easy-mock也相当的不错，还能结合 swagger。 我们大前端终于不用再看后端的脸色了~ iconfont element-ui 默认的icon不是很多，这里要安利一波阿里的iconfont简直是神器，不管是公司项目还是个人项目都在使用。它提供了png,ai,svg三种格式，同时使用也支持unicode，font-class，symbol三种方式。由于是管理后台对兼容性要求不高，楼主平时都喜欢用symbol，晒一波我司后台的图标(都是楼主自己发挥的)。 详细具体的使用可以见文章 手摸手，带你优雅的使用 icon router-view different router the same component vue。真实的业务场景中，这种情况很多。比如 我创建和编辑的页面使用的是同一个component,默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，官方说你可以通过watch $route的变化来做处理，但其实说真的还是蛮麻烦的。后来发现其实可以简单的在 router-view上加上一个唯一的key，来保证路由切换时都会重新渲染触发钩子了。这样简单的多了。 computed: { key() { return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date() } } 复制代码 优化 有些人会觉得现在构建是不是有点慢，我司现在技术栈是容器服务，后台项目会把dist文件夹里的东西都会打包成一个docker镜像，基本步骤为 npm install npm run build:prod 加打包镜像，一共是耗时如下 复制代码 还是属于能接受时间的范围。 主站PC站基于nodejs、Vue实现服务端渲染，所以不仅需要依赖nodejs，而且需要利用pm2进行nodejs生命周期的管理。为了加速线上镜像构建的速度，我们利用taobao源 registry.npm.taobao.org 进行加速, 并且将一些常见的npm依赖打入了基础镜像，避免每次都需要重新下载。 这里注意下 建议不要使用cnpm install或者update 它的包都是一个link，反正会有各种诡异的bug，这里建议这样使用 npm install --registry=https://registry.npm.taobao.org 复制代码 如果你觉得慢还是有可优化的空间如使用webpack dll 或者把那些第三方vendor单独打包 external出去，或者我司现在用的是http2 可以使用AggressiveSplittingPlugin等等，这里有需求的可以自行优化。 占坑 常规占坑，这里是手摸手，带你用vue撸后台系列。 完整项目地址：vue-element-admin 手摸手，带你用 vue 撸后台 系列一（基础篇） 手摸手，带你用 vue 撸后台 系列二(登录权限篇) 手摸手，带你用 vue 撸后台 系列三 (实战篇) 手摸手，带你用 vue 撸后台 系列四(vueAdmin 一个极简的后台基础模板) 手摸手，带你用 vue 撸后台 系列五(v4.0 新版本) 手摸手，带你封装一个 vue component 手摸手，带你优雅的使用 icon 手摸手，带你用合理的姿势使用 webpack4（上） 手摸手，带你用合理的姿势使用 webpack4（下） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:13:55 "},"笔记/js笔记/Day01-基本语法.html":{"url":"笔记/js笔记/Day01-基本语法.html","title":"Day01 基本语法","keywords":"","body":"历史 网景：JavaScript 微软：JScript ECMA：ECMAScript(ES) (ECMA-262) (ES3、ES5、ES6) https://developer.mozilla.org/zh-CN/ 语法基础 引入 JS 这个标签是可以放置在文件中的任意位置，但通常 标签放置在 之前。 引入外部 JS 资源，在引入外部 JS 时， 必须添加独立的 结束标签，在标签内部不能添加其它的额外 JS 代码。 输出 console.log('打印输出日志信息') document.write('写入文档，可包含 HTML 标签结构') 变量 变量是内存中一块数据存储的空间，主要用于保存需要进行运算的数据。 三要素： 变量名 - 通常变量名查找到在内存空间中的地址 变量值 - 内存空间中保存的数据 数据类型 - 保存某个数据时所分配的空间大小 JS 是弱类型的语言，在定义变量时，不需要指定数据类型。 定义变量 var 变量名; // 变量声明 变量名 = 变量值; // 变量赋值 var 变量名 = 变量值; // 声明并赋值 如： // 定义变量，保存本金 var money; // 声明变量 money = 1000; // 变量赋值 // 定义变量，保存利率 var rate = 0.0175; // 变量声明并赋值 // 计算，使用变量名引用变量值 var result = money * rate; 使用变量 直接利用变量名引用变量值进行使用即可： console.log(result) 变量名命名规则： 可以包含的字符：字母、数字、下划线(_)、$ 不能以数字开头 不能够是关键字 关键字 关键字，是 JS 语言本身需要使用到的有特殊函义的单词，如：var、let、const、for、if、switch....... 变量命名规范： 选取简洁的英文单词作为变量名（见名知意） 采用(小)驼峰命名规范（第一个单词首字母小写，其它单词首字母大写，除首字母之外，其它所有字母小写） 数据类型 原始（基本）类型 Number，数字，主要用于表示数字，NaN、Infinity String，字符串，主要用于表示文本数据，使用单引号 '' 或双引号 \"\" 将要表示的文本内容包含起来 Boolean，布尔，主要用于表示条件的真假，有两个取值：true、false Undefined，未定义，有一个取值：undefined，如：变量只作声明没有赋值时，就是 undefined Null，空，有一个取值：null Symbol(ES6)，符号，表示唯一值，使用 Symbol() 语法来定义 Symbol 的值 BigInt(ES11)，大整数，在需要表示的数字后添加字母 n 来表示是 BigInt 类型的数字 引用类型 Object，对象，一系列属性数据的无序集合，表示方式：{ name: '小明', age: 18 } typeof 运算符 可以使用 typeof 求解某个表达式的数据类型，其求解的结果是一个字符串. 'number' 'string' 'boolean' 'undefined' 'object' 'symbol' 'bigint' 'function' 数据类型转换 显式类型转换（强制类型转换） parseInt() parseFloat() Number() Boolean() String() parseInt() / parseFloat() : 主要用于将字符串解析为数字，在解析字符串内容时，会有一定的容错能力。如果字符串中包含非法的数字，则解析到该第一个非法数字符号之前，如果第一个符号就是非法的符号，则返回 NaN Number()：主要用于将其它类型数据转换为数字，在将字符串转换为数字时，没有容错能力。 Boolean()：主要用于将其它类型转换为布尔 String()：主要用于将其它类型转换为字符串 隐式类型转换 由 JS 引擎在执行 JS 代码时，自动实现类型转换操作 运算符 算术运算符 + - * / % （模，求余数） 条件运算符 > >= === / == !== / != 利用条件运算符运算的结果，数据类型为 Boolean 类型，即结果取值为 true 或 false。 === 与 == 的区别： == 在比较相等时，如果两边的表达式类型不一致，会先尝试自动转换为同种数据类型后比较，在类型一致的情况下再比较值是否相等。 === 在比较相等时，会进行严格比较，即如果两边的类型不一致，则直接返回 false 在实际使用中，推荐使用 === 比较相等。 !== 与 != 的区别与相等(=== 与 ==)判断的区别类似。!== 在判断不等时会严格区分类型，!= 在数据类型不一致时会先尝试转换类型。 逻辑运算符 &&：并且 ||：或者 !：非 && 与 || 也叫短路运算符。 && 使用时，如果第一个表达式为 false，不再进行第二个表达式运算 || 使用时，如果第一个表达式为 true，不再进行第二个表达式运算 赋值运算符 = 将 = 右边的值赋值给左边的变量进行保存 复合运算符 结合了算术运算符与赋值运算符的使用： += -= *= /= %= 利用运算符左侧的变量与运算符右侧的表达式进行运算，运算规则是运算符第一个符号的运算规则，将最终运算结果放回左侧变量空间中保存。 自增、自减运算符 ++ var i = 10 i++ // ++i console.log(i) ++ 作为后缀（如 i++ ），先引用，后运算（先使用 i 的值，后进行 i 自增运算） ++ 作为前缀（如 ++i），先运算，后引用（先进行 i 自增运算，再使用运算后的结果值） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day02-条件结构.html":{"url":"笔记/js笔记/Day02-条件结构.html","title":"Day02 条件结构","keywords":"","body":"Review 变量：变量名、变量值、数据类型 数据类型：Boolean、String、Number、Null、Undefined、Symbol、BigInt、Object typeof：'boolean'、'string'、'number'、'object'、'undefined'、'symbol'、'bigint'、'function' 数据类型转换：parseInt()、parseFloat()、Number()、Boolean()、String() 运算符： 算术运算符 ：+、-、*、/、%。 使用 + 号时，需要注意，如果 + 号两边的表达式都是数字，则进行算术的加，如果有任何一个为字符串的值，则进行的是字符串拼接操作 条件运算符（关系运算符）：>、=、 逻辑运算符：&&、||、! 赋值运算符：= 自增、自减：++、-- 前缀：先运算，后引用 后缀：先引用，后运算 复合运算符：+=、-=、*=、/=、%= NaN与任何的值都不相等，包括它自身 练习： 为抵抗洪水，战士连续作战89小时，编程计算共多少天零多少小时？ var days = parseInt(89 / 24) var hours = 89 % 24 小明要到美国旅游，可是那里的温度是以华氏度为单位记录的。它需要一个程序将华氏温度（80度）转换为摄氏度，并以华氏度和摄氏度为单位分别显示该温度。 提示：摄氏度与华氏度的转换公式为：摄氏度 = 5/9.0*(华氏度-32) 。保留3位小数 var c = 5 / 9.0 * (80 - 32) c = c.toFixed(3) toFixed(num) 表示将数字转换为字符串，保留小数点后指定 num 位的小数字符 计算两个文本框中输入数字的和 var k=0; console.log(k++ + ++k +k +k++) var k=0 // var result = K++ + 5 // result = 5 k = 1 console.log(k++ + ++k +k +k++) // k = 3 console.log(0 + 2 + 2 + 2) 计算两个文本框的加减乘除 流程控制语句 顺序结构：按照代码书写的先后顺序依次执行 选择结构（条件结构、分支结构） 循环结构 选择结构 有条件的执行操作，在满足条件的情况下执行，不满足条件由不执行。 语法 if(条件表达式) { // 语句块 // 在条件表达式为 true 时执行的语句块 } if(条件表达式) { // 语句块 // 在条件表达式为 true 时执行的语句块 } else { // 语句块 // 当条件表达式为 false 时执行的语句块 } if(条件表达式1) { // 语句块 // 在条件表达式1为 true 时执行的语句块 } else if(条件表达式2) { // 语句块 // 在条件表达式1为 false，条件表达式2为 true 时执行的语句块 } else if(...) { // statement } else { // 语句块 // 当所有条件均为 false 时执行的语句块 } 当 if 或 else 语句块中只一条可执行语句时，可以省略 {} 的书写。 switch(表达式) { case 常量1: // 当 (表达式 === 常量1) 相等时，执行该语句块 break // 退出选择结构 case 常量2: // 当 (表达式 === 常量2) 相等时，执行该语句块 break case ...: // ...... break default: // 当前述所有条件都不满足时，执行默认语句块 } 通常 switch 用于等值条件判断。 case 语句块中的 break 语句是可以省略的，当省略 break 语句时，会导致 case 语句贯穿 多重 if 与 switch 通常都是多重条件判断，在选择使用时，一般等值条件判断优先选择使用 switch。 流程图： 比如：他说他喜欢他 使用文字描述可能会产生歧义，使用图形描述会更形象（一图胜千言） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day03-循环结构.html":{"url":"笔记/js笔记/Day03-循环结构.html","title":"Day03 循环结构","keywords":"","body":"Review 选择结构： if (条件表达式) { // 条件表达式为 true 时执行的语句块 } else { // 条件表达式为 false 时执行的语句块 } if (条件表达式1) { // 条件表达式1为 true 时执行的语句块 } else if (条件表达式2) { // 条件表达式2为 true 时执行的语句块 } else if (条件表达式3) { // 条件表达式3为 true 时执行的语句块 } else { // 前述所有条件均为 false 时执行的语句块 } switch (表达式) { case 常量1: // 语句块(当 表达式 === 常量1 时执行到的语句块) break case 常量2: // 语句块(当 表达式 === 常量2 时执行到的语句块) break case 常量3: // 语句块(当 表达式 === 常量3 时执行到的语句块) break default: // 语句块 break } 判断一个整数是偶数还是奇数，并输出判断结果： if (num % 2 === 0) { // 偶数 } else { // 奇数 } 开发一款软件，根据公式（身高-108）*2=体重，可以有10斤左右的浮动。来观察测试者体重是否合适： var height = 178 var weight = 135 var standard = (height - 108) * 2 if (weight >= standard - 10 && weight 输入数字（范围为 0-6，0表示星期天，1-6表示星期一到星期六），显示星期几： switch(day) { case 0: // 星期天 break case 1: // 星期一 break // ...... } 根据一个数字日期，判断这个日期是这一年的第几天： var year = 2016, month = 4, date = 11, totalDays = 0 /* var isRn = (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) ? '闰年' : '平年' if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) { isRn = '闰年' } else { isRn = '平年' } */ switch(month) { case 1: totalDays = date break case 2: totalDays = 31 + date break case 3: totalDays = 31 + 28 + date break case 4: totalDays = 31 + 28 + 31 + date break // ...... } if (month > 2) { if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) { totalDays += 1 } } console.log('当年第' + totalDays + '天') var year = 2016, month = 12, date = 11, totalDays = 0 switch(month) { case 12: totalDays += 30 case 11: totalDays += 31 case 10: totalDays += 30 case 9: totalDays += 31 case 8: totalDays += 31 case 7: totalDays += 30 case 6: totalDays += 31 case 5: totalDays += 30 case 4: totalDays += 31 case 3: totalDays += year % 4 === 0 && year % 100 !== 0 || year % 400 === 0 ? 29 : 28 case 2: totalDays += 31 case 1: totalDays += date } console.log('当年第' + totalDays + '天') 补充： 三目运算符：条件表达式 ? 条件表达式为 true 时执行的表达式 : 条件表达式为 false 时执行的表达式 循环结构 当有大量重复或有规范动作需要执行时，可使用循环结构 语法： while (条件表达式) { // 当条件表达式为 true 时执行的语句块 } do { // 当条件表达式为 true 时执行的语句块 // 语句块第一次的执行是无条件执行的 } while (条件表达式) for (初始化; 条件表达式; 变量更新) { // 当条件表达式为 true 时执行的语句块 } 流程图： 使用循环的步骤： 找出循环条件和循环操作 代入循环的语法结构 判断能否退出循环，如果不能退出循环结构(死循环)，需要构建退出的条件 关于循环结构的选择： 通常 while 与 do-while 循环用于循环次数不确定的情况，而 for 用于循环次数确定的情况。大部分情况下循环次数都是确定的，所以 for 循环使用会更多。 在选择使用 while 与 do-while 时，通常先判断后执行时选择使用 while，先执行后判断使用 do-while。 跳转语句： break; continue; 当在循环主体中遇到 break; 语句，表示退出（结束）整个循环结构操作； 遇到 continue; 语句，表示结束当前次循环，还会判断条件执行下一次循环。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day04-函数（上）.html":{"url":"笔记/js笔记/Day04-函数（上）.html","title":"Day04 函数（上）","keywords":"","body":"Review 循环结构语法： while (条件表达式) { // 条件表达式为 true 时执行的语句块 } 先判断，后执行 do { // 语句块 } while (条件表达式) 先执行，后判断 for (初始化; 条件表达式; 变量更新) { // 语句块 } 初始化 判断条件 条件满足，执行语句块，条件不满足，退出循环结构 变量更新 回第2步继续判断条件 跳转语句： break; - 结束其所在的整个循环结构，即如果还有未执行的循环操作，不再执行 continue; - 结束当前次循环，还会判断条件继续执行下一次循环操作 选择： 循环次数不确定，优先选择 while 、do-while 如果是先执行后判断，优先选择 do-while，如果先判断后执行，则优先选择 while for 循环通常用于循环次数确定的情况 三种循环结构是可以相互转换的 练习： 计算输入日期（如：2021, 10, 3）是距离1900年1月1日以来的第多少天 函数 实现代码复用 本质上是一个代码块，该代码块可以在其它的代码块中被调用执行，以实现复用。 语法： // 定义 function 函数名(参数列表) { // 代码块 // return 返回值 } // 调用 函数名(参数列表) 定义函数时，参数列表是可选的（可以不定义参数，也可以定义参数） 参数 参数，相当于是函数体内部的输入数据。即函数体内部实现功能时，如果需要使用到的数据在函数体内部不能直接解决数据来源，可使用参数的方式向函数体内部输入数据。 形式参数（形参）：是函数定义时的参数 实际参数（实参）：是函数调用时传递的实际数据 返回值 返回值，是函数体内部运算结果的返回。 函数体内部使用 return 表达式 的结构返回值（即将表达式的最终运算结果作为返回值返回到函数调用处） 在函数体内部遇到 return 表示结束函数的调用（同时将表达式的结果值返回），在 return 语句后如果还有未执行的代码块不再执行。 跳转语句： break; continue; return 表达式; 函数定义的写法： // 声明 function 函数名(形参列表) { // 函数主体 } // 函数表达式 var 变量名 = function(形参列表) { // 匿名函数 // 函数主体 } // 了解，创建对象方式的写法 var 变量名 = new Function('参数字符串', '函数主体字符串') 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day05-函数（下）.html":{"url":"笔记/js笔记/Day05-函数（下）.html","title":"Day05 函数（下）","keywords":"","body":"Review 函数定义语法： // 声明 function 函数名(形参) { // 语句块 } // 函数表达式 var 变量名 = function(形参) { // 语句块 } // 创建对象：了解 var 变量名 = new Function('形参', '语句块') 参数（输入）： 形参：函数定义时的参数 实参：函数调用时的参数 返回值（输出）： return 表达式; 遇到 return 表示结束函数的调用，并将表达式的结果返回到函数调用处 作用域 作用范围 全局作用域 在全局范围内定义的变量，整个 html 文件的 script 中都可以使用到的变量。 真实的开发业务中，尽量少使用全局变量，因为可能会存在全局变量命名污染问题（在一个 HTML 中引入多个外部 JS 时，各外部 JS 文件中都有取相同名称的全局变量） 函数作用域 利用 var 在函数体内部所定义的变量，可在整个函数体内部被调用到，其拥有的是函数作用域 块级作用域 只在其所定义的语句块范围内有效，超出范围不能使用 ES6：使用 let / const 来定义变量，拥有块级作用域 ES6之前：IIFE（立即调用函数表达式） 声明提升 利用 var 所定义的变量，利用声明方式定义的函数，存在“声明提升”的现象（在 JS 引擎中执行 JS 时的预解析过程）。 在执行 JS 代码时，会先将所有使用 var 所定义的变量声明部分提升到对应作用域的最顶部（赋值部分仍保留在原位置）。对于函数，如果是使用声明方式定义的函数（function 函数名(){} 这种方式），会将函数整体提升到对应作用域的最顶部，对于函数表达式方式定义的函数，只提升声明部分，不提升函数主体。 let/const 不存在声明提升，但存在“暂存死区”（暂时性死区） let/const let 用于定义变量（可以重复进行赋值操作） const 用于定义常量（即第一次赋值后不能再重新赋值修改变量值） let 定义变量，可先声明，后赋值，const 定义变量需要在声明的同时赋值（以后不能再使用 = 进行赋值运算） 递归 在函数体内部实现自身函数的调用 练习： 求菲波拉契数列中某项的值。 菲波拉契数列特点：1, 1, 2, 3, 5, 8, 13, 21, 34............. IIFE IIFE (Immediately Invoked Function Expression) 立即调用函数。 (function () { statements })(); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day06-Array数组.html":{"url":"笔记/js笔记/Day06-Array数组.html","title":"Day06 Array数组","keywords":"","body":"Review 变量 var / let / const 数据类型，typeof 运算符 流程控制语句： 顺序结构 选择结构 循环结构 跳转语句 函数 定义 参数 返回值 调用 递归 内存中数据的保存 栈内存：保存的是基本类型的值，引用类型的 “引用” 堆内存：保存的是对象的具体数据 对象相当于是通过一个变量名，能够使用到多个所保存的数据（对象是一系列属性的集合），可以使用 对象名. 或 对象名['字符串索引'] 来访问到对象的属性值。 内置对象 https://developer.mozilla.org/zh-CN/ JavaScript 本身所提供给我们可以直接使用到的对象 Array 作用：用于保存一组数据值 定义 语法： var array = [] // 直接量 var array = new Array() // 创建数组对象 var array = [val1, val2, val3, ...] // 创建的同时初始化数组 var array = new Array(val1, val2, ......) var array = new Array(number) // 创建数组对象，同时初始化空间大小 元素：数组中所保存数据的空间 下标（索引 - index）：数组中所保存元素的编号，编号从 0 开始 长度：数组中所保存元素的个数，使用 .length 属性获取或设置 数组元素的引用 要使用到数组中保存的某个数据值，是通过下标来引用到数组的元素值。例： scores[5] 数组的 API(ES3) 数组对象的属性与方法。内置对象数组本身提供的一些方法，可供我们直接调用到来实现相应功能。 属性： length：获取或设置数组的长度 方法（函数）： 添加元素 push() - 向数组末尾添加元素，返回数组的新的长度，如果有多个元素，可使用 , （逗号）分隔 unshift() - 向数组头部添加元素 splice(index, length, val1, val2, ......) - （用于数组元素的删除），当length 参数为0时，表示删除0个元素，有 val1, val2, 等参数时，将这些值插入指定 index 索引处。 删除元素 pop() - 从末尾删除一个元素，返回被删除的元素值 shift() - 从头部删除一个元素 splice(index, length) - 从指定 index 索引处删除 length 个元素，返回的是一个数组，包含了被删除的所有元素 连接 concat() - 连接两个或多个数组，返回连接后的新数组，原数组不受影响 join(sep) - 使用指定的符号sep将数组中每个元素连接成一个字符串后返回，如果不传递参数，默认使用 ',' （英文半角的逗号）连接 toString() - 将数组转换为字符串，返回值与没有参数的 join() 方法返回的字符串相同。 排序 reverse() - 反转数组元素，原数组本身受影响 sort() - 数组元素排序，默认（不传参数）按照数组元素字符串unicode编码升序排序。如果需要按照指定的规则排序，则需要传递比较函数作为参数 截取 slice(start, end) - 从原数组中截取一个子数组片段，start 为起始索引，end 为结束索引，会包含开始索引处的元素，不包含结束索引处的元素。end 可以省略，表示截取到最后。start 与 end 可以取负值，表示从后向前计数取索引 冒泡排序 N: 数组长度 使用二重循环来实现冒泡排序的比较，外层循环控制比较的轮数，内层循环控制每轮比较的次数。 通常外层循环使用循环变量 i，内层循环使用循环变量 j 来控制循环次数，循环变量初始值为 0。 外层循环 N - 1 内层循环 N - 1 - i 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day07-ES5、String字符串.html":{"url":"笔记/js笔记/Day07-ES5、String字符串.html","title":"Day07 ES5、String字符串","keywords":"","body":"Day2. ES5/String 第一节：精讲 严格模式 \"use strict\" 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 全局变量声明时 必须加var \"use strict\"; x = 3.14; this 无法指向全局对象 function f(){ \"use strict\"; return !this; } // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 不允许变量重名: \"use strict\"; function x(p1, p1) {}; // 报错 ES5新增数组常见方法（indexof/forEach/map/reduce/filter） indexOf(data,start) O要大写 indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引 var arr = [1,3,5,7,7,5,3,1]; console.log(arr.indexOf(5)); //2 console.log(arr.lastIndexOf(5)); //5 console.log(arr.indexOf(5,2)); //2 console.log(arr.lastIndexOf(5,4)); //2 console.log(arr.indexOf(\"5\")); //-1 forEach() 循环 对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值 var arr = [1, 2, 3, 4, 5]; arr.forEach(function(x, index, a){ console.log(x + '|' + index + '|' + (a === arr)); }); // 输出为： // 1|0|true // 2|1|true // 3|2|true // 4|3|true // 5|4|true map(callback) ； 会遍历当前数组，然后调用参数中的方法，返回当前方法的返回值; var arr = [1, 2, 3, 4, 5]; var arr2 = arr.map(function(item){ return item*item; }); console.log(arr2); //[1, 4, 9, 16, 25] filter() 过滤 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; var arr2 = arr.filter(function(x, index) { return index % 3 === 0 || x >= 8; }); console.log(arr2); //[1, 4, 7, 8, 9, 10] 字符串的两种创建方式（常量和构造函数） var str=\"亲\" var str = new String(“hello”) 第二节：强化练习 敏感词过滤 密码格式要求 留言过滤 第三节：精讲 ASCII码和字符集 ASCII（American Standard Code for Information Interchange:美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的系统，并等同于国际标准ISO/IEC 646 ``` var str = \"A\"; str.charCodeAt(); // 65 var str1 = 'a'; str1.charCodeAt(); // 97 ``` 字符串常见API str.length (计算空格) charAt(3) //获取下标为3的字符 默认是第0个 找不到的情况 charCodeAt(3) //获取下标为3的字符的Unicode码 String.fromCharCode() 0-9 48-57 检测字符串中有没有数字 var stringValue = \"hello world\"; console.log(stringValue.charAt(1));//e console.log(stringValue.charCodeAt(1));//101 console.log(stringValue[1]);//e indexOf(\"abc\") 查找字符串第一次出现的位置 第二个参数 从第几个开始找 lastIndexOf(\"abc\") 查找字符串最后一次出现的位置 如果没找到 返回-1 可以同时找几个 只查一次 找到字符串中 'www.1000phone.com' 1是第几个 找到字符串中 '' 某个字出现过几次 第几位 while(str.indexOf(s,i) != -1){ alert(str.indexOf(s,i)) i = str.indexOf(s,i)+s.length } 字符串的比较 '1000' > '2' '1000' > 2 '张三' > '李四' substring(start,end)//截取字符串，从第start位开始，到end位停止 substring(0,2) substring(2,0) substring() // 默认从0-最后 split(separator, howmany) //根据分隔符、拆分成数组 'hello' 分割 'www.1000phone.com' 分割 '2019-04-04' 分割 限制截取长度 toLowerCase() toUpperCase() 第四节：强化练习 统计字符串中每个字符的个数？ var testStr = 'aoifhoiwehfoiweiwadakl'; var i; var tempObj = {}; for (i = 0; i 第五节：强化练习 数字字母混合验证码 aabccd统计每个字符出现的次数，结果显示 a 2、b 1、c 2、d1，去掉重复的字符，使结果显示 abcd JSON表示对象的方法 JSON（JavaScript Object Notation）一种简单的数据格式 {名称1:值,名称2:值2} 元素值可具有的类型：string, number, object, array, true, false, null for in 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day08-Math、Date.html":{"url":"笔记/js笔记/Day08-Math、Date.html","title":"Day08 Math、Date","keywords":"","body":"Math Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。 在 Math 对象中的属性与方法都是通过 Math 来进行调用的。 API 方法 Math.random() - 随机数，[0, 1) Math.floor() - 向下取整 Math.ceil() - 向上取整 Math.round() - 四舍五入取整数 Math.pow(x, y) - x的y次方 Math.abs() - 取绝对值 Math.max() - 取参数中的最大值 Math.min() - 取参数中的最小值 Math.sqrt() - 开平方根 属性 Math.PI - 圆周率 JSON（ES5） JavaScript Object Notation - JavaScript 对象表示法。 JSON 是用于数据传递的一种语法格式，其本质是一个字符串，在这个字符串中，可以表示出 JavaScript 中的各类型数据。 通常我们在不同系统之间要传递数据时，使用 JSON 格式的文本来实现数据传递。 现在公司前后端分离的情况下，后端向前端传递数据，基本也使用的是 JSON 格式传递数据。 在 JSON 字符串中，可表示的数据有： 对象 数组 数值 字符串 布尔值 null 注意： JSON 格式中表示字符串数据时，必须使用 \"\" (双引号) 包含 JSON 格式中表示对象时，对象属性名称必须使用 \"\" （双引号）包含 JSON 格式中表示数组或对象时，不能在最后一个元素后加多余的尾逗号 API JSON.stringify() - 序列化，将 JS 的值转换为 JSON 格式的字符串 JSON.parse() - 反序列化，将 JSON 格式的字符串内容还原为 JS 的值 eval() eval() 函数会将传入的字符串当做 JavaScript 代码进行执行 eval() 存在严重的安全问题，永远不要使用 eval()!!! Number API toFixed() - 将数字转换为字符串，保存小数点后指定位数的小数 toString(radix) - 将数字转换为对应的字符串，radix 是可选参数，表示在转换为字符串时所使用的进制 Number.parseInt(str, radix) - 与全局的 parseInt() 等价 Date 作用：用于处理与日期时间相关的数据 创建 Date 对象 new Date() // 以系统当前时间创建 Date 对象 new Date(value) // value 是一个整数，表示距 1970-1-1 0:0:0 以来的毫秒值 new Date(dateString) // dateString 是一个表示日期时间的字符串，通常使用 - 或 / 号分隔日期, :分隔时间 new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]) // 传递年、月、日、时、分、秒、毫秒 作为参数创建日期时间对象 API 获取 getFullYear() - 年 (注：getYear表示的是距离1900年的年份，属于历史遗留问题) getMonth() - 月，返回值范围为 0 - 11 getDate() - 日 getHours() - 时 getMinutes() - 分 getSeconds() - 秒 getMillseconds() - 毫秒 getDay() - 星期几 getTime() - 获取距 1970-1-1 0:0 的毫秒 设置 setFullYear() - 年 setMonth() - 月，返回值范围为 0 - 11 setDate() - 日 setHours() - 时 setMinutes() - 分 setSeconds() - 秒 setMillseconds() - 毫秒 setTime() - 获取距 1970-1-1 0:0 的毫秒 练习： 定义函数，格式化日期时间字符串，YYYY-MM-dd HH:mm:ss 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day09-BOM、DOM.html":{"url":"笔记/js笔记/Day09-BOM、DOM.html","title":"Day09 BOM、DOM","keywords":"","body":"Review 定义函数，格式化日期时间字符串 ES6 模板字符串 \"字符串\" '字符串' `字符${expression}串` 在模板字符串中，可以使用 ${expression} 结构来将表达式的运算结果拼接在字符串中 获取距离 1970-1-1 0:0:0 的毫秒值： new Date().getTime() +new Date() new Date().valueOf() Date.now() BOM Browser Object Model（浏览器对象模型） 使得我们能够在 JavaScript 脚本中与浏览器 “对话” Window 对象 Window 对象表示浏览器中打开的窗口 Window 对象是在 JavaScript 中的一个全局对象，使用 window 来引用 Window 对象。 API window 对象下属性与方法的调用可使用 window. 进行调用，也可以省略 window. 的书写而直接调用 属性 普通属性 name - 窗口名称 innerWidth - 内部显示区域的宽度 innerHeight - 内部显示区域的高度 对象属性 location - 代表浏览器中当前打开的 URL，使用 window.location 或 location 引用 history - 历史记录，使用 window.history 或 history 引用 navigator - Navigator 对象包含有关浏览器的信息，navigator.userAgent document screen 方法 alert() - 弹出警告框 prompt() - 弹出输入框 confirm() - 弹出确认框 注意：使用 alert()、prompt()、confirm() 弹框，可能会阻塞浏览器渲染，实际开发中通常不再使用这几个方法。 open() - 打开新窗口 close() 定时器、计时器 setTimeout() - 一次性定时 setInterval() - 周期性定时 clearTimeout() - 清除由 setTimeout() 启动的定时器 clearInterval() - 清除由 setInterval() 启动的定时器 Location 代表浏览器中当前打开的 URL URL 格式： 协议://域名:端口/资源路径?查询字符串参数#hash 如： https://www.w3school.com.cn:443/jsref/dom_obj_location.asp https://www.baidu.com/s?wd=iframe&rsv_spt=1&rsv_iqid=0x88d6ee170002acf2&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=&tn=baiduhome_pg&ch=&rsv_enter=0&rsv_dl=ib&rsv_btype=i http 默认端口为 80 https 默认端口为 443 API 属性 protocol - 协议 hostname - 域名 port - 端口 host - 域名+端口 pathname - 资源路径 search - 查询字符串，包括 ? hash - 锚点值，包括 # href - 完整的 URL 可使用 location.href = 'url' 来跳转页面，可简写为 location = 'url' 方法 reload() - 重新加载、刷新 assign(url) - 加载新的文档，可认为内部是封装的对 location.href 的赋值操作 replace(url) - 以新文档替换当前文档（当前文档的访问记录不会添加到历史记录中） History 代表浏览器访问的历史记录，仅能获取到历史记录列表的长度，能够实现前进、后退操作，不能获取具体的历史记录url信息 API 属性 length - 记录条数 方法 back() - 后退，仅能后退一个历史记录 forward() - 前进，仅能前进一个历史记录 go(n) - 前进/后退，可前进/后退多(n)个历史记录，n 大于 0 表示前进，n 小于 0 表示后退 定时器 setTimeout() setInterval() const id = setTimeout(function() {}, time) const id = setInterval(function() {}, time) time 是定时时间，单位毫秒 在定时时间 time 到达后，再执行第一个参数（函数）中的任务 定时器函数调用后，会返回定时器的 id，该 id 用于停止定时器 clearTimeout() 与 clearInterval() 调用时的参数传递。 可以使用 setTimeout() 来实现周期性定时任务（利用函数的递归）： function fn() { // 定时需要执行的任务:TODO...... // 利用 setTimeout() 启动定时器，在 fn 函数体 // 内部，当定时时间到后执行 fn 函数本身的调用（递归） setTimeout(fn, 1000) } fn() 异步机制 JavaScript 是单线程的应用程序，在 JS 引擎中同时只能处理一条语句的执行，必须前一条语句执行完才能执行后一条语句。 通常使用 setTimeout() 与 setInterval() 在定时的时候定时时间长短不一，如果等定时时间到达并执行完定时任务后，再继续身后执行语句，则存在定时时间内 CPU 资源闲置浪费的情况。 所以对于 setTimeout() 、setInterval() 的设计采用异步机制来完成，即先会处理定时任务后的语句块，再回头执行定时任务。 了解 Event Loop 情况。 练习： 计算当前时间距离 2021-11-26 00:00:00 还有 ?天?小时?分?秒 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day10-DOM.html":{"url":"笔记/js笔记/Day10-DOM.html","title":"Day10 DOM","keywords":"","body":"Review JavaScript 是单线程的应用，setTimeout、setInterval 是利用异步机制来实现定时的 Event Loop setTimeout() 与 setInterval() 指定的定时时间到达后，不一定马上执行回调函数，可能会被延迟（受单线程主线程中执行效率的影响） DOM Document Object Model (文档对象模型) document 对象是 DOM 中最顶层的对象。 DOM 树 节点： 层级： 父节点、子节点 兄弟：有共同父节点的节点间互为兄弟节点 根节点、叶子节点（终端节点） 类型： 元素（标签）节点、文本节点、属性节点、注释节点 在文档中获取元素的方法： document.getElementById(id) // 根据 id 查找元素节点，不能找到则返回 null，找到则返回对应的 DOM 元素对象 document.getElementsByTagName(tagname) // 根据标签名查找元素，返回集合（类数组对象），集合中包含了查找到的元素节点 document.getElementsByClassName(className) // 根据标签使用的 css 类名查找元素，返回集合（类数组对象），集合中包含了查找到的元素节点 document.getElementsByName(name) // 根据标签的 name 属性值查找元素，返回集合（类数组对象），集合中包含了查找到的元素节点 document.querySelector(selector) // 根据CSS选择器查找满足条件的第一个元素 document.querySelectorAll(selector) // 根据CSS选择器查找满足条件的所有元素 获取或设置元素节点的属性 const value = element.getAttribute(name) // 根据标签的属性名获取对应的属性值 element.setAttribute(name, value) // 设置标签的属性 const value = element. element. = value 节点本身的属性 node.nodeType -- 节点的类型，返回数字，1 表示元素节点，3 表示文本节点 node.nodeName -- 节点名称，返回字符串，元素节点名称通常为标签的大写字符串，文本节点名称通常为：#text node.nodeValue -- 节点值，文本节点返回节点中的文本值，元素节点固定返回 null element.tagName -- 获取元素标签名 筛选层级节点 node.parentNode // 获取节点的父节点 element.childNodes // 获取孩子节点，会包含所有的孩子文本节点、元素节点、注释节点等 element.children // 获取孩子元素节点 element.firstChild // 第一个孩子节点 element.firstElementChild // 第一个孩子元素节点 element.lastChild // 最后一个孩子节点 element.lastElementChild // 最后一个孩子元素节点 node.previousSibling // 前一个兄弟节点 node.previousElementSibling // 前一个兄弟元素节点 node.nextSibling // 后一个兄弟节点 node.nextElementSibling // 后一个兄弟元素节点 常用：parentNode、children、previousElementSibling、nextElementSibling 元素节点内部文本 element.innerHTML -- 内部 html 文本 element.innerText -- 内部纯文本 element.textContent -- 内部纯文本 创建并添加节点 const element = document.createElement('标签名') // 创建元素节点 const text = document.createTextNode('文本内容') // 创建文本节点 element.appendChild(node) // 在元素节点内部末尾追加孩子节点 element.insertBefore(newNode, oldNode) // 在 element 元素内部 oldNode 节点前插入 newNode 节点 删除节点 node.parentNode.removeChild(node) // 从父节点中删除孩子节点 node.remove() // IE不支持(不建议) 克隆节点 const clone = node.cloneNode(bool) // 克隆节点，bool 为 true 时，将后代节点也一并克隆 CSSOM const _style = element.style // 获取行内（内联）样式，但不能获取到外部样式表文件中的样式 const _style = window.getComputedStyle(element, null) // 获取经过计算的样式（节点上最终起作用的样式），返回 CSSStyleDeclaration 类型的对象 element.style. = '属性值' // 设置样式，通常都是设置为行内样式 const classnames = element.className // 获取所有的 class 类名字符串 const list = element.classList // 获取所有类名的列表，返回类数组对象，可使用 add()、remove() 等方法添加、删除类名 练习： 输入行数，列数，动态生成一个表格，表格行实现隔行变色功能 类似购物车操作 添加购物车商品 修改商品数量 删除选购商品 计算小计金额 计算合计金额 ...... 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day11-DOM、事件.html":{"url":"笔记/js笔记/Day11-DOM、事件.html","title":"Day11 DOM、事件","keywords":"","body":"事件 事件驱动模型：对于不同的动作行为，应用程序给予不同反馈。 事件 事件类型： click - 点击 mousedown - 鼠标按下 mouseup - 鼠标弹起 mousemove - 鼠标移动 mouseover / mouseenter - 鼠标移入 mouseout / mouseleave - 鼠标移出 keydown - 键盘按下 keyup - 键盘弹起 keypress - 键盘按压 focus - 获得焦点 blur - 失去焦点 ...... 事件监听器 事件处理程序：函数 事件源 事件流 处理事件的流程 事件捕获 从祖先节点到事件源元素节点之间进行事件传播的行为。 事件冒泡 集中式进行事件处理。事件源元素上的事件处理完毕后，会向父级及祖先节点进行事件传播的行为。 浏览器默认事件处理的方式是按照事件冒泡的方式进行事件处理。 事件流三个阶段： 事件捕获 处理目标 事件冒泡 注册事件监听（绑定事件）： 将事件源、事件类型、事件处理程序关联在一起 在 JS 逻辑中： // 使用事件句柄来绑定事件 element.onxxx = function() { // 语句块，实现事件处理程序任务 } // 调用 addEventListener() 方法来绑定事件 element.addEventListener('事件类型', 事件处理程序, 是否使用事件捕获) 在 HTML 标签中使用事件属性： 按钮 事件对象 event 对象，是事件处理程序(函数)的第一个参数 API 属性： type - 事件类型 target - 最初触发事件的事件源 方法： stopPropagation() - 阻止事件的传播 preventDefault() - 阻止默认行为 事件委派（事件代理、事件委托） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day12-事件、事件对象.html":{"url":"笔记/js笔记/Day12-事件、事件对象.html","title":"Day12 事件、事件对象","keywords":"","body":"事件 事件驱动模型：对于不同的动作行为，应用程序给予不同反馈。 事件 事件类型： click - 点击 mousedown - 鼠标按下 mouseup - 鼠标弹起 mousemove - 鼠标移动 mouseover / mouseenter - 鼠标移入 mouseout / mouseleave - 鼠标移出 keydown - 键盘按下 keyup - 键盘弹起 keypress - 键盘按压 focus - 获得焦点 blur - 失去焦点 ...... 事件监听器 事件处理程序：函数 事件源 事件流 处理事件的流程 事件捕获 从祖先节点到事件源元素节点之间进行事件传播的行为。 事件冒泡 集中式进行事件处理。事件源元素上的事件处理完毕后，会向父级及组先节点进行事件传播的行为。 浏览器默认事件处理的方式是按照事件冒泡的方式进行事件处理。 事件流三个阶段： 事件捕获 处理目标 事件冒泡 注册事件监听（绑定事件）： 将事件源、事件类型、事件处理程序关联在一起 在 JS 逻辑中： // 使用事件句柄来绑定事件 element.onxxx = function() { // 语句块，实现事件处理程序任务 } // 调用 addEventListener() 方法来绑定事件 element.addEventListener('事件类型', 事件处理程序, 是否使用事件捕获) 在 HTML 标签中使用事件属性： 按钮 事件处理程序中的 this: 在事件处理程序（函数）中的 this 可以指向绑定事件的事件源元素，但由于 this 在函数中指向是非常灵活的（根据执行上下文环境决定 this 指向哪个对象），所以在事件处理程序中，要获取事件源元素，更推荐使用 event.target 来获取。 事件对象 event 对象，是事件处理程序(函数)的第一个参数，但是对于 IE9 之前的浏览器，事件处理程序中没有 event 对象的参数，而是需要使用 window.event 获取。 API 属性： type - 事件类型 target - 最初触发事件的事件源 pageX / pageY - 获取光标在文档中的定位坐标 clientX / clientY - 获取光标在当前可视视口中的定位坐标 offsetX / offsetY - 获取光标在事件源(event.target)元素坐标系中的坐标 方法： stopPropagation() - 阻止事件的传播 preventDefault() - 阻止默认行为 事件委派（事件代理、事件委托） 利用事件冒泡的特性，将后代元素上事件的处理委托给组先元素去处理。 在事件委派过程中，可使用 event.target 获取最初触发事件的事件源元素。 事件委派带来的好处是，可以减少事件绑定的次数，可以为动态添加的节点也绑定事件 补充 元素的计算宽高： clientWidth / clientHeight：元素边框以内部分（不包括滚动条）的宽高 offsetWidth / offsetHeight：包括边框及以内的宽高 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day13-事件、正则.html":{"url":"笔记/js笔记/Day13-事件、正则.html","title":"Day13 事件、正则","keywords":"","body":"事件 事件驱动模型：对于不同的动作行为，应用程序给予不同反馈。 事件 事件类型： click - 点击 mousedown - 鼠标按下 mouseup - 鼠标弹起 mousemove - 鼠标移动 mouseover / mouseenter - 鼠标移入 mouseout / mouseleave - 鼠标移出 keydown - 键盘按下 keyup - 键盘弹起 keypress - 键盘按压 focus - 获得焦点 blur - 失去焦点 contextmenu - 右键快捷菜单 scroll - 滚动 load - 内容加载完毕 ...... 事件监听器 事件处理程序：函数 事件源 事件流 处理事件的流程 事件捕获 从祖先节点到事件源元素节点之间进行事件传播的行为。 事件冒泡 集中式进行事件处理。事件源元素上的事件处理完毕后，会向父级及组先节点进行事件传播的行为。 浏览器默认事件处理的方式是按照事件冒泡的方式进行事件处理。 事件流三个阶段： 事件捕获 处理目标 事件冒泡 注册事件监听（绑定事件）： 将事件源、事件类型、事件处理程序关联在一起 在 JS 逻辑中： // 使用事件句柄来绑定事件 element.onxxx = function() { // 语句块，实现事件处理程序任务 } // 调用 addEventListener() 方法来绑定事件 element.addEventListener('事件类型', 事件处理程序, 是否使用事件捕获) 在 HTML 标签中使用事件属性： 按钮 事件处理程序中的 this: 在事件处理程序（函数）中的 this 可以指向绑定事件的事件源元素，但由于 this 在函数中指向是非常灵活的（根据执行上下文环境决定 this 指向哪个对象），所以在事件处理程序中，要获取事件源元素，更推荐使用 event.target 来获取。 事件对象 event 对象，是事件处理程序(函数)的第一个参数，但是对于 IE9 之前的浏览器，事件处理程序中没有 event 对象的参数，而是需要使用 window.event 获取。 API 属性： type - 事件类型 target - 最初触发事件的事件源 pageX / pageY - 获取光标在文档中的定位坐标 clientX / clientY - 获取光标在当前可视视口中的定位坐标 offsetX / offsetY - 获取光标在事件源(event.target)元素坐标系中的坐标 keyCode - 键盘按键的虚拟键盘码 which - 键盘按键编码 / 鼠标按键编码 key - 键盘按键的物理值 方法： stopPropagation() - 阻止事件的传播 preventDefault() - 阻止默认行为 事件委派（事件代理、事件委托） 利用事件冒泡的特性，将后代元素上事件的处理委托给祖先元素去处理。 在事件委派过程中，可使用 event.target 获取最初触发事件的事件源元素。 事件委派带来的好处是，可以减少事件绑定的次数，可以为动态添加的节点也绑定事件 补充 元素的计算宽高： clientWidth / clientHeight：元素边框以内部分（不包括边框与滚动条）的宽高 offsetWidth / offsetHeight：包括边框及以内的宽高 元素的计算定位位置： offsetLeft / offsetTop：计算元素在其有定位的父级中的位置 offsetParent：查找其有定位的父级节点 滚动距离： scrollTop / scrollLeft：垂直 / 水平滚动距离 拖拽 mousedown：鼠标在待拖拽的元素上按下，获取鼠标光标在拖拽的元素坐标系中的坐标位置 mousemove：鼠标在文档中移动时，动态计算出拖拽的元素的定位位置：光标在文档中的坐标与光标在拖拽元素中的坐标求差值 mouseup：鼠标弹起，应该取消鼠标的移动事件 XSS 跨站脚本攻击。 百度百科 正则表达式 作用：用于对文本的格式进行校验 创建对象 const reg = /pattern/attributes const reg = new RegExp(pattern, attributes) pattern：正则表达式的模式 方括号： [a-z]：匹配方括号内的任意一个字符 abc：匹配不在方括号内的字符 元字符 . : 代表除换行和行结束符外的任意字符 \\w ：代表单词字符：字母、数字、下划线 \\d ：代表数字字符 \\s ：代表空白字符，如空格、制表、回车、换行 ...... \\b ：代表单词边界 量词（出现的次数） + ：表示最少出现一次 ? ：表示最多出现一次 * ：表示能够出现任意多次（0到多次） {m} ：表示固定出现 m 次 {m,} ：表示最少出现 m 次 {m,n} ：表示最少m次，最多n次 ^ ：表示开头 $ ：表示结尾 attributes：特性 i ：ignoreCase，表示忽略大小写 g ：global，表示全局匹配 API test(str) - 测试参数字符串是否符合正则的规则 exec() - 查找字符串中满足正则规则的文本，找到了则返回数组，未找到则返回 null。返回的数组中第一个元素是完整的规则匹配结果，如果有第二个或更多元素，则表示各分组的匹配结果 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day14-ES5、ES6.html":{"url":"笔记/js笔记/Day14-ES5、ES6.html","title":"Day14 ES5、ES6","keywords":"","body":"兼容问题 getElementsByClassName() - 根据类名查找元素，在 IE9 之前无法使用 querySelector() / querySelectorAll() - 根据选择器查找元素，在 IE9 之前无法使用 getComputedStyle() - 获取元素的计算后的 css 样式表，在 IE9 之前无法使用 IE9 之前使用 element.currentStyle 属性获取计算后的样式表 event - 事件对象，标准中是在事件处理程序（函数）中的第一个参数 function(event) { event = event || window.event } event.target - 事件源元素 event.target || event.srcElement event.stopPropagation() - 阻止事件传播 function(event) { if (event.stopPropagation) { event.stopPropagation() } else { event.cancelBubble = true } } event.preventDefault() - 阻止事件默认行为 默认行为：点右键弹出浏览器快捷菜单、点链接跳转页面、提交表单全页面刷新到action页面、禁止图像资源拖拽...... function(event) { if (event.preventDefault) { event.preventDefault() } else { event.returnValue = false } } 或 function(event) { return false } addEventListener() - 注册事件监听 if (element.addEventListener) { element.addEventListener(eventType, callback, false) } else { eventType = 'on' + eventType element.attachEvent(eventType, callback) } removeEventListener() - 移除事件监听 function off(element, eventType, callback) { if (element.removeEventListener) { element.removeEventListener(eventType, callback, false) } else { eventType = 'on' + eventType element.detachEvent(eventType, callback) } } document.documentElement：获取文档的根元素节点（html） document.documentElement || document.body ................ ES5、ES6(ES2015及之后) 严格模式 'use strict' 内置对象新增API String.prototype.trim() - 去掉字符串前后空白 function trim(str) { return str.replace(/^\\s+|\\s+$/g, '') } Map（集合） Map 对象保存键值对，并且能够记住键的原始插入顺序。 创建 const map = new Map() API set(key, value) - 保存 key- value 键值对 get(key) - 根据 key 获取 value delete(key) - 根据 key 删除键值对 clear() - 清空 forEach() - 遍历迭代每个 key-value 键值对 Set（集合） Set 对象允许你存储任何类型的唯一值 创建 const set = new Set() API add() - 向集合中添加保存数据 forEach() - 遍历集合每个元素 delete() - 删除集合中的元素 clear() - 清空 如：数组元素去重 const newArray = Array.from(new Set(array)) let / const ES6 中新增定义变量的语法 模板字符串 `使用反引号包含的字符串为模板字符串，可以使用 ${expression} 在字符串中拼接表达式文本内容` for ... of 遍历迭代可迭代对象（如数组或类数组对象） of 之前所定义变量代表的是当前遍历到的元素值 箭头函数 是普通函数的简写形式，没有自己的 this、arguments、super、new.target 等 (param1, param2, …, paramN) => { statements } (param1, param2, …, paramN) => expression //相当于：(param1, param2, …, paramN) =>{ return expression; } // 当只有一个参数时，圆括号是可选的： (singleParam) => { statements } singleParam => { statements } // 没有参数的函数应该写成一对圆括号。 () => { statements } 如： const add = function(a, b) { return a + b } // ==> const add = (a, b) => { return a + b } // ==> const add = (a, b) => a + b 解构赋值 将数组或对象的属性保存到单个变量中 const array = [2, 5, 7, 3, 9] // const a = array[0], b = array[1], c = array.slice(2) const [a, b, ...c] = array ... 运算符 rest - 剩余的 spread - 展开 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day15-DOM高级.html":{"url":"笔记/js笔记/Day15-DOM高级.html","title":"Day15 DOM高级","keywords":"","body":"ES6 补充 函数参数默认值 function add(num1 = 0, num2 = 0) { return num1 + num2 } Promise（了解） 与异步有关 Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。 可以将异步嵌套书写的问题转换为同步链式调用的操作。 三种状态： pending - 等待 fulfilled - 成功 rejected - 失败 生成器函数（了解） function 所定义的函数，*生成器函数在执行时能暂停，后面又能从暂停处继续执行。 class 类（了解） 面向对象使用到的语法糖 async / await（ES7、了解） ?. 运算符、 ?? 运算符 （ES12、了解） babel (了解) 是一个工具，用于进行 ECMAScript 代码转译，可将高版本的 JS 代码转译为低版本支持使用的 JS 代码 https://babeljs.io/ this JavaScript 中的 this 在函数中的指向：this 指向的是其执行上下文环境中的当前对象。 全局的 this 指向的是全局对象，浏览器中的全局对象是 window 如果是直接调用函数(直接以函数名+括号的方式调用)，则非严格模式下，函数体中的 this 指向全局对象，严格模式下为 undefined 在对象中的方法，当对象方法调用时，通常是 谁调用指向谁 构造函数中的 this 通常指向的是通过 new 调用构造函数后创建出来的对象本身 事件处理程序中的 this 通常指向的是绑定事件的事件源元素 箭头函数不会绑定自己的 this（箭头函数没有 this），在箭头函数中使用的 this 与其外层结构中的 this 指向相同 运动 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day16-运动.html":{"url":"笔记/js笔记/Day16-运动.html","title":"Day16 运动","keywords":"","body":"window.requestAnimationFrame（了解） window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。 在 IE10 以前的浏览器中不适用，如果浏览器不支持使用 window.requestAnimationFrame() 则仍然需要使用 window.setTimeout() 来实现动画效果。 报错 Cannot read property 'style' of undefined 不能读取未定义的 style 属性，这儿实际指的是调用 style 属性的那个对象是未定义的 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day17-常见页面效果.html":{"url":"笔记/js笔记/Day17-常见页面效果.html","title":"Day17 常见页面效果","keywords":"","body":"mouseover 与 mouseenter 区别： mouseenter 没有事件冒泡，mouseover 有事件冒泡 即 mouseenter 事件，当在后代元素上移动经过时，不会重复触发执行 mouseenter 事件处理程序，而 mouseover 因为存在事件冒泡，所以当从后代元素上移动经过时，会重复触发 mouseover 事件处理程序。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day18-面向对象编程.html":{"url":"笔记/js笔记/Day18-面向对象编程.html","title":"Day18 面向对象编程","keywords":"","body":"面向对象编程 OOP - 面向对象编程 万物皆对象 三大特性 封装（抽象） 继承：复用 多态：多种状态，复用 对象 属性：静态特征 方法：动作行为 对象就是一系列属性的无序集合 对象属性调用： 对象名.属性名 对象名[属性名索引字符串] 创建对象 对象直接量 const stu = { name: '张三', age: 18, address: '四川成都', study: function() { console.log('学习') } } 相当于： const stu = new Object() stu.name = '张三' stu.study = function() { console.log('学习') } // ...... 工厂方式创建对象 // 定义函数，创建学生对象 function createStudent(name, age, address) { const stu = new Object() stu.name = name stu.age = age stu.address = address stu.study = function() { console.log('学习') } return stu } 通常工厂方式来创建对象，能够实现在函数主体中代码的复用，但对于创建后的各种对象类型的判断不方便 构造函数 function Student(name, age, address) { this.name = name this.age = age this.address = address this.study = function() { console.log('学习') } } 构造函数本质上就是一个函数，将使用 new 调用的函数称为构造函数，其主要用作于创建对象，在创建对象时初始化对象的属性 构造函数中使用 this 来表示当前所创建的对象本身 在命名规范上，构造函数的函数名采用大驼峰（帕斯卡命名规范）来命名：每个单词首字母都大写 构造函数 + 原型 function Student(name) { this.name = name } // const Student = new Function('name', 'this.name = name') Student.prototype.study = function() { console.log(this.name + ' 学习') } const stu1 = new Student('小明') 利用原型来复用方法。 class (ES6) 语法糖，是构造函数 + 原型 的语法糖，JS 中没有真正的类 class Student { // 构造函数 constructor(name, age, sex) { this.name = name this.age = age this.sex = sex } // 成员方法 study() { console.log('学习') } eat() { console.log('吃饭') } } prototype 原型 可利用 prototype 原型来实现在对象中的属性复用： Student.prototype.study = function() { console.log(this.name + ' 学习') } 每个函数都是一个特殊的对象，都拥有 prototype 属性，该属性是一个对象的结构，我们可以在 prototype 对象中添加自定义的属性，以复用自定义的数据。 __proto__ 每个对象都有一个特殊的属性：__proto__，其指向创建对象的构造函数中的 prototype，建立起对象与其原型之间的关联关系 Object.prototype 中的 __proto__ 属性固定为 null 原型链：将对象的 __proto__ 与其 prototype 所串联的结构称作原型链。原型链的终点是 Object.prototype 总结： prototype 通常被称为原型对象，__proto__ 通常也被称为原型属性 每个函数都有 prototype 属性 每个对象（普通对象、函数）都有 __proto__ 属性 通常将 prototype 理解为显式属性，__proto__ 理解为隐式属性，如果是需要在代码中操作原型链的内容，通常修改的是 prototype 属性 对象属性查找 在调用对象属性进行使用时，会进行对象属性查找。 首先在对象自身的内存空间中查找属性，如果在自身内存空间中能够找到，则直接使用后结束查找；如果在自身内存空间中不能找到调用的属性，则到原型中进行查找，如果原型中能找到，则使用后结束查找，如果原型中也找不到，则继续到原型的原型中查找；以此类推。如果查找到最后，都不能找到要调用的属性，则返回 undefined。 this 函数中 this 指向问题（面试）： 通常情况下，谁调用指向谁 如果函数是直接调用（函数名()），非严格模式下指向 window，严格模式下为 undefined 构造函数中的 this 通常指向的是 new 调用函数创建出来的对象本身 事件处理程序中的 this 通常指向的是绑定事件的事件源元素 箭头函数中没有 this（箭头函数不能作为构造函数使用） 改变 this 指向 可以调用相关方法在函数体内部修改 this 指向问题 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() call、apply 作用：用于立即调用函数执行，在执行过程中，将 this 指向修改为第一个参数所表示的对象。如果调用 call、apply 时未传递第一个参数，或传递的是 null 、 undefined时，默认函数中的 this 指向全局(window)对象（在严格模式下为 undefined） 区别：apply 的第二个参数需要是数组或类数组对象，而 call 的第二个参数是一个可变参数 [3, 8, 2, 1, 7, 9, 4, 5] bind 调用 bind() 后会返回一个新的函数，该返回的新函数主体与原函数一致，但函数体中的 this 指向被改为 bind() 方法第一个参数指向的对象 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day20-http、服务端开发.html":{"url":"笔记/js笔记/Day20-http、服务端开发.html","title":"Day20 Http、服务端开发","keywords":"","body":"URL 格式： 协议://域名:端口/资源路径?查询字符串#hash 端口，用于标识联网的应用程序 HTTP http://10.7.189.59:5500/demo1-test.html https://www.baidu.com/ 是因特网上应用最为广泛的一种网络传输协议 HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web 服务器：Apache、IIS、Tomcat、Nginx、........... HTTP 默认端口是 80 HTTPS 默认端口是 443 HTTP 消息结构 HTTP 请求方法 GET 与 POST 的区别 HTTP 状态码 200 - OK，成功 403 - Forbidden，拒绝 404 - Not Found，资源未找到 500 - 服务器内部异常，通常是服务端代码执行出错导致 1xx：消息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx/6xx：服务端错误 NodeJS Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时（V8引擎）建立的一个平台。 npm node package manager（node 包资源管理工具），主要用于安装、卸载、更新、发布（等操作） Node 平台上的各种包资源。 https://www.npmjs.com/：所有发布到 node 平台的包都可以在该网站查询到 安装包 $ npm install --save-dev -g install 可以简写为 i 是需要安装的包的名称 --save 是保存安装包资源到项目依赖环境中，可省略，当省略时，默认为 --save --save-dev 是保存安装包资源到项目的开发依赖环境中 -g 是全局安装 安装包资源时，会在项目目录下建立 node_modules 目录来保存所安装的资源数据 package.json 这是项目的配置文件，与项目相关的配置信息是保存在该文件中 创建 package.json $ npm init -y npm scripts npm 脚本，主要是一些复杂的 node 任务要执行时，输入命令比较繁琐，可以使用 npm scripts 来定义脚本，然后利用 npm run 执行这些脚本 创建 webserver 利用 Express 来实现 webserver 创建： 创建项目目录 server 在项目根目录下创建 package.json 文件 $ npm init -y 安装 express： $ npm install express 安装后在项目目录下生成 node_modules 目录 在项目根目录下创建 app.js 文件： // 引入 express const express = require('express') // 创建 Express 应用实例 const app = express() // 托管静态资源 app.use(express.static('public')) // 监听端口，等待客户端浏览器连接 app.listen(9527, () => console.log('Server running at http://localhost:9527')) 创建 public 目录，在 public 目录下的资源是浏览器中能够直接访问到的静态资源，如html、css、js、Image、videos....... 运动webserver $ node app.js MySQL 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 数据库产品：MySQL、SQL Server、Oracle、DB2、SQLite....... 概念： 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。由行与列组成 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 列: 是每条记录的特征信息，一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。作用：唯一标识记录 使用 安装 创建数据库 在数据库中创建表 表中实现CRUD(SQL) 插入数据 -- INSERT INTO 表名 (列名1, 列名2) VALUES (列值1, 列值2) INSERT INTO `students` (`name`, `sex`) VALUES ('李四', '男') 修改数据 -- UPDATE 表名 SET 列名1=列值1, 列名2=列值2 WHERE 条件 UPDATE `students` SET `sex`='男', `birthday`='2000-02-02', `phone`='13455667788' WHERE (`id`='1') 注意，不添加 WHERE 子句，是会将整张表的数据更新成相同的值，这种修改是不可撤销的 删除数据 -- DELETE FROM 表名 WHERE 条件 DELETE FROM `students` WHERE (`id`='2') 不使用 WHERE 子句时，会删除整张表的数据，这种删除是不可撤销的 查询数据 -- SELECT 列名1, 列名2, ... -- FROM 表名 -- WHERE 条件 -- ORDER BY 排序的列名 ASC|DESC -- LIMIT 起始索引, 限定查询的条数 SELECT * FROM `students` LIMIT 0, 1000 NodeJS 中连接MySQL数据库 安装驱动 $ npm i mysql 连接数据库 // 连接数据库 const mysql = require('mysql') const connection = mysql.createConnection({ host : 'localhost', // 数据库服务器主机 user : 'root', // 连接数据库的用户名 password : '123456', // 密码 database : 'h52107' // 数据库名 }) // 连接 connection.connect() /* 到数据库中验证用户名与密码 */ // 创建 SQL 语句 const sql = 'SELECT COUNT(*) AS total FROM users WHERE username=? AND password=?' const params = ['abc', 'test'] // 查询 connection.query(sql, params, (err, result) => { if (err) { response.send('有异常') return } console.log('result:', result) // 返回响应 if (result[0].total === 1) { response.send('用户登录成功') } else { response.send('用户名或密码错误') } }) 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day21-连接数据库、AJAX.html":{"url":"笔记/js笔记/Day21-连接数据库、AJAX.html","title":"Day21 连接数据库、AJAX","keywords":"","body":"nodemon 这是一个监测文件变化后自动重启 Node 应用的工具 安装 $ npm i -g nodemon 安装成功后，可以在命令行中使用 nodemon 命令代替 node 命令执行应用 AJAX 阿贾克斯 Asynchronous JavaScript And XML，异步 JavaScript 和 XML 技术 Asynchronous - 异步 JavaScript - JS XMLHttpRequest(xhr) XML - 可扩展标记语言，主要用于传递数据，JSON 可用于： 不刷新页面更新网页 在页面加载后从服务器请求数据 在页面加载后从服务器接收数据 在后台向服务器发送数据 主要特点：在不全页面刷新的情况下实现页面局部更新，通常将这种技术称为无刷新技术 缺点：不利于 SEO 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day22-AJAX.html":{"url":"笔记/js笔记/Day22-AJAX.html","title":"Day22 AJAX","keywords":"","body":"Review AJAX 异步 JavaScript 和 XML 技术 实现无刷新操作（局部更新） 核心： XMLHttpRequest 使用： 创建核心对象实例（准备手机） 准备建立连接-请求方法、资源地址、是否异步（准备电话号码） 发送请求（拨号） 处理响应（等待对方接听或是挂断电话） 示例： // 1. 创建核心对象实例 const xhr = new XMLHttpRequest() // 2. 准备建立连接 // xhr.open(method, url, async) xhr.open('POST', '/register.do', true) // 3. 发送请求 xhr.send() // 4. 处理响应 xhr.onreadystatechange = () => { // readyState 表示请求到达哪个阶段，可取 0、1、2、3、4 if (xhr.readyState === 4) { // 请求处理完毕，响应就绪 // status 表示 HTTP 状态码 if (xhr.status === 200) { // OK // responseText 获取响应文本数据 const data = xhr.responseText console.log('获取到数据：', data) } } } 如果需要像表单一样 POST 提交数据，则需要在 send() 方法调用之前，调用 setRequestHeader() 设置请求头信息： xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") 将需要传递给服务器的数据（拼接成查询字符串参数）以字符串参数形式传递到 send() 方法中. 网络API接口 showapi 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day23-AJAX、promise、Cookie.html":{"url":"笔记/js笔记/Day23-AJAX、promise、Cookie.html","title":"Day23 AJAX、Promise、Cookie","keywords":"","body":"Review ajax 使用步骤： // 创建核心对象实例 const xhr = new XMLHttpRequest() // 处理响应 xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status === 200) { const data = xhr.responseText } } } // 准备建立连接 xhr.open(method, url, async) // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') // 发送请求 xhr.send(params) 跨域 同源策略（同域限制） 同源策略是浏览器中的一种安全策略（负责管理浏览器中数据访问的安全问题），默认情况下，在浏览器中，非同源的资源之间不允许相互访问。 URL 格式： 协议://域名:端口/资源路径?查询字符串#hash 同源：协议、域名、端口完全一致 只要三者中有任意一个不同，则就是非同源的资源，非同源资源间的访问叫做跨域。 如： http://localhost:3000/index.html http://localhost:3000/html/login.html http://localhost:3000/assets/images/5.png https://localhost:3000/html/register.html http://127.0.0.1:3000/style/style.css http://127.0.0.1:9527/index 跨域访问时，会报告类似如下的错误信息： Access to XMLHttpRequest at 'http://localhost:3000/exist' from origin 'http://127.0.0.1:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 解决跨域的方案： CORS 跨域资源共享。允许浏览器跨域发送 ajax 请求，克服 ajax 只能在同源中访问的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，所以通常 CORS 现在是在服务端设置即可。浏览器端仍然使用 ajax 请求资源。 CORS 跨域，设置响应头信息： Access-Control-Allow-Origin: * Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS Access-Control-Allow-Headers: * JSONP JavaScript Object Notation Padding 原理： 在浏览器端，利用 引入外部资源时，不受同源策略限制的特点，来实现跨域资源访问。 实现： 服务端：在向浏览器端返回数据时，返回数据的格式是一个 JS 中函数调用结构的数据 浏览器端： 动态创建 script 元素 设置 script 元素的 src 属性，在URL中传递用于处理响应数据的函数名称给服务端 将创建的 script 元素添加到 DOM 树结构中 创建全局的用于处理响应数据的函数 将添加到 DOM 树结构中的 script 元素节点删除 注意：JSONP 处理的是 GET 请求方法的跨域 百度提示：https://www.baidu.com/sugrec?prod=pc&wd=搜索的关键字&cb=回调函数名称 Promise 在异步调用执行过程中，可能会出现回调地狱问题，可利用 Promise 来解决相关回调地狱问题。 利用 Promise，可以将异步嵌套调用的书写方式转换为同步链式调用的书写方式，有利于进行代码阅读与维护。 三种状态： pending：等待状态 fulfilled：成功 rejected：失败 使用 创建对象 const executor = function(resolve, reject) { // 通常在该函数中，定义异步操作任务 // resolve 函数：将 Promise 状态修改为 fulfilled 成功状态 // reject 函数：将 Promise 状态修改为 rejected 失败状态 } const promise = new Promise(executor) // 在创建 Promise 对象的同时，executor 函数会被同步调用 示例： const promise = new Promise(function(resolve, reject) { setTimeout(function() { const rand = Math.random() console.log('定时任务', rand) if (rand >= 0.5) { // 成功 resolve() } else { // 失败 reject() } }, 10000) }) API Promise.prototype.then(onFulfilled[, onRejected]) 作用：是Promise对象的前置任务执行结束后，接下来要执行的任务，onFulfilled 是Promise 状态为 fulfilled 时执行的回调函数，onRejected 是 Promise 状态为 rejected 时执行的回调函数 Promise.prototype.catch() 作用：捕获错误（rejected状态） 本地存储 Cookie WebStorage localStorage sessionStorage IndexedDB Cookie 特点： 存储的是文本数据 存储容量大小限制：4KB 会占用网络上传带宽（即访问服务端资源时默认会将 cookie 携带在请求头中传递到服务端） 受同域限制 有时效性 使用 保存、修改、删除： document.cookie = 'key=value; expires=失效时间; path=保存路径; domain=域; secure' key: cookie 名称 value: cookie 值 expires: 过期时间，可选，不设置时默认是会话失效。会话指的是从访问某网站开始，到关闭浏览器结束 path: 保存的路径，可选，默认为访问文件的路径，一般会将 path 设置为 / domain: 域 secure: 是否安全链接 查询： document.cookie 返回所在域下所有的 cookie 拼接的字符串，所有 cookie 以 key=value 形式使用 ;(分号+空格) 拼接 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day24-本地存储、案例.html":{"url":"笔记/js笔记/Day24-本地存储、案例.html","title":"Day24 本地存储、案例","keywords":"","body":"Review 跨域 CORS -- XMLHttpRequest Level2 JSONP Promise 三种状态： 创建对象 API Cookie document.cookie = 'key=value; expires=失效时间; path=路径; domain=域; secure' document.cookie 编码、解码 encodeURIComponent('美女') decodeURIComponent('%E7%BE%8E%E5%A5%B3') Cookie 封装 WebStorage localStorage sessionStorage 特征： 是 H5 中新增的存储结构 存储的是文本数据 是真正的本地存储（不会占用网络上传带宽） 存储容量为 5MB localStorage 是本地永久存储、sessionStorage 是本地会话存储 受同域限制 有完善的 API API setItem(name, value): 保存 getItem(name): 查询 removeItem(name): 删除 clear(): 清空 Bootstrap bootstrap 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day25-设计模式、继承.html":{"url":"笔记/js笔记/Day25-设计模式、继承.html","title":"Day25 设计模式、继承","keywords":"","body":"Review http ajax 跨域 本地存储 Promise 设计模式 文档 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 单例模式（Singleton Pattern） 提供了一种创建对象的最佳方式。 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 JS 中的实现： // 最简单的单例：对象直接量 const obj = { method: function() { console.log('方法') } } // IIFE // 饿汉式单例 const Player = function() { function Player(list = []) { this.list = list } Player.prototype.setList = function(list) { console.log('设置播放列表') this.list = list } Player.prototype.play = function() { console.log('播放：', this.list) } Player.prototype.start = function() { console.log('开始...') this.play() } return new Player() }() // 懒汉式单例 const Player = (function() { class Player { constructor(list) { this.list = list } setList(list) { this.list = list } play() { console.log('播放...') } start() { console.log('开始') this.play() } } let _instance = null return { getInstance() { if (_instance === null) { _instance = new Player() } return _instance } } })() 工厂模式（Factory Pattern） 主要用于创建对象，在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 MVC Model View Constroller 创建对象 直接量 / new Object() 工厂方式：利用函数的封装实现创建对象代码的复用 构造函数 构造函数 + 原型 class 原型（prototype） prototype：原型对象，每个函数都有 prototype 属性 __proto__：原型属性，每个对象都有 __proto__ 属性，该属性指向创建对象的构造函数下的 prototype 由 __proto__ 与其对应的 prototype 所串联的结构被称为“原型链” 对象属性查找时，会通过原型链进行查找。 call、apply、bind call()、apply() 作用：立即调用函数执行，在函数执行过程中，将 this 指向修改为第一个参数表示的对象，没有第一个参数，或传递的是 null、undefined时，表示的是修改为 window 对象。 bind() 作用：返回新函数，当新函数被调用执行时，函数体内部的 this 被修改为 第一个参数 表示的对象 继承 实现代码复用，方便维护 构造函数 function Person(name, age, sex) { this.name = name this.age = age this.sex = sex } function Student(name, age, sex, courses) { Person.call(this, name, age, sex) this.courses = courses } 原型链继承 Student.prototype = new Person() // 更推荐下边的写法 Student.prototype = Object.create(Person.prototype) 组合继承 构造函数继承 + 原型链继承 class 继承 class Student extends Person { constructor(name, age, sex, courses) { // 调用父类的构造函数 super(name, age, sex) // 子类特征 this.courses = courses } study() { console.log('学习') } sleep() { this.study() super.sleep() } } 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day26-闭包.html":{"url":"笔记/js笔记/Day26-闭包.html","title":"Day26 闭包","keywords":"","body":"Review 设计模式：单例、工厂、装饰者 继承：构造函数继承、原型链继承、组合继承、class（ES6） call、apply、bind this prototype 作用域（scope） 全局作用域 函数作用域 块级作用域 作用域链 在函数嵌套结构中，内层函数可以查找使用到外层函数中的局部变量（外层函数是不能使用到内嵌函数中的局部变量）。 在函数体内部进行变量查找时，如果自身作用域下能够查找到，则直接使用，如果自身作用域下不存在，则到父级作用域中查找，父级存在则使用，不存在则到父级的父级作用域下查找（作用域链），以此类推，直接找到变量使用，如果一直到全局范围都不能查找到变量，则报错：Uncaught ReferenceError: xxx is not defined 闭包（closure） 闭包：函数嵌套函数的结构，在内部函数中有使用到外部函数中的局部变量实现其功能，在外部函数中返回了对内嵌函数的引用。 作用：在函数体外部能够引用到函数体内部的局部变量，延长函数体内部变量的生命周期 Object Object.assign()：对象复制 Object.create()：创建对象 Object.defineProperty()：定义属性 jQuery 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day27-jQuery.html":{"url":"笔记/js笔记/Day27-jQuery.html","title":"Day27 JQuery","keywords":"","body":"常见 JS 库： jQuery prototype.js yui dojo ......... jQuery 官网 在线中文文档 特点 小巧、快速、富应用 API 丰富易用、文档详细 对常用的 DOM 操作、事件处理、ajax、运动等进行了封装 解决了浏览器兼容问题 支持 CSS 选择器及jQuery自身的选择器的使用 有丰富的插件 支持链式调用 ...... 版本 1.x 2.x 3.x 使用 下载 引入 API 核心 jQuery(selector) / $(selector)：在全局范围内，$ 与 jQuery 是等价的，根据选择器查询元素，返回 jQuery 对象实例（是一个类数组对象），在 jQuery 对象实例中包装了查找到的 DOM 元素 $(dom)：将 DOM 对象包装成 jQuery 对象实例 $(htmlString)：创建 DOM 对象后包装成 jQuery 对象实例 $(callback)：是 $(document).ready(callback) 的简写 选择器 主要用于使用 jQuery 查找元素 DOM 操作 文档处理 DOM 节点的添加、修改、删除、克隆 筛选 DOM 节点的查找与过滤 属性 DOM 元素节点的属性操作 CSS css 样式处理 事件处理 事件 on(type, selector, callback)：注册事件监听 off()：移除事件监听 hover(onmouseenter, onmouseleave)：事件合成的方法，合成了 mouseenter、mouseleave 两个事件 事件对象 event 效果 包括常见的运动效果 animate()：自定义运动效果 fadeIn() fadeOut() show() hide() ajax ajax 网络请求 $.ajax() $.ajax({ url: '', // 请求资源的地址 method: 'GET', // 请求方法，默认为 'GET'，也可以使用 type 属性表示请求方法 data: {username: 'abc', password: '123'}, // 向服务端传递的数据 dataType: 'json', // 预期从服务端返回数据的格式 success: function(resData) { // 请求成功时执行的回调函数 // resData 为服务端响应返回的数据 }, error: function(err) { // 请求失败时执行的回调函数 } }) $.get() $.getJSON() $.post() load() 延迟对象 类似于 Promise 工具 git gulp sass require.js art-template ......... 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day28-Git.html":{"url":"笔记/js笔记/Day28-Git.html","title":"Day28 Git","keywords":"","body":" SVN 与 Git Git 菜鸟教程 Git 是一个开源的分布式版本控制系统，不必服务器端软件支持。 概念 工作区 项目目录 版本库 是在工作区中的一个隐藏的 .git 目录，在该目录中保存了和版本相关的数据 暂存区 暂时保存版本信息的区域，是在 .git 目录中的 index 文件 安装 下载-v2.33.0gitgit 全局配置 $ git config --global user.name 用户名称 $ git config --global user.email 用户邮箱 使用 在工作空间中打开 git bash 窗口，初始化创建空的版本库： $ git init 执行结束后，会在工作空间中创建出 .git 的隐藏目录 在工作空间中实现编码，在完成一个功能之后，可本地提交版本库 使用 git status 查看版本库状态： ```bash $ git status ``` 如果git中中文文件名全部显示为数字，修改配置： ```bash git config --global core.quotepath false ``` 使用 git add 添加暂存区： ```bash $ git add filename.... ``` # 如： ```bash $ git add src/index.html $ git add src/css/common.css src/css/index.css $ git add . 将所有文件添加到暂存区（不包括已删除） $ git add -A 将所有文件添加到暂存区(包括修改和已删除） ``` 使用 git checkout 撤销修改 ```bash $git checkout -- filename（如果不加--就变成切换分支命令了） 将filename文件回到最近一次commit或add的状态 ``` 使用 git rm 移除文件 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可： ```bash git rm --cached git rm -r --cached . 删除缓存区所有文件 ``` 提交本地版本库： ```bash $ git commit -m 'flag: message' ``` 在提交版本库填写信息前，通常添加前缀标记： chore: 表示搭建项目架构 feat: 新特性，新功能 fix: 修复 bug doc: 编写文档 test: 测试 refactor: 项目的重构 git commit --amend可以修改commit注释 可以在工作空间中创建 .gitignore 文件，该文件中定义的是版本管理时忽略的资源： ```bash $ touch .gitignore # 创建 .gitignore 文件 $ vi .gitignore # 编辑 .gitignore 文件 ``` 说明：在 vi 编辑器界面中，按 I 键接收输入，如果输入完毕后保存并退出，可以先按 Esc ，然后输入 :wq 回车后保存退出。 可以使用 git log 查看版本库的提交日志信息： ```bash $ git log ``` git reflog （-n可以设置显示的条数）：此命令可以查看所有分支的所有操作记录，包括已删除的commit记录，而git log只能查看每次commit的记录 从图中可以看到，执行git reflog 命令后，显示出来了很多行记录。 每行记录都由版本号（commit id SHA），HEAD值和操作描述三部分组成。版本号在第一列，HEAD值在第二列，操作描述信息在第三列。 版本号：标识着每一次提交、合并等操作时的版本，相当于唯一标识 HEAD值：同样用来标识版本，但是不同于版本号的是，Head值是相对的。 当HEAD值为HEAD时，表示为提交的最新版本；HEAD^ 表示为最新版本的上一个版本；HEAD^^表示为最新版本的上上个版本；HEAD~100表示为最新版本的往上第100个版本。 HEAD值越小，表示版本越新，越大表示版本生成时间越久。 git reset 命令用于回退版本，可以指定退回某一次提交的版本 --mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上上个版本，一次类推，也可以用HEAD~0,HEAD~1表示 --hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交 使用 git reset HEAD 可以取消之前 git add 添加 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 git reset HEAD XXX.py 就是对某个py文件进行撤销了 git reset HEAD file 即使对file文件夹进行撤销 --soft 参数用于回退到某个版本，不删除工作空间改动代码，撤销commit，不撤销git add： git 标签 切换到需要打标签的分支上，输入命令： $ git tag 默认标签是打在最新提交的commit上的，也可以通过git tag commitid给指定的commit打标签 $git tag -d 删除标签 $git push origin 将指定标签推送到远程 $git push origin --tags将所有未推送的标签推送到远程 删除已推送到远程的标签： 首先将本地标签删除 $ git tag -d ,Deleted tag \" 然后从远程删除 $ git push origin :refs/tags/ To [deleted] $ git pull : 比如，要取回origin主机的next分支，与本地的master分支合并，需要写成下面这样 - $ git pull origin next:master 如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为： $ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。 git忽略文件 在根目录下创建文件.gitignore,在文件中写忽略规则 在 .gitignore 文件中，每一行的忽略规则的语法如下： 空格不匹配任意文件，可作为分隔符，可用反斜杠转义。 开头的文件标识注释，可以使用反斜杠进行转义。 !开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含，可以使用反斜杠进行转义。 / 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件。 / 开始的模式匹配项目跟目录。 如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。 ** 匹配多级目录，可在开始，中间，结束。 ? 通用匹配单个字符。 [] 通用匹配单个字符列表。 如果想强制将忽略文件添加到库中，可用git add -f file 分支管理 创建分支 $ git branch # 如： $ git branch dev 查看分支 $ git branch 切换分支 $ git checkout # 如： $ git checkout dev 创建并切换分支 $ git checkout -b 删除分支 $ git branch -d 合并分支 $ git merge # 将指定分支内容合并到当前分支 创建分支后在分支上的所有操作都与原分支无关 远程中央仓库 可以将本地使用 git 管理的仓库提交到一台远程服务器上保存，可与其他用户共享仓库资源 github.com gitee.com coding.net gitlab - 一般公司自己搭建 git 服务器时使用 注册并登录账号 以 gitee.com 为例 ssh key 配置 在 git bash 中生成本地的 ssh 公私钥密钥对： $ ssh-keygen 生成成功后，在用户目录下会生成 .ssh 的目录，该目录中有两个文件：id_rsa（私钥）、id_rsa.pub（公钥）。可以将 id_rsa.pub 文件中最最后的邮箱地址修改为自己的邮箱 复制 id_rsa.pub 公钥文件中的所有内容 进入 gitee.com 中的个人账户：个人头像 --> 设置 --> 侧边导航菜单中 “ssh 公钥” --> 粘贴已复制的id_rsa.pub文件内容 --> 确定 --> 验证密码 --> 添加成功 可使用如下命令，测试是否能够连接成功： $ ssh -T git@gitee.com 看到类似如下提示，说明已配置成功： Hi 小明! You've successfully authenticated, but GITEE.COM does not provide shell access. 创建远程中央仓库 在 gitee.com 个人账户中，先创建空白的版本仓库 将本地仓库与远程中央仓库关联 $ git remote add # 如 $ git remote add origin git@gitee.com:mobiletrain/h5-2107-js.git 对同一个名称的添加只能执行一次，如果再次执行，会报错，如： fatal: remote origin already exists. 如果有报错，可执行 git remote remove 来删除名称对应的关联： $ git remote remove # 如 $ git remote remove origin 查看关联的远程仓库 $ git remote show, 后面加上主机名可以查看详细信息 ] do not query remotes \"> 远程仓库重命名 $ git remote rename 将本地版本库推送到远程 $ git push # 如： $ git push origin master 远程分支版本回退 先回退本地分支 $ git reflog $ git reset --hard commitid 然后强制推送到远程 $ git push -f 用远程库覆盖本地文件 git fetch --all git reset --hard origin/master 流程 进入公司后，分配工位、电脑等 进入操作系统中安装开发环境：NodeJS、Git、VSCode(或其它的开发工具) 配置基本的环境内容，如：npm 包资源镜像、git 全局配置、ssh-key 配置、vscode 中扩展程序安装........ 开发时使用 Git 的流程： 本地没有项目源代码时，下载远程中央仓库中的代码 $ git clone 如果本地存在项目的源代码，可更新为远程中央仓库中的最新版本的代码： $ git pull origin master 进入工作空间中，完成任务编码 在完成一个功能并通过测试后，提交本地版本库： $ git status # 查看版本库状态 $ git add # 添加到暂存区 $ git commit -m 'flag: message' # 提交本地版本库 将本地版本库推送到远程中央仓库 $ git push origin master Gulp 自动化构建工具 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:09:15 "},"笔记/js笔记/Day29-gulp_.html":{"url":"笔记/js笔记/Day29-gulp_.html","title":"Day29 Gulp ","keywords":"","body":"Gulp 中文网 自动化构建工具：压缩js、压缩css、处理图像、编译sass/less资源，形成完整的构建流程等 gulp 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。 全局安装 gulp-cli 全局安装 gulp-cli 命令行工具： $ npm i gulp-cli -g 安装完成后，使用 gulp --verion 测试： $ gulp --version 如果能够看到类似如下提示，则说明安装成功： CLI version: 2.3.0 Local version: Unknown 注意：全局安装 gulp-cli 只需要执行一次即可 创建项目与 package.json 文件 $ mkdir gulp-demo $ cd gulp-demo $ npm init -y 本地安装 gulp 本地安装 gulp 包资源： $ npm i gulp --save-dev # 或 $ npm i gulp -D 本地安装gulp完毕后，可执行 gulp --version 查看版本： $ gulp --verion CLI version: 2.3.0 Local version: 4.0.2 创建 gulpfile.js 文件 在项目根目录（与 package.json 文件同目录）中创建 gulpfile.js 文件，该文件是 gulp 工具的配置文件，用于定义各种自动化构建任务： function defaultTask(cb) { // place code for your default task here console.log('执行默认任务...') cb(); } exports.default = defaultTask exports.default 是导出默认任务 测试默认任务 在命令行中，项目根目录下，执行 gulp 命令： $ gulp 类似看到如下执行结果： [11:16:22] Using gulpfile D:\\courses\\cd-2107\\JavaScript\\week-06\\day05-gulp\\gulp-demo\\gulpfile.js [11:16:22] Starting 'default'... 执行默认任务... [11:16:22] Finished 'default' after 8.23 ms 可以使用 gulp 来执行其它任务，如： $ gulp uglifyjs 任务名称是在 gulpfile.js 文件中 exports.xxx 时定义的名称 定义 gulp 任务 gulp 任务的执行通常是结合相关插件来完成 压缩 js 任务 安装 gulp-uglify 插件： $ npm install --save-dev gulp-uglify # 或 $ npm i gulp-uglify -D 定义 gulpfile.js 文件中的任务： // 引入包资源 const gulp = require('gulp') const uglify = require('gulp-uglify') // 定义变量，保存各种资源的路径 const paths = { js: { src: 'src/js/**/*.js', // js 文件的源路径 dest: 'dist/js' // js 处理后的目标路径 } } // 定义任务函数 function scripts() { return gulp.src(paths.js.src) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) } // 导出任务 exports.scripts = scripts 执行任务： $ gulp scripts 压缩 css 任务 插件：gulp-clean-css $ npm install gulp-clean-css --save-dev 压缩 html 任务 插件：gulp-htmlmin $ npm install --save-dev gulp-htmlmin 转译 js 插件：gulp-babel $ npm install --save-dev gulp-babel@7 babel-core babel-preset-env sass 编译 插件：gulp-sass $ npm install sass gulp-sass --save-dev 流程化 const build = gulp.series(clean, gulp.parallel(styles, scripts, buildScss, html, copyLibs, watch)) 示例代码 //引入资源 const gulp = require('gulp') const htmlmin = require('gulp-htmlmin') const cleanCSS = require('gulp-clean-css') const babel = require('gulp-babel') const uglify = require('gulp-uglify') const sass = require('gulp-sass')(require('sass')) const del = require('del') const connect = require('gulp-connect') const path = require('path') // const { resolve } = require('path') // const { rejects } = require('assert') //设置资源路径 const paths = { html: { src: 'src/**/*.html', dest: 'dist' }, css: { src: 'src/css/**/*.css', dest: 'dist/css' }, js: { src: 'src/js/**/*.js', dest: 'dist/js' }, scss: { src: 'src/scss/**/*.scss', dest: 'dist/css' }, libs: { src: 'src/libs/**/*.*', dest: 'dist/libs' }, imgs: { src: 'src/images/**/*.*', dest: 'dist/images' } } //定义处理html文件的函数 function html() { return gulp.src(paths.html.src) //collapseWhitespace是否处理空白html字符，minifyCSS,minifyJS:是否处理HTML中的CSS、JS代码 .pipe(htmlmin({ collapseWhitespace: true, minifyCSS: true, minifyJS: true })) .pipe(gulp.dest(paths.html.dest)) .pipe(connect.reload()) } function cleanHtml() { return del([paths.html.dest+'/**/*.html'])//'**'指文件夹，'*.*'指文件 } // 处理css文件 function styles(){ return gulp.src(paths.css.src) .pipe(cleanCSS()) .pipe(gulp.dest(paths.css.dest)) .pipe(connect.reload()) } //预编译scss文件 function buildScss() { return gulp.src(paths.scss.src) .pipe(sass({outputStyle: 'compressed'}))//选择编译风格：nested、expanded、compact、compressed .pipe(gulp.dest(paths.scss.dest)) .pipe(connect.reload()) } function cleanCss() { return del([paths.css.dest+'/*']) } //转译压缩js function scripts(){ return gulp.src(paths.js.src) .pipe(babel({ presets: ['env'] })) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) .pipe(connect.reload()) } function cleanScripts() { return del([paths.js.dest+'/*.js']) } //复制无需特殊处理的资源 function copyLibs() { return gulp.src(paths.libs.src) .pipe(gulp.dest(paths.libs.dest)) .pipe(connect.reload()) } function cleanLibs() { return del([paths.libs.dest+'/**/*.*']) } function copyImgs() { return gulp.src(paths.imgs.src) .pipe(gulp.dest(paths.imgs.dest)) .pipe(connect.reload()) } function cleanImgs() { return del([paths.imgs.dest+'/**/*.*']) } //清理dist目录 function clean (){ return del(['dist']) } //定义监视任务,当检测到第一个参数的文件发生变化就执行第二个参数的方法 async function watch() { gulp.watch(paths.html.src, gulp.series(cleanHtml, html)).on('error', function (error) { console.log(error); this.emit('end');//错误处理，emit表示任务结束避免任务卡死 }) gulp.watch([paths.css.src, paths.scss.src], gulp.series(cleanCss, styles, buildScss)).on('error', function (error) { console.log(error); this.emit('end'); }) gulp.watch(paths.js.src, gulp.series(cleanScripts, scripts)).on('error', function (error) { console.log(error); this.emit('end'); }) gulp.watch(paths.libs.src, gulp.series(cleanLibs, copyLibs)).on('error', function (error) { console.log(error); this.emit('end'); }) gulp.watch(paths.imgs.src, gulp.series(cleanImgs, copyImgs)).on('error', function (error) { console.log(error); this.emit('end'); }) } //启动webserver服务器,如果不加async会提示任务未完成 async function server() { connect.server({ root: 'dist',//设置服务器根目录 port: 8888, //设置端口 livereload: true //server启动时运行livereload }) } //在任务后面添加.pipe(connect.reload()),当任务执行时就会触发浏览器刷新 //形成处理流程 //gulp.series函数中的任务将按顺序依次执行 //gulp.parallel函数中的任务将同时执行 const build = gulp.series(clean, gulp.parallel(html, styles, scripts, buildScss, copyLibs, copyImgs, watch, server)) //导出任务 // exports.html = html // exports.cleanCss = styles // exports.scripts = scripts // exports.buildScss = buildScss // exports.clean = clean // exports.copyLibs = copyLibs // exports.copyImgs = copyImgs // exports.build = build // exports.watch = watch // exports.copyimg = copyimg //默认任务 exports.default = build 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day30-模板引擎、模块化.html":{"url":"笔记/js笔记/Day30-模板引擎、模块化.html","title":"Day30 模板引擎、模块化","keywords":"","body":"模板引擎 为了使用户界面与业务数据（内容）分离而产生的模板，可以方便快速实现页面渲染。 前端模板引擎： art-template handlebars ejs ....... art-template 高性能 JavaScript 模板引擎 下载 下载：template-web.js（gzip: 6kb） 模板语法 标准语法(简洁语法)： 使用 { { }} 语法将业务逻辑处理部分包裹起来，html 布局部分原样书写 原始语法： 使用 语法将业务逻辑处理部分包裹 原始语法支持所有 JS 功能 定义模板 { {each cart prod}} { {prod.id}} { {prod.title}} { {prod.price}} { {prod.amount}} { {(prod.price * prod.amount).toFixed(2)}} 删除 { {/each}} 定义模板时，将 的 type 修改为 text/html，必须设置 id 属性 渲染模板 const html = template(id, data) 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/js笔记/Day31-require.js模块化.html":{"url":"笔记/js笔记/Day31-require.js模块化.html","title":"Day31 Require.Js模块化","keywords":"","body":"模块化 将完整应用分解为一个一个功能独立的小模块，模块与模块之间可能存在依赖关系，将各功能独立的模块通过业务组合成完整的应用。 模块化规范： AMD - require.js CMD - sea.js CommonJS - （包含了非常多的规范内容，模块化仅是其中很小的一部分）NodeJS ES6 Modules - import / export require.js require.js JS模块化工具requirejs教程(一)：初识requirejs JS模块化工具requirejs教程(二)：基本知识 RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments, like Rhino and Node. Using a modular script loader like RequireJS will improve the speed and quality of your code. 三个变量 require requirejs define require 与 requrejs 是等价的，主要用于引入依赖模块实现功能 define 主要用于定义模块 require // 语法 require(array, callback) 参数 array 表示引入的依赖模块数组，数组元素值为依赖模块的模块名称字符串 参数 callback 是依赖于引入模块后所需要完成的业务处理函数 define // 语法 define(name, array, callback) name 为可选的参数，表示模块名称 array 为可选的参数，依赖项数组，即定义当前模块时所需要依赖的其它模块 callback 为定义当前模块时所需要完成的业务代码 下载 require.js 文件 当页面引入 require.js 库后，在全局范围内就能调用到 define 函数，并且 define 函数中存在一个 amd 属性 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/Day32-项目案例（一）.html":{"url":"笔记/js笔记/Day32-项目案例（一）.html","title":"Day32 项目案例（一）","keywords":"","body":"项目案例 技术栈及工具：HTML + CSS + JavaScript + jQuery + art-template + require.js + git + sass + gulp + ...... 电商类项目 实现的页面： 首页 分类（列表）页 详情 购物车 确认订单 用户注册 用户登录 ...... 步骤： 创建空白的 git 远程中央仓库（gitee.com） 将远程中央仓库克隆到本地 $ git clone 在工作空间中创建项目的结构 project |--src # 放置项目源代码 |--|--scss |--|--js |--|--images |--|--libs |--|--html |--|--index.html |--gulpfile.js # gulp 任务配置文件 |--package.json # 项目配置文件 |--.gitignore # git 忽略资源 |--README.md # 项目描述文件 利用 npm init -y 生成 package.json 文件，在文件中添加 devDependencies 字段： { \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-preset-env\": \"^1.7.0\", \"del\": \"^6.0.0\", \"gulp\": \"^4.0.2\", \"gulp-babel\": \"^7.0.1\", \"gulp-clean-css\": \"^4.3.0\", \"gulp-connect\": \"^5.7.0\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-sass\": \"^5.0.0\", \"gulp-uglify\": \"^3.0.2\", \"sass\": \"^1.39.2\" } } 使用 npm i 安装在 package.json 中配置的开发依赖包： $ npm i # 在安装前，可修改 npm 安装的镜像源（只改一次，以后可不用再修改）： # npm config set registry https://registry.npm.taobao.org 复制 gulpfile.js 文件到项目根目录中： // 引入包资源 const gulp = require('gulp') const uglify = require('gulp-uglify') const babel = require('gulp-babel') const cleanCSS = require('gulp-clean-css') const sass = require('gulp-sass')(require('sass')) const htmlmin = require('gulp-htmlmin') const connect = require('gulp-connect') const del = require('del') // 定义变量，保存各种资源的路径 const paths = { js: { src: 'src/js/**/*.js', // js 文件的源路径 dest: 'dist/js' // js 处理后的目标路径 }, css: { src: 'src/css/**/*.css', dest: 'dist/css' }, scss: { src: 'src/scss/**/*.scss', dest: 'dist/css' }, html: { src: 'src/**/*.html', dest: 'dist' }, libs: { src: 'src/libs/**/*.*', dest: 'dist/libs' } } // 定义任务函数：处理 JS 资源 function scripts() { return gulp.src(paths.js.src) .pipe(babel({ presets: ['env'] })) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) .pipe(connect.reload()) } // 处理 CSS function styles() { return gulp.src(paths.css.src) .pipe(cleanCSS()) .pipe(gulp.dest(paths.css.dest)) .pipe(connect.reload()) } // 编译 sass 文件 function buildScss() { return gulp.src(paths.scss.src) .pipe(sass()) // .pipe(sass({outputStyle: 'compressed'})) .pipe(gulp.dest(paths.scss.dest)) .pipe(connect.reload()) } // html文件处理 function html() { return gulp.src(paths.html.src) .pipe(htmlmin({ collapseWhitespace: true, minifyCSS: true, minifyJS: true })) .pipe(gulp.dest(paths.html.dest)) .pipe(connect.reload()) } // 定义监视任务 function watch() { gulp.watch(paths.scss.src, buildScss) gulp.watch(paths.js.src, scripts) gulp.watch(paths.css.src, styles) gulp.watch(paths.html.src, html) } // 清理 dist 目录 function clean() { return del([ 'dist' ]) } // 复制无需特殊处理的资源 function copyLibs() { return gulp.src(paths.libs.src) .pipe(gulp.dest(paths.libs.dest)) } // 启动 webserver 服务器 function server() { connect.server({ root: 'dist', port: 9527, livereload: true }) } // 形成处理流程 const build = gulp.series(clean, gulp.parallel(styles, scripts, buildScss, html, copyLibs, watch, server)) // 导出任务 exports.scripts = scripts exports.styles = styles exports.buildScss = buildScss exports.watch = watch exports.html = html exports.clean = clean exports.build = build exports.copyLibs = copyLibs exports.server = server // 默认任务 exports.default = build 提交本地版本库 $ git status $ git add -A $ git status $ git commit -m 'flag: message' 推送到远程中央仓库 $ git push origin master 编码实现页面功能 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day33-项目案例（二）.html":{"url":"笔记/js笔记/Day33-项目案例（二）.html","title":"Day33 项目案例（二）","keywords":"","body":"项目案例 技术栈及工具：HTML + CSS + JavaScript + jQuery + art-template + require.js + git + sass + gulp + ...... 电商类项目 实现的页面： 首页 分类（列表）页 详情 购物车 确认订单 用户注册 用户登录 ...... 步骤： 创建空白的 git 远程中央仓库（gitee.com） 将远程中央仓库克隆到本地 $ git clone 在工作空间中创建项目的结构 project |--src # 放置项目源代码 |--|--scss |--|--js |--|--images |--|--libs |--|--html |--|--index.html |--gulpfile.js # gulp 任务配置文件 |--package.json # 项目配置文件 |--.gitignore # git 忽略资源 |--README.md # 项目描述文件 利用 npm init -y 生成 package.json 文件，在文件中添加 devDependencies 字段： { \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-preset-env\": \"^1.7.0\", \"del\": \"^6.0.0\", \"gulp\": \"^4.0.2\", \"gulp-babel\": \"^7.0.1\", \"gulp-clean-css\": \"^4.3.0\", \"gulp-connect\": \"^5.7.0\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-sass\": \"^5.0.0\", \"gulp-uglify\": \"^3.0.2\", \"sass\": \"^1.39.2\" } } 使用 npm i 安装在 package.json 中配置的开发依赖包： $ npm i # 在安装前，可修改 npm 安装的镜像源（只改一次，以后可不用再修改）： # npm config set registry https://registry.npm.taobao.org 复制 gulpfile.js 文件到项目根目录中： // 引入包资源 const gulp = require('gulp') const uglify = require('gulp-uglify') const babel = require('gulp-babel') const cleanCSS = require('gulp-clean-css') const sass = require('gulp-sass')(require('sass')) const htmlmin = require('gulp-htmlmin') const connect = require('gulp-connect') const del = require('del') // 定义变量，保存各种资源的路径 const paths = { js: { src: 'src/js/**/*.js', // js 文件的源路径 dest: 'dist/js' // js 处理后的目标路径 }, css: { src: 'src/css/**/*.css', dest: 'dist/css' }, scss: { src: 'src/scss/**/*.scss', dest: 'dist/css' }, html: { src: 'src/**/*.html', dest: 'dist' }, libs: { src: 'src/libs/**/*.*', dest: 'dist/libs' } } // 定义任务函数：处理 JS 资源 function scripts() { return gulp.src(paths.js.src) .pipe(babel({ presets: ['env'] })) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) .pipe(connect.reload()) } // 处理 CSS function styles() { return gulp.src(paths.css.src) .pipe(cleanCSS()) .pipe(gulp.dest(paths.css.dest)) .pipe(connect.reload()) } // 编译 sass 文件 function buildScss() { return gulp.src(paths.scss.src) .pipe(sass()) // .pipe(sass({outputStyle: 'compressed'})) .pipe(gulp.dest(paths.scss.dest)) .pipe(connect.reload()) } // html文件处理 function html() { return gulp.src(paths.html.src) .pipe(htmlmin({ collapseWhitespace: true, minifyCSS: true, minifyJS: true })) .pipe(gulp.dest(paths.html.dest)) .pipe(connect.reload()) } // 定义监视任务 function watch() { gulp.watch(paths.scss.src, buildScss) gulp.watch(paths.js.src, scripts) gulp.watch(paths.css.src, styles) gulp.watch(paths.html.src, html) } // 清理 dist 目录 function clean() { return del([ 'dist' ]) } // 复制无需特殊处理的资源 function copyLibs() { return gulp.src(paths.libs.src) .pipe(gulp.dest(paths.libs.dest)) } // 启动 webserver 服务器 function server() { connect.server({ root: 'dist', port: 9527, livereload: true }) } // 形成处理流程 const build = gulp.series(clean, gulp.parallel(styles, scripts, buildScss, html, copyLibs, watch, server)) // 导出任务 exports.scripts = scripts exports.styles = styles exports.buildScss = buildScss exports.watch = watch exports.html = html exports.clean = clean exports.build = build exports.copyLibs = copyLibs exports.server = server // 默认任务 exports.default = build 提交本地版本库 $ git status $ git add -A $ git status $ git commit -m 'flag: message' 推送到远程中央仓库 $ git push origin master 编码实现页面功能 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day34-项目案例（三）.html":{"url":"笔记/js笔记/Day34-项目案例（三）.html","title":"Day34 项目案例（三）","keywords":"","body":"项目案例 技术栈及工具：HTML + CSS + JavaScript + jQuery + art-template + require.js + git + sass + gulp + ...... 电商类项目 实现的页面： 首页 分类（列表）页 详情 购物车 确认订单 用户注册 用户登录 ...... 步骤： 创建空白的 git 远程中央仓库（gitee.com） 将远程中央仓库克隆到本地 $ git clone 在工作空间中创建项目的结构 project |--src # 放置项目源代码 |--|--scss |--|--js |--|--images |--|--libs |--|--html |--|--index.html |--gulpfile.js # gulp 任务配置文件 |--package.json # 项目配置文件 |--.gitignore # git 忽略资源 |--README.md # 项目描述文件 利用 npm init -y 生成 package.json 文件，在文件中添加 devDependencies 字段： { \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-preset-env\": \"^1.7.0\", \"del\": \"^6.0.0\", \"gulp\": \"^4.0.2\", \"gulp-babel\": \"^7.0.1\", \"gulp-clean-css\": \"^4.3.0\", \"gulp-connect\": \"^5.7.0\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-sass\": \"^5.0.0\", \"gulp-uglify\": \"^3.0.2\", \"sass\": \"^1.39.2\" } } 使用 npm i 安装在 package.json 中配置的开发依赖包： $ npm i # 在安装前，可修改 npm 安装的镜像源（只改一次，以后可不用再修改）： # npm config set registry https://registry.npm.taobao.org 复制 gulpfile.js 文件到项目根目录中： // 引入包资源 const gulp = require('gulp') const uglify = require('gulp-uglify') const babel = require('gulp-babel') const cleanCSS = require('gulp-clean-css') const sass = require('gulp-sass')(require('sass')) const htmlmin = require('gulp-htmlmin') const connect = require('gulp-connect') const del = require('del') // 定义变量，保存各种资源的路径 const paths = { js: { src: 'src/js/**/*.js', // js 文件的源路径 dest: 'dist/js' // js 处理后的目标路径 }, css: { src: 'src/css/**/*.css', dest: 'dist/css' }, scss: { src: 'src/scss/**/*.scss', dest: 'dist/css' }, html: { src: 'src/**/*.html', dest: 'dist' }, libs: { src: 'src/libs/**/*.*', dest: 'dist/libs' } } // 定义任务函数：处理 JS 资源 function scripts() { return gulp.src(paths.js.src) .pipe(babel({ presets: ['env'] })) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) .pipe(connect.reload()) } // 处理 CSS function styles() { return gulp.src(paths.css.src) .pipe(cleanCSS()) .pipe(gulp.dest(paths.css.dest)) .pipe(connect.reload()) } // 编译 sass 文件 function buildScss() { return gulp.src(paths.scss.src) .pipe(sass()) // .pipe(sass({outputStyle: 'compressed'})) .pipe(gulp.dest(paths.scss.dest)) .pipe(connect.reload()) } // html文件处理 function html() { return gulp.src(paths.html.src) .pipe(htmlmin({ collapseWhitespace: true, minifyCSS: true, minifyJS: true })) .pipe(gulp.dest(paths.html.dest)) .pipe(connect.reload()) } // 定义监视任务 function watch() { gulp.watch(paths.scss.src, buildScss) gulp.watch(paths.js.src, scripts) gulp.watch(paths.css.src, styles) gulp.watch(paths.html.src, html) } // 清理 dist 目录 function clean() { return del([ 'dist' ]) } // 复制无需特殊处理的资源 function copyLibs() { return gulp.src(paths.libs.src) .pipe(gulp.dest(paths.libs.dest)) } // 启动 webserver 服务器 function server() { connect.server({ root: 'dist', port: 9527, livereload: true }) } // 形成处理流程 const build = gulp.series(clean, gulp.parallel(styles, scripts, buildScss, html, copyLibs, watch, server)) // 导出任务 exports.scripts = scripts exports.styles = styles exports.buildScss = buildScss exports.watch = watch exports.html = html exports.clean = clean exports.build = build exports.copyLibs = copyLibs exports.server = server // 默认任务 exports.default = build 提交本地版本库 $ git status $ git add -A $ git status $ git commit -m 'flag: message' 推送到远程中央仓库 $ git push origin master 编码实现页面功能 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/Day35-项目案例（四）.html":{"url":"笔记/js笔记/Day35-项目案例（四）.html","title":"Day35 项目案例（四）","keywords":"","body":"项目案例 技术栈及工具：HTML + CSS + JavaScript + jQuery + art-template + require.js + git + sass + gulp + ...... 电商类项目 实现的页面： 首页 分类（列表）页 详情 购物车 确认订单 用户注册 用户登录 ...... 步骤： 创建空白的 git 远程中央仓库（gitee.com） 将远程中央仓库克隆到本地 $ git clone 在工作空间中创建项目的结构 project |--src # 放置项目源代码 |--|--scss |--|--js |--|--images |--|--libs |--|--html |--|--index.html |--gulpfile.js # gulp 任务配置文件 |--package.json # 项目配置文件 |--.gitignore # git 忽略资源 |--README.md # 项目描述文件 利用 npm init -y 生成 package.json 文件，在文件中添加 devDependencies 字段： { \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-preset-env\": \"^1.7.0\", \"del\": \"^6.0.0\", \"gulp\": \"^4.0.2\", \"gulp-babel\": \"^7.0.1\", \"gulp-clean-css\": \"^4.3.0\", \"gulp-connect\": \"^5.7.0\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-sass\": \"^5.0.0\", \"gulp-uglify\": \"^3.0.2\", \"sass\": \"^1.39.2\" } } 使用 npm i 安装在 package.json 中配置的开发依赖包： $ npm i # 在安装前，可修改 npm 安装的镜像源（只改一次，以后可不用再修改）： # npm config set registry https://registry.npm.taobao.org 复制 gulpfile.js 文件到项目根目录中： // 引入包资源 const gulp = require('gulp') const uglify = require('gulp-uglify') const babel = require('gulp-babel') const cleanCSS = require('gulp-clean-css') const sass = require('gulp-sass')(require('sass')) const htmlmin = require('gulp-htmlmin') const connect = require('gulp-connect') const del = require('del') // 定义变量，保存各种资源的路径 const paths = { js: { src: 'src/js/**/*.js', // js 文件的源路径 dest: 'dist/js' // js 处理后的目标路径 }, css: { src: 'src/css/**/*.css', dest: 'dist/css' }, scss: { src: 'src/scss/**/*.scss', dest: 'dist/css' }, html: { src: 'src/**/*.html', dest: 'dist' }, libs: { src: 'src/libs/**/*.*', dest: 'dist/libs' } } // 定义任务函数：处理 JS 资源 function scripts() { return gulp.src(paths.js.src) .pipe(babel({ presets: ['env'] })) .pipe(uglify()) .pipe(gulp.dest(paths.js.dest)) .pipe(connect.reload()) } // 处理 CSS function styles() { return gulp.src(paths.css.src) .pipe(cleanCSS()) .pipe(gulp.dest(paths.css.dest)) .pipe(connect.reload()) } // 编译 sass 文件 function buildScss() { return gulp.src(paths.scss.src) .pipe(sass()) // .pipe(sass({outputStyle: 'compressed'})) .pipe(gulp.dest(paths.scss.dest)) .pipe(connect.reload()) } // html文件处理 function html() { return gulp.src(paths.html.src) .pipe(htmlmin({ collapseWhitespace: true, minifyCSS: true, minifyJS: true })) .pipe(gulp.dest(paths.html.dest)) .pipe(connect.reload()) } // 定义监视任务 function watch() { gulp.watch(paths.scss.src, buildScss) gulp.watch(paths.js.src, scripts) gulp.watch(paths.css.src, styles) gulp.watch(paths.html.src, html) } // 清理 dist 目录 function clean() { return del([ 'dist' ]) } // 复制无需特殊处理的资源 function copyLibs() { return gulp.src(paths.libs.src) .pipe(gulp.dest(paths.libs.dest)) } // 启动 webserver 服务器 function server() { connect.server({ root: 'dist', port: 9527, livereload: true }) } // 形成处理流程 const build = gulp.series(clean, gulp.parallel(styles, scripts, buildScss, html, copyLibs, watch, server)) // 导出任务 exports.scripts = scripts exports.styles = styles exports.buildScss = buildScss exports.watch = watch exports.html = html exports.clean = clean exports.build = build exports.copyLibs = copyLibs exports.server = server // 默认任务 exports.default = build 提交本地版本库 $ git status $ git add -A $ git status $ git commit -m 'flag: message' 推送到远程中央仓库 $ git push origin master 编码实现页面功能 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/HTML5 移动端自适应方案与踩坑 - 掘金.html":{"url":"笔记/js笔记/HTML5 移动端自适应方案与踩坑 - 掘金.html","title":"HTML5 移动端自适应方案与踩坑   掘金","keywords":"","body":"原文链接：blog.sjfkai.com/2019/01/29/… 转载请注明出处 最近刚接触前端开发，接手了一个移动端H5项目。着实体会掉了前端的坑之多，和H5移动端的坑之多多。 如今项目告一段落，在这里做一总结 屏幕自适应方案 介绍方案之前，首先还是交代一下项目背景与需求，毕竟一切方案也不能脱离实际需求。 需求与背景 设备宽度 > 800px， body宽度为800px 320px 设备宽度 > 320px, body宽度为320px 大部分字体不随宽度变化而缩放 设计图宽度：1080px 自适应方案 关于自适应方案，google一搜就会有很多结果，但是总的来说个人认为最有用的还是手淘的大漠写的一系列文章，后面会给出原文链接。总的来说主流的方案有rem和vh两种。 REM（flexible） rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 所以简而言之，就是根据屏幕宽度设置 html 标签的 font-size。 再在布局时使用 rem 单位来布局，就可以达到自适应的目的。 使用此方案，可以借助手淘的开源项目lib-flexible。它可以自动帮你设置html 标签的 font-size等。将1rem设置为屏幕的1/10。 关于 rem 方案，大漠老师在使用Flexible实现手淘H5页面的终端适配中进行了详细的介绍。建议大家阅读一下。 如你所见，大漠老师也在近期对文正进行了更新，建议大家使用更方便的 vw 方案。 VW vw 是视口宽度的1/100，用 vw 来做自适应再合适不过了。 比如如果你的设计图是 750px 的宽度。 对于 75px 的元素就可以设置为 10vw。 这样在宽度为 375px 的手机上的表现就是37.5px。 当然，如果我们把每个 px 标注都手动转换的话，那也是很大的工作量， postcss-px-to-viewport可以自动帮你转换为 vw。 你只需要在配置时指定设计图宽度就可以了。 同样，强烈建议你去阅读以下大漠老师关于 vw 布局的文章 再聊移动端页面的适配 我的方案 vw + rem vw 虽好，可惜却无法满足我的需求。因为 vw 是整个视口宽度的1%，如果单纯采用 vw 方案，是无法限制 body 最大、最小宽度的。 于是我便采用了 vw + rem。 如果屏幕宽度在需要自适应的宽度之内，则将html 标签的 font-size设置为 10vw。如果屏幕宽度超过最大或最小限制的话。则将html 标签的 font-size设置为固定值。类似于lib-flexible，将1rem设为了 body 宽度的1/10。 具体 css 如下： html { height: 100%; font-size: 10vw; } body { font-size: 16px; width: 100%; height: 100%; margin: 0 auto; } @media screen and (max-width: 320px) { html{ font-size: 32px; } body{ min-width: 320px; } } @media screen and (min-width: 800px) { html{ font-size: 80px; } body{ max-width: 800px; } } 复制代码 当然，这样在布局时，我们就需要使用rem单位来布局了。 设计图标注 px 转 rem 单位同样也有现成的工具。博主使用的是postcss-pxtorem。 最终的效果： 坑 - 以上介绍的适配方案，基本上就可以满足大部分的需求了。 下面我们来聊一聊我都遇到了哪些坑。 小数像素问题 由于我们的方案，所有元素根据屏幕宽度来自适应。因而很难保证转换后的像素为整数像素。 在未接触前端，或者说H5开发之前并没有认真考虑过小数像素的问题，最初以为就是在可现实的精度上四舍五入。真正开发时发现并不是这样的。 比如下面这个例子，同样的像素值表现就不一样：在线实例 IOS、macOS设备最小像素好像支持到了0.5px，所以上面的例子在苹果设备上表现并不是很明显。 但是毕竟大部分设备还是Android和windows系统。 那么，到底浏览器是如何处理小数像素的呢？ rem 产生的小数像素问题 这篇文章给出了答案： 浏览器在渲染时所做的舍入处理只是应用在元素的渲染尺寸上，其真实占据的空间依旧是原始大小。 也就是说如果一个元素尺寸是 0.625px，那么其渲染尺寸应该是 1px，空出的 0.375px 空间由其临近的元素填充；同样道理，如果一个元素尺寸是 0.375px，其渲染尺寸就应该是 0，但是其会占据临近元素 0.375px 的空间。 复制代码 那么在我们的方案里会出现什么问题呢？ 缩放到低于1px的元素会时隐时现 两个同样宽度的元素因为各自周围的元素宽度不同，导致两元素相差1px 宽高相同的正方形，长宽不相等了 border-radius: 50% 画的圆不圆了 对于第一个问题，一般都会出现在标注为1px的地方。所以大部分的插件 postcss-pxtorem 或者 postcss-px-to-viewport 都提供了最小转换像素的选项。 我们只要指定最小转换像素，对于比较小的像素（如：1px），就不转换为rem或vw了。当然1px在视网膜屏同样存在过粗的问题，我们在之后会讨论。 对于剩下的几个问题，目前本人也没找到特别好的办法，毕竟很多地方相差1px是可以接受的。只有一些比较小的元素会表现的比较明显，本人的解决办法是不通过插件自动转换为rem或vw，而是通过js根据设备宽度，计算出该元素在该设备下实际的px。取整后动态地设置到元素的style上。这样就不会出现上述问题了。 如果各位有更好的解决方案的话。欢迎留言讨论。 0.5px问题 由于上面小数像素的问题，我们并没有对1px的元素进行转换，所以对于750px的设计图上1px的细线，在屏幕宽度为375px的iphone6上依旧为1px，按比例应该是0.5px。所以设计同学会问：“为什么这条细线变粗了？” 我们也很无奈啊，因为0.5px显不出来啊…… 但是转念一想，对于DPR=2甚至更高的设备，1px是由多个物理像素渲染的，其实是可以显示更细的线的。那么这样才能画出更细的线呢？ 大漠老师又出场了，《再谈Retina下1px的解决方案》中给出了几种方案： viewport放大为device-width的dpr倍数，然后缩小1/dpr倍显示 border-image设为一个一半透明一半显示的图片，以达到将边框一分为二的目的 同样是上面的原理，但是使用svg绘制图片 媒体查询配合伪元素，为伪元素设置1px的边框，然后缩小1/dpr倍显示 以上方案各有各的特点，2、3两个方案画出来的其实是0.5px，而1、4两个方案画出来的更接近物理像素的1px cursor:pointer 元素点击背景变色的问题 对于添加了 cursor:pointer 属性的元素，在移动端点击时，背景会高亮。 为元素添加 -webkit-tap-highlight-color: transparent; 属性可以隐藏背景高亮。 Android浏览器下line-height垂直居中偏离的问题 我们常用的垂直居中方式就是使用line-height，但是这种方法在Android设备下并不能完全居中。 具体原因是因为Android中文字体排版的问题，可以参考 知乎：Android浏览器下line-height垂直居中为什么会偏离？ 通过设置字体，确实能够解决一部分偏离的问题。但仍然会出现一些略微偏离的情况，据说与行高奇数偶数有关。不过已经不太容易分辨了，如果还是不能接受的话建议通过设置上下padding的方式进行垂直居中，再根据具体情况进行微调。 参考文章 使用Flexible实现手淘H5页面的终端适配 再聊移动端页面的适配 rem 产生的小数像素问题 再谈Retina下1px的解决方案 Android浏览器下line-height垂直居中为什么会偏离？ 欢迎关注公众号 “大前端开发者”。给你带来更多的前端技术与资讯 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-04-07 17:22:36 "},"笔记/js笔记/JS中 for in 与 for of的区别_nO0b-CSDN博客_js中for循环in和of的区.html":{"url":"笔记/js笔记/JS中 for in 与 for of的区别_nO0b-CSDN博客_js中for循环in和of的区.html","title":"JS中 For In 与 For Of的区别 NO0b CSDN博客 Js中For循环In和Of的区","keywords":"","body":"最直接的区别就是: for in遍历的是数组的索引（即键名）， 而for of遍历的是数组元素值。 1. Array.prototype.method=function(){} 2. var myArray=[1,2,4]; 3. myArray.name=\"数组\"; 5. for (var index in myArray) 6. console.log(myArray[index]); 8. for (var value of myArray) 9. console.log(value); 除此之外还有一些细节: for in的一些缺陷: 索引是字符串型的数字，因而不能直接进行几何运算 遍历顺序可能不是实际的内部顺序 for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性 故而一般用for in遍历对象而不用来遍历数组 这也就是for of存在的意义了,for of 不遍历method和name,适合用来遍历数组 那for of有缺点吗? 当然有了: for of不支持普通对象，想遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法： Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性 1. for (var key of Object.keys(Object)) 2. console.log(key + \": \" + Object[key]); 但是感觉这样有些多此一举, 总结来说: for of 遍历数组 for in 遍历对象 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:23:13 "},"笔记/js笔记/JavaScript实现列表无限加载.html":{"url":"笔记/js笔记/JavaScript实现列表无限加载.html","title":"JavaScript实现列表无限加载","keywords":"","body":"起因 之前自己在使用这种网站时，经常看到无限加载的效果。 今天正好看到了getBoundingClientRect这个Api，就想着试试看如何实现Infinite scroll的效果。 原理 在需要无限加载的列表底部，埋下一个隐藏元素。 当不断滑动时，隐藏元素将出现在视窗(viewport)里，也就意味着当前浏览的列表已经到底部了。 这时候就需要进行列表加载。 大概的HTML结构如下： 我是文章 我是文章 我是文章 我是文章 我是文章 也就是：滑动列表 => 隐藏的无限加载指示器出现在视图 => 开始加载 那么重点就是检测隐藏的无限加载指示器是否出现在视图窗口。 还好，我们有getBoundingClientRect这个Api。 getBoundingClientRect 通过查阅MDN，得知： Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。而除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。 至于兼容性，一片绿，可以放心使用。 Can I Use getboundingclientrect? Data on support for the getboundingclientrect feature across the major browsers from caniuse.com. DOMRect 对象 getBoundingClientRect()方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。 对象的属性如下图所示： 其中的 top, left, bottom, right 均是元素自身相对于视图左上角而言的。 就top, left属性而言，很好理解。而bottom, right则一开始搞的有点懵，后面通过devtools观察，发现bottom是元素的最底部相对于视图窗口左上角而言的，而right则是元素的最右侧相对于视图窗口左上角而言的。 其中right-left为元素的宽度,bottom - top则是元素的高度。 检测元素是否出现于视图窗口中 在这里，有两种情况，一个是元素是否出现于视图窗口中，另一种则是元素是否完全出现于视图窗口中。 两种情况的区别在于一个是部分出现，一个是完全出现。 下面我把两种情况都写出来： 部分出现在视图窗口中 function checkIsPartialVisible (element) { const rect = element.getBoundingClientRect() const { top, left, bottom, right } = rect const isPartialVisible = top >= 0 && left >= 0 return isPartialVisible } 全部出现于视图窗口中： function checkIsTotalVisible (element) { const rect = element.getBoundingClientRect() const { top, left, bottom, right } = rect const isTotalVisible = ( top >= 0 && left >= 0 && bottom 那么问题来了：我们到底选用那种呢？ 从无限加载这个业务场景出发，埋在列表最下边的加载触发器都非常小且不可见，因此推荐选用第二种，也就是完全出现于视图窗口的方式。 至于第一种，更适合检测该元素是否已经出现在视图窗口，但并不要求全部出现的情况。 实战 具体可以看我在jsfiddle上写的demo： 无限加载实例 后续 后续更多的则是一些性能优化的事情，比如debounce或者throttle来减少scroll事件调用次数，加入ajax加载，loading indicator等。 那些都是属于具体的业务范围了，这儿不做讨论。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/JavaScript异步机制详解.html":{"url":"笔记/js笔记/JavaScript异步机制详解.html","title":"JavaScript异步机制详解","keywords":"","body":"JavaScript异步机制详解 0.6442018.01.26 15:03:06字数 2,397阅读 4,323 学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。 一、同步与异步 在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？ 同步 如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 如下所示： //在函数返回时，获得了预期值，即2的平方根 Math.sqrt(2); //在函数返回时，获得了预期的效果，即在控制台上打印了'hello' console.log('hello'); 上面两个函数就是同步的。 如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。 异步 如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 如下所示： //读取文件 fs.readFile('hello.txt', 'utf8', function(err, data) { console.log(data); }); //网络请求 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = xxx; // 添加回调函数 xhr.open('GET', url); xhr.send(); // 发起函数 上述示例中读取文件函数 readFile和网络请求的发起函数 send都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在JavaScript中通过回调函数 function(err, data) { console.log(data); }和 onreadystatechange ，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调。 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。 二、单线程与多线程 在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？ JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。 浏览器 目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。 一个浏览器通常由以下几个常驻的线程： 渲染引擎线程：顾名思义，该线程负责页面的渲染 JS引擎线程：负责JS的解析和执行 定时触发器线程：处理定时事件，比如setTimeout, setInterval 事件触发线程：处理DOM事件 异步http请求线程：处理http请求 需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。 JS引擎 通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。 JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤： 词法分析：将源代码分解为有意义的分词 语法分析：用语法分析器将分词解析成语法树 代码生成：生成机器能运行的代码 代码执行 不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。 之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。 所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown...）等都是由浏览器提供的其他线程来完成的。 三、消息队列与事件循环 通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？ 这一切的解释就需要继续了解消息队列和事件循环。 如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。 右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。 JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。 JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。 上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。 四、示例 引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。 执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（>5s）后，再点击两下，整个过程的输出结果是什么？ setTimeout(function(){ for(var i = 0; i 要想了解上述代码的输出结果，首先介绍下定时器。 setTimeout的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间。 setTimeout(fn, 0)的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行。看一个例子： setTimeout(function() { console.log(\"a\") }, 0) for(let i=0; i打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。 理解了定时器的作用，那么对于输出结果就容易得出了。 首先，先执行同步任务。其中waitFiveSeconds是耗时操作，持续执行长达5s。 0 1 2 3 4 click begin finished waiting 然后，在JS引擎线程执行的时候，'timer a'对应的定时器产生的回调、 'timer b'对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。 click click timer a timer b 最后，5s 后的两次 click 事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。 JavaScript中的同步回调与异步回调 JavaScript中回调函数有两种，分别是同步回调与异步回调。 同步回调是指在一个函数中将另一个函数作为参数传进去，在函数中的代码执行完之后，调用传进来的函数参数实现回调，如： function f1(callback) { console.log('b') callback() } 这里的callback就是一个同步的回调函数，它没有利用事件轮询机制来实现回调，所有代码都在主线程中执行，当函数中的代码执行完后会立即执行回调函数，函数执行的顺序是自上而下的。这样的函数中如果有耗时操作会阻塞主线程执行。 异步回调是指js在执行耗时的操作（如文件io、ajax请求、setTimeout、http连接等）时，为避免主线程阻塞，JavaScript使用了异步机制，即遇到异步操作时将其放入消息队列中不执行，继续执行后面的代码，主线程中的任务执行完后，再从消息队列中取出一个任务放到执行栈中，执行栈中的任务执行完后再读取消息队列，不断循环，即事件轮询。 JavaScript中promise中的任务是同步任务，then中的函数属于异步回调 回调函数嵌套过多会出现回调地狱问题，可以使用promise来解决 console.log(1) let a = new Promise((res, rej) => { res(); console.log(2); }); a.then(() => { console.log(6) }) console.log(3); let b = new Promise((res, rej) => { res(); console.log(4); }); b.then(() => { console.log(7) }) console.log(5); console.log('-----------------同步回调-----------') console.log('a') function f1(callback) { console.log('b') callback() } console.log('c') f1(function() { console.log('d') }) console.log('e') function f2(callback) { console.log('f') callback() } f2(function () { console.log('g') }) console.log('h') 结果： 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:18:56 "},"笔记/js笔记/Javascript面向对象编程（二）：构造函数的继承 - 阮一峰的网络日志.html":{"url":"笔记/js笔记/Javascript面向对象编程（二）：构造函数的继承 - 阮一峰的网络日志.html","title":"Javascript面向对象编程（二）：构造函数的继承   阮一峰的网络日志","keywords":"","body":"这个系列的第一部分，主要介绍了如何\"封装\"数据和方法，以及如何从原型对象生成实例。 今天要介绍的是，对象之间的\"继承\"的五种方法。 比如，现在有一个\"动物\"对象的构造函数。 　　function Animal(){ 　　　　this.species = \"动物\"; 　　} 还有一个\"猫\"对象的构造函数。 　　function Cat(name,color){ 　　　　this.name = name; 　　　　this.color = color; 　　} 怎样才能使\"猫\"继承\"动物\"呢？ 一、 构造函数绑定 第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行： 　　function Cat(name,color){ 　　　　Animal.apply(this, arguments); 　　　　this.name = name; 　　　　this.color = color; 　　} 　　var cat1 = new Cat(\"大毛\",\"黄色\"); 　　alert(cat1.species); // 动物 二、 prototype模式 第二种方法更常见，使用prototype属性。 如果\"猫\"的prototype对象，指向一个Animal的实例，那么所有\"猫\"的实例，就能继承Animal了。 　　Cat.prototype = new Animal(); 　　Cat.prototype.constructor = Cat; 　　var cat1 = new Cat(\"大毛\",\"黄色\"); 　　alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。 　　Cat.prototype = new Animal(); 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？ 　　Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有\"Cat.prototype = new Animal();\"这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 　　alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。 　　alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行\"Cat.prototype = new Animal();\"这一行之后，cat1.constructor也指向Animal！ 　　alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象， 　　o.prototype = {}; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。 　　o.prototype.constructor = o; 三、 直接继承prototype 第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 现在，我们先将Animal对象改写： 　　function Animal(){ } 　　Animal.prototype.species = \"动物\"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 　　Cat.prototype = Animal.prototype; 　　Cat.prototype.constructor = Cat; 　　var cat1 = new Cat(\"大毛\",\"黄色\"); 　　alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 所以，上面这一段代码其实是有问题的。请看第二行 　　Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！ 　　alert(Animal.prototype.constructor); // Cat 四、 利用空对象作为中介 由于\"直接继承prototype\"存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。 　　var F = function(){}; 　　F.prototype = Animal.prototype; 　　Cat.prototype = new F(); 　　Cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。 　　alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。 　　function extend(Child, Parent) { 　　　　var F = function(){}; 　　　　F.prototype = Parent.prototype; 　　　　Child.prototype = new F(); 　　　　Child.prototype.constructor = Child; 　　　　Child.uber = Parent.prototype; 　　} 使用的时候，方法如下 　　extend(Cat,Animal); 　　var cat1 = new Cat(\"大毛\",\"黄色\"); 　　alert(cat1.species); // 动物 这个extend函数，就是YUI库如何实现继承的方法。 另外，说明一点，函数体最后一行 　　Child.uber = Parent.prototype; 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是\"向上\"、\"上一层\"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 五、 拷贝继承 上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用\"拷贝\"方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。 首先，还是把Animal的所有不变属性，都放到它的prototype对象上。 　　function Animal(){} 　　Animal.prototype.species = \"动物\"; 然后，再写一个函数，实现属性拷贝的目的。 　　function extend2(Child, Parent) { 　　　　var p = Parent.prototype; 　　　　var c = Child.prototype; 　　　　for (var i in p) { 　　　　　　c[i] = p[i]; 　　　　　　} 　　　　c.uber = p; 　　} 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。 使用的时候，这样写： 　　extend2(Cat, Animal); 　　var cat1 = new Cat(\"大毛\",\"黄色\"); 　　alert(cat1.species); // 动物 （本系列未完，请继续阅读第三部分《非构造函数的继承》。） （完） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/js笔记/__proto__与prototype.html":{"url":"笔记/js笔记/__proto__与prototype.html","title":"  Proto  与Prototype","keywords":"","body":"JS prototype与__proto__的联系与区别_fivedoumi的专栏-CSDN博客_prototype与__proto__的关系与区别 Javascript中的原型链、prototype、__proto__的关系 - 最骚的就是你 - 博客园 (cnblogs.com) 动图解释JS中的原型链 (shuaihuajun.com) 在JavaScript里，没有类的概念，所有东西都是对象，这并没有什么问题,不过，我们必须承认，类的思想会给工程问题带来很多方便，所以，在JavaScript的不断发展中，一些需求也催生了JavaScript想模仿类这个概念。比如说，如果你想构建一个有一定规模的项目，那你必然会涉及到一些继承问题，而这种继承问题，在Java中就是用类来解决的，那在JavaScript中，我们该怎么办？当然有办法，那就是模仿，我们没有类，但我们可以模仿类，而且随着时代的发展，我们有了更好的方法。prototype与__proto__都是在这个过程中催生的产物 __proto__属性是对象独有的，prototype属性是Function独有的。但是JS中函数也是一种对象，所以函数也有__proto__属性。 首先举一个简单的例子： function Foo(name) { this.name = name } let f1 = new Foo(); 上面的代码表示创建一个构造函数Foo()，并用new关键字创建一个构造函数的实例f1，虽然只有两行代码，但他们背后的关系确是错综复杂的，如下图： 第一步，Foo函数被执行。Foo函数在f1的作用域下被执行，所以这里this指代的就是f1，这样name属性才会被当做f1的属性被创建，如果你在函数Foo中写一个console.log()语句，它也会在结果中打印出来. 第二步，将f1.__proto__指向Foo.prototype。这才是javascript构造函数的精髓所在，之后foo就继承了Foo.prototype中（以及其原型链上）的属性与方法。 __proro__属性：由一个对象指向另一个对象，即指向他们的原型对象（也可以理解为父对象），它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，如果父对象也不存在这个属性，则继续往上找，直到原型链的终点null。以上这种通过__proto__属性来连接对象直到终点null的一条链即为原型链。我们平时调用的字符串方法、数组方法、对象方法等都是靠__proto__继承而来的。 prototype：它是函数独有的，从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数所创建的实例的原型对象。prototype的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象都可以找到公用的属性和方法。任何函数在创建的时候都会默认创建该函数的prototype对象 __proto__是真正用来查找原型链去获取方法的对象。 prototype是在用new创建对象时用来构建__proto__的对象。 参考 帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）_码飞_CC的博客-CSDN博客 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-13 22:07:41 "},"笔记/js笔记/js学习step/js学习step.html":{"url":"笔记/js笔记/js学习step/js学习step.html","title":"Js学习Step","keywords":"","body":"作者：知乎用户 链接：https://www.zhihu.com/question/23078046/answer/203531074 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如果说选一本JS入门书籍的话，那《JavaScript高级程序设计》（以下简称‘高程’）是比《JavaScript权威指南》（以下简称‘犀牛书’）更适合入门的。 但你要说入门，我觉得高程也不是最适合小白看的。我的建议是 step1：菜鸟教程JavaScript/w3cschool JavaScript二选其一。 有人说这种教程垃圾，我是不同意的，作为初学者，重要的是先对JS有个初步的理解，看完了能上手做点小东西提升信心。即使抱着效果好一点的高程，也要花上一个月左右看完的吧。这时候前面的知识都忘差不多了，想做个小demo都捉襟见肘。所以，先看这两个在线教程没错。 step2：廖雪峰JavaScript教程 廖大教程涵盖内容很广泛，行文流畅而又深入浅出，讲了很多菜鸟和w3c上没有的知识点，基本全是干货，适合这时候看。后面有些章节可以暂时不看，先看三分之二即可。划重点，map和set，iterable，函数整章，标准对象整章，面向对象编程整章，浏览器整章，jQuery整章，后面的先别看。然后看第二遍，简单的内容就别看了，回去巩固一下map和set，iterable，map/reduce，filter，sort，闭包，箭头函数，正则表达式，JSON，对象，DOM操作，AJAX，promise，jQuery。时不时做个小demo出来，增强信心。 step3：高程 这时候，廖大过了三分之二，有些小细节可能理解了但是又不够扎实，来看高程吧。高程的4/5/6/7/13是要重点看的，8/10/11/12/13是次重点，第一遍看的时候，和IE有关的都先别看。不要陷入细节，先把大体上的意思理解了。记忆中第一遍看的时候，觉得第4章写的相当不错。 step4：菜鸟教程jQuery 建议一天内看完，虽然不敢说自己会jQuery，但是基本就是 $(selection).action()这个套路。 step5：专项突破 到这时，发现简单的内容差不多都理解了，但几块大骨头还是有点生疏，专攻一下this，闭包，原型链，对象，AJAX，JS内存调度，事件处理等自己觉得需要加深理解的地方。 当然，如果你开始就拿出了犀牛书学习，很可能从一开始就“卒”了。 update： step6: 《你不知道的JavaScript》+《深入理解JavaScript》 学JS的同时，也学习一门框架记得。CSS能写页面即可，别研究什么奇技淫巧，浪费时间啊。JS+框架研究6了，工作不愁的。CSS屌顶多是个切图的。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:20:05 "},"笔记/js笔记/js比较两个对象是否相等_承蒙时光不弃1769203735的博客-CSDN博客_js比较两个对象是否.html":{"url":"笔记/js笔记/js比较两个对象是否相等_承蒙时光不弃1769203735的博客-CSDN博客_js比较两个对象是否.html","title":"Js比较两个对象是否相等 承蒙时光不弃1769203735的博客 CSDN博客 Js比较两个对象是否","keywords":"","body":" 前言：如何判断两个对象是否相等？ 两个Object类型对象，即使拥有相同属性、相同值，当使用 == 或 === 进行比较时，也不认为他们相等。这就是因为他们是通过引用（内存里的位置）比较的，不像基本类型是通过值比较的。 1. var obj1 = { 2. name: \"xiaoming\", 3. sex : \"male\" 4. } 6. var obj2 = { 7. name: \"xiaoming\", 8. sex : \"male\" 9. } 11. console.log(obj1 === obj2); 12. 复制代码 但是如果浅拷贝指向同一内存的时候，此时两个对象相等。 1. var obj1 = { 2. name: \"xiaoming\", 3. sex : \"male\" 4. }; 6. var obj2 = { 7. name: \"xiaoming\", 8. sex : \"male\" 9. }; 11. var obj3 = obj1; 13. console.log(obj1 === obj3); 15. console.log(obj2 === obj3); 17. 复制代码 正如你所看想的，检查对象的“值相等”我们基本上是要遍历的对象的每个属性，看看它们是否相等 7. var deepEqual = function (x, y) { 9. if (x === y) { 10. return true; 11. } 12. else if ((typeof x == \"object\" && x != null) && (typeof y == \"object\" && y != null)) { 13. if (Object.keys(x).length != Object.keys(y).length) 14. return false; 16. for (var prop in x) { 17. if (y.hasOwnProperty(prop)) 18. { 19. if (! deepEqual(x[prop], y[prop])) 20. return false; 21. } 22. else 23. return false; 24. } 26. return true; 27. } 28. else 29. return false; 30. } 31. 复制代码 虽然这个简单的实现适用于我们的例子中，有很多情况下，它是不能处理。例如： 如果该属性值之一本身就是一个对象吗？ 如果属性值中的一个是NaN（在JavaScript中，是不是等于自己唯一的价值？ 如果一个属性的值为undefined，而另一个对象没有这个属性（因而计算结果为不确定？） 结语： 检查对象的“值相等”的一个强大的方法，最好是依靠完善的测试库，涵盖了各种边界情况。Underscore和Lo-Dash有一个名为_.isEqual()方法，用来比较好的处理深度对象的比较。 最后附上Underscore里的_.isEqual()源码地址： github.com/hanzichi/un… 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:22:31 "},"笔记/js笔记/【JavaScript】ES5_ES6 创建对象与继承 - 掘金.html":{"url":"笔记/js笔记/【JavaScript】ES5_ES6 创建对象与继承 - 掘金.html","title":"【JavaScript】ES5 ES6 创建对象与继承   掘金","keywords":"","body":"1. ES5 创建对象的方式 在 JavaScript 中，创建对象的方式有很多种，最常用的一般是通过字面量的方式，而要创建实例对象则一般通过创建一个构造函数，通过 new 关键字来构造。 虽然 Object 函数和字面量都可以创建对象，但同时也会有一个问题：使用一个接口创建多个对象时，会出现大量重复代码。下面来介绍一些创建对象的变体。 1.1 工厂模式 function createPerson(name, age) { var obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function () { console.log(this.name); }; return obj; } var person = createPerson('mike', 18); 复制代码 工厂模式解决了创建多个相似对象的问题，但缺点是无法识别对象原型。 这里打印 person 对象，可以看到有 2 个属性和 1 个方法，原型对象是 Obejct，constructor 属性（指向构造函数的指针）指向 Object 对象。 1.2 构造函数 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); } } var person = new Person('mike', 18); var person2 = new Person('alice', 20); // 相当于以下操作 var obj = new Object(); obj.__proto__ = Person.prototype; Person.call(obj, 'mike', 18); 复制代码 构造函数模式是比较常见的一种方式，通过大写函数名的第一个字母来用以区分普通函数。 构造函数与工厂模式还有以下的不同： 没有显示创建对象 直接将属性赋值给了 this 没有 return 此时创建 person 实例需要通过 new 关键字，通过 new 关键字调用构造函数的过程其实经历了以下四个步骤： 创建一个新对象: var obj = new Object(); 将构造函数的原型对象赋值给新的对象 obj: obj.__proto__ = Person.prototype; 执行构造函数中的代码，给新对象 obj 添加属性和方法: Person.call(obj, 'mike', 18); 返回 obj 对象 构造函数解决了工厂模式不能识别实例类型的问题，但是也有一个缺点：在这个例子里它会多次创建了相同函数 sayName。 1.3 原型模式 我们创建每一个函数都有一个 prototype（原型）属性，指向一个对象。这个对象的用途是包含所有特定类型（例子是 Person）的所有实例共享的属性（name age）和方法（sayName）。 function Person() { } Person.prototype = { constructor: Person, // 不指定 constructor 会使 constructor 指向断裂，导致对象类型无法正确识别。 name: 'mike', age: 19, hobby: ['football', 'singing'], sayName: function () { console.log(this.name); } } var person1 = new Person(); var person2 = new Person(); person1.hobby.push('dancing'); // person2.hobby: ['football', 'singing','dancing'] 复制代码 constructor 指向未断裂的情况：指向了 Person constructor 指向断裂的情况：失去了 constructor，默认指向了 Object 原型链示意图： 下图可见通过原型模式解决了构造函数模式多次创建了 sayName 方法的问题，但聪明的电视机前的你肯定发现了定义的原型属性会被所有的实例共享。 当我们操作了 person1 的 hobby 对象的时候，person2 的也同时被修改了，这是我们不愿看到的。 1.4 组合模式 function Person(name, age) { this.name = name; this.age = age; this.hobby = ['football', 'singing'] } Person.prototype = { constructor: Person, // 不指定 constructor 会使 constructor 指向断裂，导致对象类型无法正确识别。 sayName: function () { console.log(this.name); } } var person1 = new Person('mike', 18); person1.hobby.push('dancing'); var person2 = new Person('alice', 19); 复制代码 通过以上的几种方式的分析，我们差不多也能得到比较好的一种模式了，那就是组合模式。 在构造函数中添加实例属性，在构造函数的原型链上添加实例方法，这样既解决了实例共享，又解决了多次创建相同函数的问题，是目前使用比较广泛的模式。 2. ES6 创建对象的方式 ES6 里我们可以通过 class 关键字来定义一个类，class 实际上是一个语法糖，虽然绝大部分的功能可以通过 ES5 实现，但是 class 的写法让对象变的更加清晰，更接近面向对象的语法。 通过 class 来改写组合模式： class Person { constructor(name, age) { this.name = name; this.age = age; this.hobby = ['football', 'singing']; } sayName() { console.log(this.name); } } var person1 = new Person('mike', 18); person1.hobby.push('dancing'); var person2 = new Person('alice', 19); 复制代码 由此对比可见，和 ES5 的结果只有在 __proto__ 对象里的 constructor 显示的是 class，其余的部分都是一致。 通过 babel 编译成 ES5，我们进行一下对比。 'use strict'; var _createClass = function () { // 定义属性的配置项 function defineProperties(target, props) { for (var i = 0; i 抛开对属性的一些配置上的操作，与 ES5 我们所用的组合模式并无不同。 3. ES5 实现继承 首先我们通过组合模式创建一个 Animal 父类对象 // 定义一个动物类 function Animal(name) { // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function () { return this.name + ' 正在睡觉!'; } } // 原型方法 Animal.prototype.eat = function (food) { return this.name + ' 正在吃: ' + food; }; 复制代码 3.1 原型链继承 核心： 将父类的实例作为子类的原型（注意不能使用字面量方式定义原型方法，会重写原型链） function Cat() {} Cat.prototype = new Animal(); Cat.prototype.name = 'cat'; //&emsp;Test Code var cat = new Cat(); console.log(cat.name); // cat console.log(cat.eat('fish')); // cat 正在吃：fish console.log(cat.sleep()); // cat 正在睡觉! console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 复制代码 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 推荐指数：★★（3、4两大致命缺陷） 3.2 构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） function Cat(name){ Animal.call(this); this.name = name || 'Tom'; } // Test Code var cat = new Cat(); console.log(cat.name); // Tom console.log(cat.sleep()); // Tom 正在睡觉 // console.log(cat.eat('fish')); // 会报错，原型在这里不可用 console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true 复制代码 特点： 解决了原型链继承中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 推荐指数：★★（缺点3） 3.3 实例继承（原型式继承） 核心：为父类实例添加新特性，作为子类实例返回 function Cat(name){ var instance = new Animal(); instance.name = name || 'Tom'; return instance; } // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // false 复制代码 特点：不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 推荐指数：★★ 3.4 拷贝继承 function Cat(name){ var animal = new Animal(); for(var p in animal){ Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || 'Tom'; } // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true 复制代码 特点：支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 推荐指数：★（缺点1） 3.5 组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 function Cat(name){ Animal.call(this); this.name = name || 'Tom'; } Cat.prototype = new Animal(); // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 复制代码 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 推荐指数：★★★★（仅仅多消耗了一点内存） 3.6 寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 function Cat(name){ Animal.call(this); this.name = name || 'Tom'; } (function(){ // 创建一个没有实例方法的类 var Super = function(){}; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super(); })(); // 等价于下面这种情况 // function inheritPrototype(sub, sup) { // var Fn= function() {} // Fn.prototype = sup.prototype; // sub.prototype = new Fn(); // } // inheritPrototype(Cat, Animal); // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true 复制代码 特点：堪称完美 缺点：实现较为复杂 推荐指数：★★★★ 4. ES6 实现继承 首先还是创建一个 Animal 类 class Animal { constructor(name) { this.name = name || 'Animal'; this.sleep = function () { return this.name + ' 正在睡觉!'; } } eat(food) { return this.name + ' 正在吃: ' + food; }; } 复制代码 然后通过 extends 关键字来继承 Animal class Cat extends Animal { constructor(name, age) { super(name); this.age = age; // 新增的子类属性 } eat(food) { const result = super.eat(food); // 通过 super 调用父类方法 return this.age + ' 岁的 ' + result; } } const cat = new Cat('miao', 3); 复制代码 总结 总的来说，ES6 的 class 语法糖更清晰和优雅地实现了创建对象和对象继承。 但是我们要想更好的理解 class，那么关于 ES5 的对象、对象继承以及原型链等知识也是要掌握的很牢固。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 12:34:30 "},"笔记/js笔记/为什么0.1+0.2=0.30000000000000004而1.1+2.2=3.300000000.html":{"url":"笔记/js笔记/为什么0.1+0.2=0.30000000000000004而1.1+2.2=3.300000000.html","title":"为什么0.1+0.2=0.30000000000000004而1.1+2.2=3.300000000","keywords":"","body":"不管是什么数, 在计算机中最终都会被转化为 0 和 1 进行存储, 所以需要弄明白以下几点问题 一个小数如何转化为二进制 浮点数的二进制如何存储 浮点数的二进制表示 首先我们要了解浮点数二进制表示, 有以下两个原则: 整数部分对 2 取余然后逆序排列 小数部分乘 2 取整数部分, 然后顺序排列 0.1 的表示是什么? 我们继续按照浮点数的二进制表示来计算 0.1 2 = 0.2 整数部分取 0 0.2 2 = 0.4 整数部分取 0 0.4 2 = 0.8 整数部分取 0 0.8 2 = 1.6 整数部分取 1 0.6 2 = 1.2 整数部分取 1 0.2 2 = 0.4 整数部分取 0 … 所以你会发现, 0.1 的二进制表示是 0.00011001100110011001100110011……0011 0011 作为二进制小数的循环节不断的进行循环. 这就引出了一个问题, 你永远不能存下 0.1 的二进制, 即使你把全世界的硬盘都放在一起, 也存不下 0.1 的二进制小数. 浮点数的二进制存储 Python 和 C 一样, 采用 IEEE 754 规范来存储浮点数. IEEE 754 对双精度浮点数的存储规范将 64 bit 分为 3 部分. 第 1 bit 位用来存储 符号, 决定这个数是正数还是负数 然后使用 11 bit 来存储指数部分 剩下的 52 bit 用来存储尾数 Double-precision_floating-point_format 而且可以指出的是, double 能存储的数的个数是有限的, double 能代表的数必然不超过 2^64 个, 那么现实世界上有多少个小数呢? 无限个. 计算机能做的只能是一个接近这个小数的值, 是这个值在一定精度下与逻辑认为的值相等. 换句话说, 每个小数的存储(但是不是所有的), 都会伴有精度的丢失. 浮点数计算的问题 现在我们可以回顾你提出的问题 0.1 + 0.2 == 0.3 0.1 在计算机存储中真正的数字是 0.1000000000000000055511151231257827021181583404541015625 0.2 是 0.200000000000000011102230246251565404236316680908203125 0.3 是 0.299999999999999988897769753748434595763683319091796875 这就是为什么 0.1 + 0.2 != 0.3 的原因 至于 1.1 + 2.2 与之类似。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:25:51 "},"笔记/js笔记/内置对象Array.html":{"url":"笔记/js笔记/内置对象Array.html","title":"内置对象Array","keywords":"","body":"作用：用于保存一组数据值 定义 语法： var array = [] // 直接量 var array = new Array() // 创建数组对象 var array = [val1, val2, val3, ...] // 创建的同时初始化数组 var array = new Array(val1, val2, ......) var array = new Array(number) // 创建数组对象，同时初始化空间大小 创建指定长度的数组： new Array(10).fill(0)：创建一个长度为10的数组并用0填充，填充的目的是避免数组产生空洞 const arr = []; for(let i=0;i ({}))//创建一个长度为10的对象数组 Array.from({length: 10}, (x, i) => i)//创建一个长度为10的用0,1,2……填充的数组 尽量不要使用new创建数组，new关键字只会使代码复杂化，它还会产生某些不可预期的结果，例如： var points = new Array(40, 100); // 创建包含两个元素的数组（40 和 100） var points = new Array(40); // 创建包含 40 个未定义元素的数组！！！ 元素：数组中所保存数据的空间 下标（索引 - index）：数组中所保存元素的编号，编号从 0 开始 长度：数组中所保存元素的个数，使用 .length 属性获取或设置 数组元素的引用 要使用到数组中保存的某个数据值，是通过下标来引用到数组的元素值。例： scores[5] 数组的 API(ES3) 数组对象的属性与方法。内置对象数组本身提供的一些方法，可供我们直接调用到来实现相应功能。 属性： length：获取或设置数组的长度 方法（函数）： 添加元素 push() - 向数组末尾添加元素，返回数组的新的长度，如果有多个元素，可使用 , （逗号）分隔 unshift() - 向数组头部添加元素，并把其他所有元素右移，返回新数组的长度，如果有多个元素，可使用 , （逗号）分隔 splice(index, length, val1, val2, ......) - （可用于数组元素的删除），当length 参数为0时，表示删除0个元素，有 val1, val2, 等参数时，将这些值插入指定 index 索引处，其余元素右移，返回被删除的数组，插入和删除可以同时进行，例如： var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"]; fruits.splice(2, 0, \"Lemon\", \"Kiwi\"); 第一个参数（2）定义了应添加新元素的位置（拼接）。 第二个参数（0）定义应删除多少元素。 其余参数（“Lemon”，“Kiwi”）定义要添加的新元素 删除元素 pop() - 从末尾删除一个元素，返回被删除的元素值，如果数组为空，返回undefined pop 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。pop方法根据 length属性来确定最后一个元素的位置。如果不包含length属性或length属性不能被转成一个数值，会将length置为0，并返回undefined。 eg: var myFish ={0:'angel',1:'clown',2:'mandarin',3:'sturgeon',length:4}; var popped =Array.prototype.pop.call(myFish) shift() - 从头部删除一个元素，并把所有其他元素“位移”到更低的索引，返回被“位移出”的字符串，为空返回undefined，使用call(),apply()与pop()相同 splice(index, length) - 从指定 index 索引处删除 length 个元素，返回的是一个数组，包含了被删除的所有元素，也可用于插入元素 连接 concat() - 连接两个或多个数组，返回连接后的新数组，原数组不受影响 val1.concat(val2，val3);该方法不会更改现有数组，它总是返回一个新数组。该方法可以使用任意数量的数组参数。 转为字符串 join(sep) - 使用指定的符号sep将数组中每个元素连接成一个字符串后返回，如果不传递参数，默认使用 ',' （英文半角的逗号）连接。 toString() - 将数组转换为字符串，返回值与没有参数的 join() 方法返回的字符串相同，返回单字符串以 ' , ' 隔开。所有JavaScript对象都有toString方法，数组也是对象。 排序 reverse() - 反转数组元素，原数组本身不受影响 sort() - 数组元素排序，默认（不传参数）按照数组元素字符串unicode编码升序排序。如果需要按照指定的规则排序，则需要传递比值函数作为参数。 比值函数： 比较函数应该返回一个负，零或正值，这取决于参数： function(a, b){return a-b}如果返回值小于0，a会排到b的前面 当 sort() 函数比较两个值时，会将值发送到比较函数，并根据所返回的值（负、零或正值）对这些值进行排序。 Sort()也可用于对象属性排序，例如： ```js var cars = [ {type:\"Volvo\", year:2016}, {type:\"Saab\", year:2001}, {type:\"BMW\", year:2010}]; cars.sort(function(a, b){return a.year - b.year}); ##### 截取 - slice(start, end) - 从原数组中截取一个子数组片段，start 为起始索引，end 为结束索引，会包含开始索引处的元素，不包含结束索引处的元素，返回截取后的新数组。end 可以省略，表示截取到最后。start 与 end 可以取负值，表示从后向前计数取索引 ##### 遍历、迭代 ```js for (let i = 0; i 对象属性的访问： object. - 打点调用 obj['prop-name'] - 字符串索引，通常当属性名字使用变量保存时，使用字符串索引的方式调用属性 // for ... in for (const index in array) { // array[index] } // index 是数组中当前遍历到元素的下标（字符串类型） // 可以使用 array[index] 方式获取到当前遍历的元素 for ... of for (const value of array) { // value } // value 是数组中当前遍历到的元素值 for in的一些缺陷: 索引是字符串型的数字，因而不能直接进行几何运算 遍历顺序可能不是实际的内部顺序 for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性 for of不支持普通对象，想遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法： Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性 遍历数组使用for…of 遍历对象使用for…in ES5、ES6新增 API 查找索引 indexOf(searchElement)：查找数组中 searchElement 元素第一次出现的索引（下标），如果不存在返回 -1，该函数可以使用第二个可选参数start，设置搜索的起始位置，负值将从结尾开始的给定位置开始。 lastIndexOf(search)：查找数组中 search 元素最后一次出现的索引，如果不存在返回 -1，该函数从数组结尾开始搜索，可选参数与indexOf()相同。 ES6 遍历、迭代 forEach(callback) -- 遍历迭代数组的每个元素，在遍历每个元素时，调用 callback 执行函数体语句块 map(callback) -- 遍历迭代数组的每个元素，返回一个新数组，新数组中的元素值是 callback 函数中的返回值 filter(callback) -- 过滤筛选数组元素，返回一个新数组，新数组中的元素值为满足 callback 函数条件的对应元素值，满足条件返回true some(callback) -- 判断数组中是否存在满足 callback 条件的元素，返回布尔值 every(callback) -- 判断数组中是否每一个元素都满足 callback 条件，返回布尔值 find(callback) -- 查找数组中满足 callback 条件的第一个元素，返回查找到的元素值，找不到返回 undefined findIndex(callback) -- 查找数组中满足 callback 条件的第一个元素的下标，返回下标值，找不到返回 -1 以上几个方法的参数 callback 为函数结构： function(currentValue, currentIndex, array) { // currentValue 表示当前遍历到的元素值 // currentIndex 表示当前遍历到的元素下标 // array 表示调用当前方法的数组 } reduce(callback, init) reduceRight(callback, init) 这两个方法主要实现归并（累计），callback 结构： function(result, currentValue, index, array) { // result 中保存累计结果，每次调用后的返回值会自动存入result中 // currentValue 表示当前遍历到的元素值 // index 表示当前遍历到的元素下标 // array 表示调用当前方法的数组 } init 参数为 callback 函数中 result 的初始值，如果不传递 init 参数，使用数组的第一个元素作为 result 的初始值,此时callback函数会从第二个元素开始执行。 该函数会将每次函数返回的值存入result中实现累加 填充 fill(value)：以指定的 value 值填充数组元素返回修改后的数组。可选参数：start 起始索引，默认值为0，end 终止索引，默认值为this.length,填充时不包括终止索引处的元素。 转换 Array.from()：将类似于数组的对象转换为数组的结构 类（似于）数组（的）对象，如 arguments（arguments 在函数体内部使用，表示函数被调用执行时所传递的实际参数列表） 判断 includes()：判断在数组中是否存在参数表示的元素，返回 boolean 值 Array.isArray()：判断参数是否为数组（面试经常提问如何判断一个表达式是否为数组） 扁平化（了解） flat() 参数：depth(可选) 制定要提取嵌套数组的结构深度，默认值为1 返回值为处理后的新数组，不会改变原数组 flatMap() JavaScript中箭头函数是匿名函数表达式，它们没有用于递归或者事件绑定的命名引用 箭头函数定义包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用 ( .. )包围起来），然后是标识 =>，函数体放在最后。 已剪辑自: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isarray_recursivity 替代方案 使用 reduce 与 concat var arr = [1, 2, [3, 4]]; // 展开一层数组 arr.flat(); // 等效于 arr.reduce((acc, val) => acc.concat(val), []); // [1, 2, 3, 4] // 使用扩展运算符 ... const flattened = arr => [].concat(...arr); reduce + concat + isArray + recursivity // 使用 reduce、concat 和递归展开无限多层嵌套的数组 var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]]; function flatDeep(arr, d = 1) { return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), []) : arr.slice(); }; flatDeep(arr1, Infinity); // [1, 2, 3, 1, 2, 3, 4, 2, 3, 4] forEach+isArray+push+recursivity // forEach 遍历数组会自动跳过空元素 const eachFlat = (arr = [], depth = 1) => { const result = []; // 缓存递归结果 // 开始递归 (function flat(arr, depth) { // forEach 会自动去除数组空位 arr.forEach((item) => { // 控制递归深度 if (Array.isArray(item) && depth > 0) { // 递归数组 flat(item, depth - 1) } else { // 缓存元素 result.push(item) } }) })(arr, depth) // 返回递归结果 return result; } // for of 循环不能去除数组空位，需要手动去除 const forFlat = (arr = [], depth = 1) => { const result = []; (function flat(arr, depth) { for (let item of arr) { if (Array.isArray(item) && depth > 0) { flat(item, depth - 1) } else { // 去除空元素，添加非undefined元素 item !== void 0 && result.push(item); } } })(arr, depth) return result; } 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/内置对象String.html":{"url":"笔记/js笔记/内置对象String.html","title":"内置对象String","keywords":"","body":"JavaScript中字符串是只读的，不能修改，只能覆盖，例如： str[0] = 'A'是无效的，但是也不会产生错误 str = 'A'会将整个字符串覆盖 使用属性可以访问到字符串，例如：str[0] 如果想按照数组的方式处理数组，可以使用split()方法把它转换为数组 创建： var str = 'str' var str = \"str\" var str = new String('str') var str = String('str') API 属性 length：字符串的长度 方法 concat()：字符串连接，与使用‘+’号效果相同 indexOf(sub)：在原字符串中查找子字符串sub第一次出现的索引，未找到返回-1 lastIndexOf()：最后一次出现的索引，未找到返回-1，两个方法均可以使用第二个参数作为起始位置 search(s):搜索特定值的字符串，并返回匹配的位置，与indexOf()的区别是search()无法设置第二个参数，indexOf()无法使用正则表达式 slice(start, end)：截取子字符串，包含start索引处的字符，不包含end索引处的字符。返回截取后的字符串 substring(start, end)：截取子字符串，与 slice 的区别是参数不取负值 substr(start,length):截取字符串，与silce的区别是第二个参数规定被提取部分的长度 includes() charAt(index)：查找index索引处的字符，返回值为该字符 charCodeAt(index)：查找index索引处的字符的 unicode 编码，'a'.charCodeAt()=97 String.fromCharCode(code)：将 code 编码值还原为字符串文本 endsWith(str)：判断字符串是否以 str 作为后缀结尾 startsWith(str)：是否以 str 开头 padStart(targetLength, pad)：将字符串前边补 pad 参数的子字符串内容，以达到 targetLength 的长度 padEnd() replace(sub, newTarget)：替换，将满足 sub 条件的子字符串内容替换为 newTarget 字符串的内容，只替换匹配到的第一个。 如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）： 如需替换所有匹配到的字符，请使用正则表达式 /g： str.replace(/Microsoft/g, \"W3School\"); replaceAll();替换全部 split(sep)：将字符串以指定的sep符号分割成数组， 如果省略分隔符，返回的数组index[0]中将包含整个字符串 如果分隔符是\"\"，返回的数组将是间隔单个字符的数组，逗号也会被放入数组中 toUpperCase()：转换为大写 toLowerCase()：转换为小写 trim()：去掉字符串前后空白 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/函数柯里化 _ 前端修炼小册.html":{"url":"笔记/js笔记/函数柯里化 _ 前端修炼小册.html","title":"函数柯里化   前端修炼小册","keywords":"","body":"# 函数柯里化 # 1. 柯里化的定义 红宝书（第3版）：用于创建已经设置好了一个或多个参数的函数。基本方法是使用一个闭包返回一个函数。（P604） 维基百科：柯里化（英语：Currying），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。（原链接） 官方解释看得有点懵，大白话概括一下： 柯里化技术，主要体现在函数里面返回函数。就是将多变量函数拆解为单变量（或部分变量）的多个函数并依次调用。 再直白一点：利用闭包，可以形成一个不销毁的私有作用域，把预先处理的内容都存在这个不销毁的作用域里面，并且返回一个函数，以后要执行的就是这个函数。 PS：如果还是不理解也没关系，跟闭包一样不用死扣定义，继续往下面看应用就行了。 # 2. 柯里化的应用 柯里化有 3 个常见应用： 参数复用 – 当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化候选 提前返回 – 多次调用多次内部判断，可以直接把第一次判断的结果返回外部接收 延迟计算/运行 – 避免重复的去执行程序，等真正需要结果的时候再执行 # 3. 应用一：参数复用 如下名为 uri 的函数，接收 3 个参数，函数的作用是返回三个参数拼接的字符串。 ``function uri(protocol, hostname, pathname) { return `${protocol}${hostname}${pathname}`; } // 测试一下 const uri1 = url('https://', 'www.fedbook.cn', '/function-curring/') console.log(uri1)`` 上面这种写法的弊端是：当我们有很多网址时，会导致非常多重复的参数（比如 https:// 就是重复的参数，我们在浏览器里面输入网址也不需要输入 http 或者 https）。 利用柯里化实现参数复用的思路： 原函数（称为函数 A）只设置一个参数（接收协议这个参数）； 在函数内部再创建一个函数（称为函数 B），函数 B 把刚才剩余的两个参数给补上，并返回字符串形式的 url； 函数 A 返回函数 B。 ``function uri_curring(protocol) { return function(hostname, pathname) { return `${protocol}${hostname}${pathname}`; } } // 测试一下 const uri_https = uri_curring('https://'); const uri1 = uri_https('www.fedbook.cn', '/frontend-languages/javascript/function-currying/'); const uri2 = uri_https('www.fedbook.cn', '/handwritten/javascript/10-实现bind方法/'); const uri3 = uri_https('www.wenyuanblog.com', '/'); console.log(uri1); console.log(uri2); console.log(uri3);`` # 3. 应用二：兼容性检测 注意 以下代码为了编写方便，会使用 ES6 的语法。实际生产环境中如果要做兼容性检测功能，需要转换成 ES5 语法。 因为浏览器的发展和各种原因，有些函数和方法是不被部分浏览器支持的，此时需要提前进行判断，从而确定用户的浏览器是否支持相应的方法。 以事件监听为例，IE（IE9 之前） 支持的是 attachEvent 方法，其它主流浏览器支持的是 addEventListener 方法，我们需要创建一个新的函数来进行两者的判断。 `const addEvent = function(element, type, listener, useCapture) { if(window.addEventListener) { console.log('判断为其它浏览器') // 和原生 addEventListener 一样的函数 // element: 需要添加事件监听的元素 // type: 为元素添加什么类型的事件 // listener: 执行的回调函数 // useCapture: 要进行事件冒泡或者事件捕获的选择 element.addEventListener(type, function(e) { // 为了规避 this 指向问题，用 call 进行 this 的绑定 listener.call(element, e); }, useCapture); } else if(window.attachEvent) { console.log('判断为 IE9 以下浏览器') // 原生的 attachEvent 函数 // 不需要第四个参数，因为 IE 支持的是事件冒泡 // 多拼接一个 on，这样就可以使用统一书写形式的事件类型了 element.attachEvent('on' + type, function(e) { listener.call(element, e); }); } } // 测试一下 let div = document.querySelector('div'); let p = document.querySelector('p'); let span = document.querySelector('span'); addEvent(div, 'click', (e) => {console.log('点击了 div');}, true); addEvent(p, 'click', (e) => {console.log('点击了 p');}, true); addEvent(span, 'click', (e) => {console.log('点击了 span');}, true);` 上面这种封装的弊端是：每次写监听事件的时候调用 addEvent 函数，都会进行 if...else... 的兼容性判断。事实上在代码中只需要执行一次兼容性判断就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。 那么怎么用函数柯里化优化这个封装函数？ `// 使用立即执行函数，当我们把这个函数放在文件的头部，就可以先进行执行判断 const addEvent = (function() { if(window.addEventListener) { console.log('判断为其它浏览器') return function(element, type, listener, useCapture) { element.addEventListener(type, function(e) { listener.call(element, e); }, useCapture); } } else if(window.attachEvent) { console.log('判断为 IE9 以下浏览器') return function(element, type, handler) { element.attachEvent('on'+type, function(e) { handler.call(element, e); }); } } }) (); // 测试一下 let div = document.querySelector('div'); let p = document.querySelector('p'); let span = document.querySelector('span'); addEvent(div, 'click', (e) => {console.log('点击了 div');}, true); addEvent(p, 'click', (e) => {console.log('点击了 p');}, true); addEvent(span, 'click', (e) => {console.log('点击了 span');}, true);` 上述封装因为立即执行函数的原因，触发多次事件也依旧只会触发一次 if 条件判断。 这里使用了函数柯里化的两个特点：提前返回和延迟执行。 # 4. 应用三：实现一个 add 函数 这是一道经典面试题，要求我们实现一个 add 函数，可以实现以下计算结果： `add(1)(2)(3) = 6; add(1, 2, 3)(4) = 10; add(1)(2)(3)(4)(5) = 15;` 通过这道题正好可以解释柯里化的延迟执行，直接上代码： `function add() { // 将传入的不定参数转为数组对象 let args = Array.prototype.slice.call(arguments); // 递归：内部函数里面进行自己调用自己 // 当 add 函数不断调用时，把第 N+1 个括号的参数加入到第 N 个括号的参数里面 let inner = function() { args.push(...arguments); return inner; } inner.toString = function() { // args 里的值不断累加 return args.reduce(function(prev, cur) { return prev + cur; }); }; return inner; } // 测试一下 let result = add(1)(2)(3)(4); console.log(result);` 解释几个关键点： 1）不定参数 arguments 需要转为数组对象： 因为 arguments 并不是真正的数组，而是与数组类似对象，Array.prototype.slice.call(arguments) 能将具有 length 属性的对象转成数组。 2）toString 隐形转换的特性： 对于 add(1)(2)(3)(4)，执行每个括号的时候都返回 inner 函数，不断自己调用自己，每次内部函数返回的都是内部函数。 如果打印函数执行的最终返回结果，可以发现返回了一个字符串（原本的函数被转换为字符串返回了），这即是发生了隐式转换，而发生隐式转换是因为调用了内部的 toString 方法。 知道了这一点，我们就可以利用这个特性自定义返回的内容：重写 inner 函数的 toString 方法，在里面实现参数相加的执行代码。 值得一提的是，这种处理后能够返回正确的累加结果，但返回的结果是个函数类型（function），这是因为我们在用递归返回函数，内部函数在被隐式转换为字符串之前本来就是一个函数。 （完） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:24:09 "},"笔记/js笔记/模拟点击事件.html":{"url":"笔记/js笔记/模拟点击事件.html","title":"模拟点击事件","keywords":"","body":"模拟点击事件 创建一个鼠标事件 const e = new MouseEvent('click', { view: window, bubbles: true, cancelable: true }) 调用dispatchEvent方法，将创建的事件作为参数传进去 document.querySelector(\".pws-like-btn-bg-pc\").dispatchEvent(e) 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/js笔记/解决图片的防盗链导致图片显示不出来（适合所有的防盗链图片） - 氵永 - 博客园.html":{"url":"笔记/js笔记/解决图片的防盗链导致图片显示不出来（适合所有的防盗链图片） - 氵永 - 博客园.html","title":"解决图片的防盗链导致图片显示不出来（适合所有的防盗链图片）   氵永   博客园","keywords":"","body":"图片的防盗链 因为之前使用了豆瓣的图书 API 用着的时候web 系统突然发现所有的图片都访问不了、然后谷歌一查原来豆瓣采取了防盗链。 问题很简单，就是我希望在自己的页面里用 \\ 来引用其他网站的一张图片，但是他的网站设置了防盗链的策略，会在后台判断请求的Referrer属性是不是来自于一个非本域名的网站，如果来源不是本域名就返回 403 forbidden。我的目的就是用最方便的方法使得我的页面能够不受他的防盗链策略的影响。 解决的方案 1.使用后台的预下载（把图片下载下来放到服务器下） 缺点： 占用服务器的空间，访问速度没有豆瓣提供的稳点。有些网站是静态的如 hexo 就无法实现。 2.第三方代理 缺点： 不稳点，第三方代理可能在国内访问不稳定，在国内没有好的推荐。也可以自己做一个代理，之前有人用 GO 做过一个。 下面有一个，url 后面填上豆瓣 Api 返回的图片地址 \\https://images.weserv.nl/?url=https://img3.doubanio.com/view/photo/s\\_ratio\\_poster/public/p2544866651.jpg\" \\/> 3.还有一种比较友好和奢侈的，上传 CDN 调用 CDN 的地址， 缺点： 有点奢侈，因为所有图片都存到 CND 占用大量空间，CND 可能需要钱购买，CND 服务商提供图片上传的 API 4.删除 Header 中的 Referrer content 有四个值可以选择 never,always,origin,default 这是来自于 whatwg 标准，浏览器对他的支持还是很好的。 MDN 标准，还多了一个 no-referrer 5.添加 ReferrerPolicy 属性 添加 meta 标签相当于对文档中的所有链接都取消了 referrer， 而R eferrerPolicy 则更精确的指定了某一个资源的referrer策略。 关于这个策略的定义可以参照MDN。比如我想只对某一个图片取消referrer，如下编写即可: 文章来源 https://www.mooban.net/252.html 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 16:24:53 "},"笔记/js笔记/解析字符串格式的HTML.html":{"url":"笔记/js笔记/解析字符串格式的HTML.html","title":"解析字符串格式的HTML","keywords":"","body":"结析字符串格式的HTML 使用DOMParser对象DOMParser - Web API 接口参考 | MDN (mozilla.org) DOMParser 可以将存储在字符串中的 XML 或 HTML 源代码解析为一个 DOM Document 创建一个DOMParser对象 let domparser = new DOMParser()​​; 调用parseFormString方法 let doc =domparser.parseFromString(string,mimeType) 该方法接收 2 个必要参数： string表示要解析的HTML或XHTML，mimeType表示返回值的文档类型(text/html,text/xml,application/xml等） 这里的doc就是解析后的document对象，可以调用getElementByID等方法 如： const xhr = new XMLHttpRequest() xhr.open('get', '/9txs/book/145578.html') xhr.send() xhr.onreadystatechange = () => { if (xhr.readyState === 4 && xhr.status === 200) { // const $ = HTML.parse(xhr.parse) // console.log(xhr.responseText) const domparse = new DOMParser() const doc = domparse.parseFromString(xhr.responseText, 'text/html') console.log(doc.querySelector('.header .layui-main .logo').getAttribute('href')) } } 以上代码可以将ajax请求返回的HTML文档解析，获取其中想要的元素的属性 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:35 "},"笔记/other/git命令.html":{"url":"笔记/other/git命令.html","title":"Git命令","keywords":"","body":"1.基础命令 git仓库以及命令关系 1.1配置(config) # 一般配置 # 查看版本信息 git --version # 获取全局登陆的用户,邮箱 git config --global \"user.name\" git config --global \"user.email\" # 设置启动的编辑器 git config --global core.editor vim git config --global core.editor emacs # 获取某个仓库的用户和邮箱(需要进入该仓库) git config --local user.name git config --local user.email git config --list --show-origin # 查看所有的配置以及配置文件所在的位置 git config --list # 查看当前所有的git能找到的配置 git config -e --global # 直接进入编辑全局配置文件 git config --global alias.ci commit # 设置别名,commit别名为ci, 则git ci来替代git commit # 设置单个仓库的git账户 git config --local user.name \"userName\" git config --local user.email \"userEmail\" # 当不能显示中文的时候 git config --global core.quotepath false Copy 1.2仓库初始化或克隆(clone) git可以使用四种不同的协议来传输数据： 本地协议(Local): git clone /srv/git/project.git或者git clone file:///srv/git/project.git HTTP协议：git clone https://xxx.com/xxx.git SSH协议：git clone ssh://[user@]server/project.git] Git协议 # 1.初始化 git init repo # 创建一个git仓库，有.git目录，不能推送修改到“非裸仓库” git init --bare repo.git # 创建一个裸库，没有.git目录，没有工作区（不能在仓库里进行git操作），只会记录git提交的历史信息，裸仓库一般情况下仅作为远程仓库使用，主要是为了维护远程的仓库的“干净” # 2.克隆 git clone # 从远程克隆一个版本库 git clone --depth 1 # 浅克隆，不要commit历史，只要代码 Copy 1.3暂存(add) 由于git commit的操作是原子性的,如果本次commit的内容没有完成，却要切换至其他分支等操作，那么可以将其暂存 git add . # 将所有修改文件暂存 git add test.py # 将指定文件暂存 git add -i # 使用交互式的暂存 Copy 1.4本地提交(commit) git commit在提交信息中换行，只需要单引号，且换行之后再补齐另一半单引号即可 git commit # 直接提交 git commit -m \"init\" # 带注释的提交 git commit -m \"line1\" -m \"line2\" # 带注释的提交,可以有多个-m,表示多行 git commit -a -m \"format\" # 提交当前repo的所有改变，可以跳过git add(慎用，可能会添加不需要的文件) # 1. 如果上次提交以来修改了，会将暂存区中的文件提交,从而将本次的修改合并到上一次的提交(适用于一次提交忘了提交某些信息的场景) # 2. 如果上次提交以来没有任何修改，则只是修改上一次提交的信息(适用于修改提交信息的场景) git commit --amend -m [message] Copy 1.5远程提交于拉取(push, pull) # 当前分支只有一个追踪分支，直接将本地的分支的更新推送至远程主机 git push git push 　: git push origin master:master # 将本地的master分支推送到远程的master分支 git push origin master:dev # 将本地的master分支推送到远程的dev分支 git pull # 当前分支只有一个追踪分支，直接取回远程主机某个分支的更新，与本地的分支合并 git pull 　: # 与本地的指定合并 git push -f # 强制推到远程(慎用) Copy 1.6提交堆栈(stash) git stash clear之后如何找回数据 # 当前分支内容修改了，但是还不想提交，此时需要切换到另一个分支，则该命令将当前分支修改的内容 # 保存到堆栈中，然后就可以在不同的分支中进行切换了 # 将所有未提交的修改（工作区和暂存区）保存到堆栈 git stash git stash save \"message\" # 等同于stash,但是可以加一些注释 git stash list # 查看当前stash中内容 git stash pop # 将当前stash中的内容弹出，并应用到当前分支对应的工作目录（会删除堆栈中最近保存的内容） git stash drop stash@{0} # 删除存储堆栈中指定的进度 git stash clear # 删除所有存储的进度 git stash apply # 将当前stash中的内容应用到当前分支对应的工作目录（不会删除堆栈中最近保存的内容） git stash apply stash@{0} # 使用指定的堆栈中的内容 git stash show -p stash@{1} # 查看某个堆栈中的修改内容 git stash show -p # 查看最近一个stash里面的修改 Copy 1.7分支(fetch, branch, checkout) 特殊指针HEAD，用来指向当前所处的本地分支 git fetch # 取回所有分支的更新 git fetch # 取回指定的分支更新(eg:git fetch origin master) git fetch -p # 跟随远程删除分支的操作删除本地分支 git fetch -P # 跟随远程删除分支的操作删除本地tag git checkout a.txt # 取消对某个文件的修改(即没有文件),恢复暂存区的指定文件到工作区 git checkout [commit] [file] # 恢复某个commit的指定文件到工作区 git checkout dev # 切换到本地的dev分支 git checkout -b dev # 建立一个新的本地dev分支并切换到该分支 git checkout - # 导航到之前的一个分支 git branch # 查看本地所有分支 git branch -v # 查看本地所有分支和分支的最后一次提交 git branch -vv -a # 查询本地仓库，远程仓库，跟踪关系最全的命令 git branch -d dev # 删除本地分支 git branch --merged # 查看本地已经合并到当前的分支 git branch --no-merged # 查看本地还没有合并到当前的分支 git push origin --delete dev # 删除远程分支 git remote get-url origin # 获取远程仓库的地址 Copy 1.8撤销(reset, revert) reset撤销直接删除指定的commit, 将HEAD后移 revert会将操作之前和之后的信息都会保留, 用新的commit回滚旧的commit git reset HEAD # 撤销对所有文件的暂存, add到暂存区的代码想撤销 git reset HEAD test.py # 撤销对指定文件的暂存(适用于误将文件暂存add的场景) git reset HEAD~1 # 如果想要将一个分支的最后一个提交转移到另外一个分支,然后git stash，应用到另外一个分支 git reset --soft HEAD~1 # 将刚刚的提交撤回到暂存区 git reset --soft HEAD^ # 将刚刚的提交撤回到暂存区 git reset --soft HEAD~3 # 撤销最近的三次提交，HEAD, HEAD^ 和HEAD~2均被撤销 git reset --hard # 提交到本地仓库的代码想撤销 git revert HEAD # 撤销前一次commit git revert HEAD^ # 撤销前前一次commit git revert commit d92761fec08ecca646f81402a415e9a07f9638b6 # 撤销指定的版本 Copy 1.9操作记录(log, reflog) git reflog是显示所有的操作记录，包括提交，回退的操作。一般用来找出操作记录中的版本号，进行回退 git reflog常用于恢复本地的错误操作 git log # 查看提交历史 git log -p # 查看提交历史并显示每次提交的差异 git log -p -2 # 只查看最近的两次提交 git log -p # 查看某个文件每次提交的diff git log --stat # 每次提交的简略统计信息，加减行数 git log --graph # 带简单ascii字符来图形化展示 git log --author=bigfoolliu # 筛选作者 git log --grep content # 模糊搜索 git log --pretty=format:\"%H - %an, %cd : %s\" # 使用特定的格式输出log # %H 提交的完整哈希值 # %h 提交的简写哈希值 # %T 树的完整哈希值 # %t 树的简写哈希值 # %P 父提交的完整哈希值 # %p 父提交的简写哈希值 # %an 作者名字 # %ae 作者的电子邮件地址 # %ad 作者修订日期(可以用 --date=选项 来定制格式) # %ar 作者修订日期，按多久以前的方式显示 # %cn 提交者的名字 # %ce 提交者的电子邮件地址 # %cd 提交日期 # %cr 提交日期(距今多长时间) # %s 提交说明 git reflog show # 查看所有的操作记录 git reflog master # 查看分支操作记录 git reflog --date=local | grep branch_name # 查看branch_name分支是基于哪个分支创建的 Copy 1.10标签(tag) 软件发布的时候通常使用，会记录版本的commit号,方便回溯 一般的打tag都是建立在head上 git tag # 查看目前已经打上的标签 git tag -l \"v1\" # 显示tag，并通过关键字过滤 git tag v1.0 # 直接创建一个tag git tag -a v1.0 -m \"有备注信息的tag\" # 创建一个带备注信息的tag git tag -a v1.0 -m \"有备注信息的tag\" # 在某一个提交对象上打tag，只要提交对象的校验和前几位 # tag创建完成之后，需要单独推送到远程,如果 # 推送单个tag git push origin v1.0 # 推送所有的tag git push origin --tags # 删除tag git tag -d v1.0 # 删除本地的tag git push origin :refs/tags/v1.0 # 将冒号之前的空值推动到远程的tag从而删除远程的tag git push origin --delete v1.0 # 更直观的删除远程标签 Copy 1.11查看内容(show) git show # 查看最近的commit git show v1.0 # 查看tag的详细信息 git show # 查看某次提交的内容 git show # 查看某次提交的某个文件的修改 Copy 1.12状态(status) git status # 检查当前文件状态 git status -s # 以更简短的方式检查文件状态 Copy 1.13删除(rm) git移除文件,需要从暂存区中删除，然后提交 如果直接删除已经暂存的文件，需要再次提交 # 从暂存区中删除文件，且文件不会有未追踪的情况 git rm test.txt git rm -f test.txt Copy 1.14移动(mv) 相当于三条命令的结合 mv .., git rm .., git add .. git mv file1 file2 # 将file1重命名为file2 Copy 1.15查看更新(diff) git diff # 查看暂未暂存的文件更新哪些部分 # 查看暂存起来(即add之后)的更新 git diff --cached git diff --staged git diff --check # 检查空白错误，可以在提交之前运行一次 git diff HEAD # 检查自上次提交以来的所有变化 git diff # 查看和某个分支的不同 git diff --diff-filter=MRC # 仅仅查看修改，重命名等，不看增删 Copy 1.16远程(remote) 对远程仓库的操作 origin也并没有特殊含义 # 查看配置的远程仓库服务器,如果是clone的则默认为origin git remote git remote -v # 读写仓库服务器以及对应的简写url git remote add tom https://github.com/tom/liu_aistuff # 添加远程仓库，并设置简写,那么本地fetch之后就可以在tom/master访问 git remote show origin # 查看某个远程仓库的更多信息 git remote rename tom tom1 # 将远程分支重命名 git remote remove tom # 移除远程仓库(适用于远程仓库搬走了或者没人贡献了场景) git ls-remote origin # 查看远程分支列表 Copy 1.17清除(clean) git clean -n # 演示，查看哪些文件会被删除 git clean -f # 删除当前目录下所有没有track的文件,不清理.gitignore文件中指定的文件和文件夹 git clean -df # 删除当前目录下所有没有没有被track的文件和文件夹 git clean -xf # 删除当前目录下的所有文件和文件夹，不管是否在.gitignore中指定 Copy 2.操作命令组 2.1修改已经push的commit的message 已经push的commit如何修改message # 1.确定修改哪些commit git rebase -i HEAD~5 # 2.在vim中将待修改的commit的 pick 改为 edit，然后保存退出，此时git的分支发生改变，改成了我们第一个edit的commit id # 3.在当前分支轮流执行（有几条message要修改就执行几次）以下两个命令,执行完第一个命令，修改message保存 git commit --amend git rebase --continue Copy 2.2修改多次commit的信息为一个 # 1.定位到指定的commit，修改commit的message，倒数的修改为`squash` git rebase -i # 2.修改掉多余的commit message git rebase --continue Copy 2.3提交之后因为大文件而push失败 # 1.回退至指定的版本号 git reset --hard `commit_id` # 2.远程提交回退 git push origin HEAD --force # 3.删除缓存 git rm -r --cached . Copy 2.4提交错误且已经push到远程 # 1.本地撤销到指定版本 git reset --soft # 2.取消对所有文件的头指针指向 git reset --HEAD ./ # 3.重新提交xxx # 4.重新推送到远程,必须要-f git push -f Copy 2.5 分支重命名 # 1.修改本地分支名称 git branch -m old_branch new_branch # 2.重命名的分支提交到远程 git push origin new_branch # 3.删除远程的旧分支 git push origin --delete origin/old_branch Copy 3.gitignore文件 3.1介绍 子目录中也可以有额外的.gitignore文件，且只应用到子目录 常用.gitignore文件 自动生成.gitignore文件网站 3.2格式规范 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以(/)开头防止递归。 匹配模式可以以(/)结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号(!)取反。 glob 模式是指 shell 所使用的简化了的正则表达式。 星号()匹配零个或多个任意字符;[abc] 匹配 任何一个列在方括号中的字符 (这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c); 问号(?)只 匹配一个任意字符;如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配 (比如 [0-9] 表示匹配所有 0 到 9 的数字)。 使用两个星号(*)表示匹配任意中间目录，比如 a//z 可以 匹配 a/z 、 a/b/z 或 a/b/c/z 等。 4.gitmodule 4.1介绍 gitsubmodule是多项目使用共同类库的工具。 4.2使用 # 增加submodule # 父repo增加submodule的repo git submodule add http://github.com/bigfooliu/liu_work.git # 修改submodule,首先Push submodule的变动，然后Push父repo的变动 cd liu_work git add git commit git push cd .. git push # 更新submodule,两种方式 git submodule foreach git pull # 直接父repo cd liu_work # 进入submodule git pull # clone submodule # 采用递归的方式clone整个项目,父项目和submodule git clone git@xxx.git --recursive # 删除submodule,需要手动删除文件 git rm --cached liu_work rm -rf liu_work rm .gitmodules # 然后重新提交修改信息 Copy # 初始化本地.gitmodules文件 git submodule init # 同步远端submodule源码 git submodule update # 给一个仓库添加子仓库 git submodule add # 获取主项目和所有子项目源码 git clone --recurse-submodules # 删除子模块 rm -rf # 删除子模块的目录以及源码 vim .gitmodule # 删除项目目录下.gitmodule文件中子模块相关条目 vim .git/config # 删除配置中子模块相关条目 rm .git/module/* # 删除模块下的子模块目录 git rm --cached # 如果执行完成之后报错执行 Copy 5.其他 5.1非常用命令 # 查看当前状态 git status # 查看commit的日志 git log # 每个提交在一行显示，更加清晰 git log --oneline # 获取某人的提交的日志 git log --author=\"tony\" # 在所有提交中搜索包含关键字的提交 git log --all --grep=\"homepage\" # 指定时间范围内的查询 git log --author=\"liurui\" --after=\"2020-01-01 00:00:00\" --before=\"2020-04-01 00:00:00\" # 获取所有操作历史 git reflog # 查看尚未暂存的更新 git diff # 查看尚未提交的更新 git diff --cached Copy pull request: fork仓库后修改了错误，然后给原始仓库提交pull request 原仓库的所有者看到pr,进行review，觉得对的就merge,完成流程 index文件损坏处理: rm -rf .git/index git reset --mixed HEAD Copy 错误的commit并提交到远程: git log git reset --soft HEAD~2 # 不删除工作空间改动代码，撤销commit，不撤销git add . 或者将HEAD~2改为回退到的版本号 git push origin 分支名 --force # 将当前撤销的提交推送到远程 Copy 5.2github 5.2.1github搜索技巧 # 名字包含python，stars数量大于1000 python in:name stars:>1000 in:readme in:description language:python pushed:2020-01-01 Copy 5.2.2github知识 fork的作用： 当想参与某个项目，但是没有推动权限的时候，将其fork一个副本到自己的仓库，在本地修改之后可以通过创建拉取请求(pull request, pr),将改动进入原项目仓库。 5.3在服务器上搭建git # 1.将当前仓库导出为裸仓库-不包含当前目录的仓库 git clone --bare my_project my_project.git # 2.将本地裸仓库放到服务器上,加入是放入/srv/git目录下 scp -r my_project.git user@git.example.com:/srv/git # 3.如果一个用户对该目录/srv/git目录有读写权限，即可推送了 Copy 5.4如何选择git的分支模式 如何选择git分支模式 5.4.1TBD 主干开发模式 在一个分支开发，变更要小，要快速完成验证 适合小规模团队 5.4.2Git-Flow模式 feature(新功能分支)，开发者从develop分支拉取新的分支，开发完成，再merge到develop分支 develop(新功能集成分支)，永远是保存开发集成中最新的版本，代码验证可发布之后，单独从develop分支拉release分支进行发布 release(版本发布分支)，如果有缺陷修改，会同步到develop和master分支 hotfix(线上缺陷紧急修改分支)，从master拉出，修复后验证，并将问题修复合并到develop和release上 master(保存最新发布版本基线的分支)，主干分支，保存的是可工作版本的基线,即稳定随时可以上线的分支 适合大规模团队 5.4.3Github-Flow模式 master分支永远是所有代码最新可部署，可工作的版本 新工作从master拉取新分支 尽可能频繁的同步服务端同名的分支 合并到master，直接发起 pull request，请代码评审，评审通过，合并到master 5.4.4Gitlab-Flow模式 类似于github-flow模式，开发将pull request 改成了 merge request 5.5git-lfs使用 5.5.1概述 简书: git-lfs使用 github开发的git扩展，用于实现git对大文件的支持, 可以减少提交的变动量 在检出版本时,根据指针的变化情况下更新对应的大文件.而不是在本地保存所有版本的大文件 5.5.2使用 # 1.mac安装 brew install git-lfs git lfs install # 开启git-lfs功能 # 2.文件追踪 git lfs track # 查看当前的文件追踪模式 git lfs track \"*.mp4\" # 追踪所有的.mp4文件 # 3.提交代码需要将gitattributes文件提交至仓库. 它保存了文件的追踪记录 # 4.可以查看当前跟踪的文件列表 git lfs ls-files # 5.将代码 push 到远程仓库后 git add *.mp4 git commit git push # LFS 跟踪的文件会以『Git LFS』的形式显示: # clone 时 使用'git clone' 或 git lfs clone均可 Copy 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-02-16 16:05:18 "},"笔记/other/npm删除.html":{"url":"笔记/other/npm删除.html","title":"Npm删除","keywords":"","body":"有时候node_modules包特别大，目录层级太深，windows系统删除有时候还报没有管理员权限的错误。右键点击直接删除是删除不了的。 下面给大家介绍一种方法可以快速删除node_modules，让你彻底告别这个苦恼。。。 npm install rimraf -g rimraf node_modules 或者 rmdir /s/q node_modules 删除文件 del filename 清除node_modules缓存 npm cache clean 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-01 17:29:52 "},"笔记/other/npm命令.html":{"url":"笔记/other/npm命令.html","title":"Npm命令","keywords":"","body":"npm 查看安装了哪些包 指令1： npm list --depth=0 –depth 表示深度，我们使用的模块会有依赖，深度为零的时候，不会显示依赖模块 这个指令可以用来 显示 出我们的项目中安装了哪些模块，其实就是 package.json 文件中 的 dependencies 和 devDependencies 的和 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list --depth=0 当然我们可以在加参数 npm list --depth=0 [--dev | --production] 指令2： npm list --depth --global 这个指令用来查看全局安装了哪些工具 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list --depth=0 --global C:\\Users\\by\\AppData\\Roaming\\npm +-- chrome-remote-interface@0.25.4 +-- create-react-app@1.4.0 +-- eslint@4.17.0 +-- jshint@2.9.4 +-- less@2.7.2 +-- live-server@1.2.0 +-- mysql@2.15.0 +-- sass@1.0.0-beta.1 +-- sequelize-auto@0.4.29 +-- vue-cli@2.8.2 `-- webpack@3.6.0 指令3： npm list 这个指令用来查看某个模块是否安装了 PS C:\\Users\\by\\Desktop\\jsPang\\awesomePos> npm list element-ui awesome_pos@1.0.0 C:\\Users\\by\\Desktop\\jsPang\\awesomePos `-- element-ui@2.2.2 官网详情 这篇文章目的在于推荐下几个常用的指令 传送门 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-02-15 23:20:13 "},"笔记/other/吐槽.html":{"url":"笔记/other/吐槽.html","title":"吐槽","keywords":"","body":"天天改bug，代码都不知道在哪，有些不熟悉的模块也要改，遇到问题全靠问，问其他人也都是踢皮球，心累。 代码也乱，除了标准产品，还有客户客开，金格，迈锐思，金山各种第三方，如果是网络、接口问题还好，如果是代码问题，全是压缩构建的代码，找的头昏眼花，找到问题了还不好改。 还得联系客户，有些客户态度也不好，搞得自己跟个客服一样，还得装孙子。 有些客户没办法远程，只能视频，这要我怎么找问题，说又说不清楚，但是这种还必须解决，不能超期，难受。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-02-23 16:25:55 "},"笔记/web前端面试-面试官系列/JavaScript/== _===.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/== _===.html","title":"==  ===","keywords":"","body":"面试官：== 和 ===区别，分别在什么情况使用 一、等于操作符 等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true 前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等 遵循以下规则： 如果任一操作数是布尔值，则将其转换为数值再比较是否相等 let result1 = (true == 1); // true 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等 let result1 = (\"55\" == 55); // true 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较 let obj = {valueOf:function(){return 1}} let result1 = (obj == 1); // true null和undefined相等 let result1 = (null == undefined ); // true 如果有任一操作数是 NaN ，则相等操作符返回 false let result1 = (NaN == NaN ); // false 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true let obj1 = {name:\"xxx\"} let obj2 = {name:\"xxx\"} let result1 = (obj1 == obj2 ); // false 下面进一步做个小结： 两个都为简单类型，字符串和布尔值都会转换成数值，再比较 简单类型与引用类型比较，对象转化成其原始类型的值，再比较 两个都为引用类型，则比较它们是否指向同一个对象 null 和 undefined 相等 存在 NaN 则返回 false 二、全等操作符 全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同 let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同 let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 undefined 和 null 与自身严格相等 let result1 = (null === null) //true let result2 = (undefined === undefined) //true 三、区别 相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换 let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同 let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 null 和 undefined 比较，相等操作符（==）为true，全等为false let result1 = (null == undefined ); // true let result2 = (null === undefined); // false 小结 相等运算符隐藏的类型转换，会带来一些违反直觉的结果 '' == '0' // false 0 == '' // true 0 == '0' // true false == 'false' // false false == '0' // true false == undefined // false false == null // false null == undefined // true ' \\t\\r\\n' == 0 // true 但在比较null的情况的时候，我们一般使用相等操作符== const obj = {}; if(obj.x == null){ console.log(\"1\"); //执行 } 等同于下面写法 if(obj.x === null || obj.x === undefined) { ... } 使用相等操作符（==）的写法明显更加简洁了 所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===） 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/BOM.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/BOM.html","title":"BOM","keywords":"","body":"面试官：说说你对BOM的理解，常见的BOM对象你了解哪些？ 一、是什么 BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象 其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率 浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM。区别如下： 二、window Bom的核心对象是window，它表示浏览器的一个实例 在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象 因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法 var name = 'js每日一题'; function lookName(){ alert(this.name); } console.log(window.name); //js每日一题 lookName(); //js每日一题 window.lookName(); //js每日一题 关于窗口控制方法如下： moveBy(x,y)：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体 moveTo(x,y)：移动窗体左上角到相对于屏幕左上角的(x,y)点 resizeBy(w,h)：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体 resizeTo(w,h)：把窗体宽度调整为w个像素，高度调整为h个像素 scrollTo(x,y)：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置 scrollBy(x,y)： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素 window.open() 既可以导航到一个特定的url，也可以打开一个新的浏览器窗口 如果 window.open() 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL window.open('htttp://www.vue3js.cn','topFrame') ==> window.open() 会返回新窗口的引用，也就是新窗口的 window 对象 const myWin = window.open('http://www.vue3js.cn','myWin') window.close() 仅用于通过 window.open() 打开的窗口 新创建的 window 对象有一个 opener 属性，该属性指向打开他的原始窗口对象 三、location url地址如下： http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents location属性描述如下： 属性名 例子 说明 hash \"#contents\" utl中#后面的字符，没有则返回空串 host www.wrox.com:80 服务器名称和端口号 hostname www.wrox.com 域名，不带端口号 href http://www.wrox.com:80/WileyCDA/?q=javascript#contents 完整url pathname \"/WileyCDA/\" 服务器下面的文件路径 port 80 url的端口号，没有则为空 protocol http: 使用的协议 search ?q=javascript url的查询字符串，通常为？后面的内容 除了 hash之外，只要修改location的一个属性，就会导致页面重新加载新URL location.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载 如果要强制从服务器中重新加载，传递一个参数true即可 四、navigator navigator 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂 下表列出了navigator对象接口定义的属性和方法： 五、screen 保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度 六、history history对象主要用来操作浏览器URL的历史记录，可以通过参数向前，向后，或者向指定URL跳转 常用的属性如下： history.go() 接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转， history.go('maixaofei.com') 当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面 history.go(3) //向前跳转三个记录 history.go(-1) //向后跳转一个记录 history.forward()：向前跳转一个页面 history.back()：向后跳转一个页面 history.length：获取历史记录数 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/Dom.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/Dom.html","title":"Dom","keywords":"","body":"面试官：DOM常见的操作有哪些？ 一、DOM 文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口 它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容 任何 HTML或XML文档都可以用 DOM表示为一个由节点构成的层级结构 节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，如下所示： Page Hello World! DOM像原子包含着亚原子微粒那样，也有很多类型的DOM节点包含着其他类型的节点。接下来我们先看看其中的三种： content 上述结构中，div、p就是元素节点，content就是文本节点，title就是属性节点 二、操作 日常前端开发，我们都离不开DOM操作 在以前，我们使用Jquery，zepto等库来操作DOM，之后在vue，Angular，React等框架出现后，我们通过操作数据来控制DOM（绝大多数时候），越来越少的去直接操作DOM 但这并不代表原生操作不重要。相反，DOM操作才能有助于我们理解框架深层的内容 下面就来分析DOM常见的操作，主要分为： 创建节点 查询节点 更新节点 添加节点 删除节点 创建节点 createElement 创建新元素，接受一个参数，即要创建元素的标签名 const divEl = document.createElement(\"div\"); createTextNode 创建一个文本节点 const textEl = document.createTextNode(\"content\"); createDocumentFragment 用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到DOM中 const fragment = document.createDocumentFragment(); 当请求把一个DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment自身，而是它的所有子孙节点 createAttribute 创建属性节点，可以是自定义属性 const dataAttribute = document.createAttribute('custom'); consle.log(dataAttribute); 获取节点 querySelector 传入任何有效的css 选择器，即可选中单个 DOM元素（首个）： document.querySelector('.element') document.querySelector('#element') document.querySelector('div') document.querySelector('[name=\"username\"]') document.querySelector('div + p > span') 如果页面上没有指定的元素时，返回 null querySelectorAll 返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表 const notLive = document.querySelectorAll(\"p\"); 需要注意的是，该方法返回的是一个 NodeList的静态实例，它是一个静态的“快照”，而非“实时”的查询 关于获取DOM元素的方法还有如下，就不一一述说 document.getElementById('id属性值');返回拥有指定id的对象的引用 document.getElementsByClassName('class属性值');返回拥有指定class的对象集合 document.getElementsByTagName('标签名');返回拥有指定标签名的对象集合 document.getElementsByName('name属性值'); 返回拥有指定名称的对象结合 document/element.querySelector('CSS选择器'); 仅返回第一个匹配的元素 document/element.querySelectorAll('CSS选择器'); 返回所有匹配的元素 document.documentElement; 获取页面中的HTML标签 document.body; 获取页面中的BODY标签 document.all['']; 获取页面中的所有元素节点的对象集合型 除此之外，每个DOM元素还有parentNode、childNodes、firstChild、lastChild、nextSibling、previousSibling属性，关系图如下图所示 更新节点 innerHTML 不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树 // 获取... var p = document.getElementById('p'); // 设置文本为abc: p.innerHTML = 'ABC'; // ABC // 设置HTML: p.innerHTML = 'ABC RED XYZ'; // ...的内部结构已修改 innerText、textContent 自动对字符串进行HTML编码，保证无法设置任何HTML标签 // 获取... var p = document.getElementById('p-id'); // 设置文本: p.innerText = 'alert(\"Hi\")'; // HTML被自动编码，无法设置一个节点: // &lt;script&gt;alert(\"Hi\")&lt;/script&gt; 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本 style DOM节点的style属性对应所有的CSS，可以直接获取或设置。遇到-需要转化为驼峰命名 // 获取... const p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; // 驼峰命名 p.style.paddingTop = '2em'; 添加节点 innerHTML 如果这个DOM节点是空的，例如，，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于添加了新的DOM节点 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点 appendChild 把一个子节点添加到父节点的最后一个子节点 举个例子 JavaScript Java Python Scheme 添加一个p元素 const js = document.getElementById('js') js.innerHTML = \"JavaScript\" const list = document.getElementById('list'); list.appendChild(js); 现在HTML结构变成了下面 Java Python Scheme JavaScript 上述代码中，我们是获取DOM元素后再进行添加操作，这个js节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置 如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置 const list = document.getElementById('list'), const haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); insertBefore 把子节点插入到指定的位置，使用方法如下： parentElement.insertBefore(newElement, referenceElement) 子节点会插入到referenceElement之前 setAttribute 在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值 const div = document.getElementById('id') div.setAttribute('class', 'white');//第一个参数属性名，第二个参数属性值。 删除节点 删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉 // 拿到待删除节点: const self = document.getElementById('to-be-removed'); // 拿到父节点: const parent = self.parentElement; // 删除: const removed = parent.removeChild(self); removed === self; // true 删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置 相关链接 https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/ajax.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/ajax.html","title":"Ajax","keywords":"","body":"面试官：ajax原理是什么？如何实现？ 一、是什么 AJAX全称(Async Javascript and XML) 即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面 流程图如下： 下面举个例子： 领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作 Ajax请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李 浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作 二、实现过程 实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤： 创建 Ajax的核心对象 XMLHttpRequest对象 通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接 构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端 通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态 接受并处理服务端向客户端响应的数据结果 将处理结果更新到 HTML页面中 创建XMLHttpRequest对象 通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象 const xhr = new XMLHttpRequest(); 与服务器建立连接 通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接 xhr.open(method, url, [async][, user][, password]) 参数说明： method：表示当前的请求方式，常见的有GET、POST url：服务端地址 async：布尔值，表示是否异步执行操作，默认为true user: 可选的用户名用于认证用途；默认为`null password: 可选的密码用于认证用途，默认为`null 给服务端发送数据 通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端 xhr.send([body]) body: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null 如果使用GET请求发送数据的时候，需要注意如下： 将请求数据添加到open()方法中的url地址中 发送请求数据中的send()方法中参数设置为null 绑定onreadystatechange事件 onreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState , 关于XMLHttpRequest.readyState属性有五个状态，如下图显示 只要 readyState属性值一变化，就会触发一次 readystatechange 事件 XMLHttpRequest.responseText属性用于接收服务器端的响应结果 举个例子： const request = new XMLHttpRequest() request.onreadystatechange = function(e){ if(request.readyState === 4){ // 整个请求过程完毕 if(request.status >= 200 && request.status =400){ console.log(\"错误信息：\" + request.status) } } } request.open('POST','http://xxxx') request.send() 三、封装 通过上面对XMLHttpRequest对象的了解，下面来封装一个简单的ajax请求 //封装一个ajax请求 function ajax(options) { //创建XMLHttpRequest对象 const xhr = new XMLHttpRequest() //初始化参数的内容 options = options || {} options.type = (options.type || 'GET').toUpperCase() options.dataType = options.dataType || 'json' const params = options.data //发送请求 if (options.type === 'GET') { xhr.open('GET', options.url + '?' + params, true) xhr.send(null) } else if (options.type === 'POST') { xhr.open('POST', options.url, true) xhr.send(params) //接收请求 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { let status = xhr.status if (status >= 200 && status 使用方式如下 ajax({ type: 'post', dataType: 'json', data: {}, url: 'https://xxxx', success: function(text,xml){//请求成功后的回调函数 console.log(text) }, fail: function(status){////请求失败后的回调函数 console.log(status) } }) 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/array_api.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/array_api.html","title":"Array Api","keywords":"","body":"面试官：数组的常用方法有哪些？ 一、操作方法 数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 下面对数组常用的操作方法做一个归纳 增 下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响 push() unshift() splice() concat() push() push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度 let colors = []; // 创建一个数组 let count = colors.push(\"red\", \"green\"); // 推入两项 console.log(count) // 2 unshift() unshift()在数组开头添加任意多个值，然后返回新的数组长度 let colors = new Array(); // 创建一个数组 let count = colors.unshift(\"red\", \"green\"); // 从数组开头推入两项 alert(count); // 2 splice 传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组 let colors = [\"red\", \"green\", \"blue\"]; let removed = colors.splice(1, 0, \"yellow\", \"orange\") console.log(colors) // red,yellow,orange,green,blue console.log(removed) // [] concat() 首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组 let colors = [\"red\", \"green\", \"blue\"]; let colors2 = colors.concat(\"yellow\", [\"black\", \"brown\"]); console.log(colors); // [\"red\", \"green\",\"blue\"] console.log(colors2); // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"] 删 下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop() pop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项 let colors = [\"red\", \"green\"] let item = colors.pop(); // 取得最后一项 console.log(item) // green console.log(colors.length) // 1 shift() shift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项 let colors = [\"red\", \"green\"] let item = colors.shift(); // 取得第一项 console.log(item) // red console.log(colors.length) // 1 splice() 传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组 let colors = [\"red\", \"green\", \"blue\"]; let removed = colors.splice(0,1); // 删除第一项 console.log(colors); // green,blue console.log(removed); // red，只有一个元素的数组 slice() slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组 let colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; let colors2 = colors.slice(1); let colors3 = colors.slice(1, 4); console.log(colors) // red,green,blue,yellow,purple concole.log(colors2); // green,blue,yellow,purple concole.log(colors3); // green,blue,yellow 改 即修改原来数组的内容，常用splice splice() 传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响 let colors = [\"red\", \"green\", \"blue\"]; let removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两个值，删除一个元素 console.log(colors); // red,red,purple,blue console.log(removed); // green，只有一个元素的数组 查 即查找元素，返回元素坐标或者元素值 indexOf() includes() find() indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回 -1 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.indexOf(4) // 3 includes() 返回要查找的元素在数组中的位置，找到返回true，否则false let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.includes(4) // true find() 返回第一个匹配的元素 const people = [ { name: \"Matt\", age: 27 }, { name: \"Nicholas\", age: 29 } ]; people.find((element, index, array) => element.age 二、排序方法 数组有两个方法可以用来对元素重新排序： reverse() sort() reverse() 顾名思义，将数组元素方向反转 let values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); // 5,4,3,2,1 sort() sort()方法接受一个比较函数，用于判断哪个值应该排在前面 function compare(value1, value2) { if (value1 value2) { return 1; } else { return 0; } } let values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values); // 0,1,5,10,15 三、转换方法 常见的转换方法有： join() join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串 let colors = [\"red\", \"green\", \"blue\"]; alert(colors.join(\",\")); // red,green,blue alert(colors.join(\"||\")); // red||green||blue 四、迭代方法 常用来迭代数组的方法（都不改变原数组）有如下： some() every() forEach() filter() map() some() 对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let someResult = numbers.every((item, index, array) => item > 2); console.log(someResult) // true every() 对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let everyResult = numbers.every((item, index, array) => item > 2); console.log(everyResult) // false forEach() 对数组每一项都运行传入的函数，没有返回值 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach((item, index, array) => { // 执行某些操作 }); filter() 对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let filterResult = numbers.filter((item, index, array) => item > 2); console.log(filterResult); // 3,4,5,4,3 map() 对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let mapResult = numbers.map((item, index, array) => item * 2); console.log(mapResult) // 2,4,6,8,10,8,6,4,2 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/bind_call_apply.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/bind_call_apply.html","title":"Bind Call Apply","keywords":"","body":"面试官：bind、call、apply 区别？如何实现一个bind? 一、作用 call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向 那么什么情况下需要改变this的指向呢？下面举个例子 const name=\"lucy\"; const obj={ name:\"martin\", say:function () { console.log(this.name); } }; obj.say(); //martin，this指向obj对象 setTimeout(obj.say,0); //lucy，this指向window对象 从上面可以看到，正常情况say方法输出martin 但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy 我们实际需要的是this指向obj对象，这时候就需要该改变this指向了 setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象 二、区别 下面再来看看apply、call、bind的使用 apply apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入 改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args){ console.log(this,args); } let obj = { myname:\"张三\" } fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组； fn(1,2) // this指向window 当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.apply(null,[1,2]); // this指向window fn.apply(undefined,[1,2]); // this指向window call call方法的第一个参数也是this的指向，后面传入的是一个参数列表 跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 function fn(...args){ console.log(this,args); } let obj = { myname:\"张三\" } fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组； fn(1,2) // this指向window 同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中) fn.call(null,[1,2]); // this指向window fn.call(undefined,[1,2]); // this指向window bind bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入) 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数 function fn(...args){ console.log(this,args); } let obj = { myname:\"张三\" } const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次 bindFn(1,2) // this指向obj fn(1,2) // this指向window 小结 从上面可以看到，apply、call、bind三者的区别在于： 三者都可以改变函数的this对象指向 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入 bind是返回绑定this之后的函数，apply、call 则是立即执行 三、实现 实现bind的步骤，我们可以分解成为三部分： 修改this指向 动态传递参数 // 方式一：只在bind中传递函数参数 fn.bind(obj,1,2)() // 方式二：在bind中传递函数参数，也在返回函数中传递参数 fn.bind(obj,1)(2) 兼容new关键字 整体实现代码如下： Function.prototype.myBind = function (context) { // 判断调用对象是否为函数 if (typeof this !== \"function\") { throw new TypeError(\"Error\"); } // 获取参数 const args = [...arguments].slice(1), fn = this; return function Fn() { // 根据调用方式，传入不同绑定值 return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments)); } } 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/cache.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/cache.html","title":"Cache","keywords":"","body":"面试官：Javascript本地存储的方式有哪些？区别及应用场景？ 一、方式 javaScript本地缓存的方法我们主要讲述以下四种： cookie sessionStorage localStorage indexedDB cookie Cookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题 作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成 但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站 关于cookie常用的属性如下： Expires 用于设置 Cookie 的过期时间 Expires=Wed, 21 Oct 2015 07:28:00 GMT Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高） Max-Age=604800 Domain指定了 Cookie 可以送达的主机名 Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部 Path=/docs # /docs/Web/ 下的资源会带 Cookie 首部 标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端 通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存 关于cookie的使用如下： document.cookie = '名字=值'; 关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie Set-Cookie:name=aa; domain=aa.net; path=/ # 服务端设置 document.cookie =name=bb; domain=aa.net; path=/ # 客户端设置 最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除 localStorage HTML5新方法，IE8及以上浏览器都兼容 特点 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 存储的信息在同一域中是共享的 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。 大小：5M（跟浏览器厂商有关系） localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 受同源策略的限制 下面再看看关于localStorage的使用 设置 localStorage.setItem('username','cfangxu'); 获取 localStorage.getItem('username') 获取键名 localStorage.key(0) //获取第一个键名 删除 localStorage.removeItem('username') 一次性清除所有存储 localStorage.clear() localStorage 也不是完美的，它有两个缺点： 无法像Cookie一样设置过期时间 只能存入字符串，无法直接存对象 localStorage.setItem('key', {name: 'value'}); console.log(localStorage.getItem('key')); // '[object, Object]' sessionStorage sessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据 扩展的前端存储方式 indexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索 虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案 优点： 储存量理论上没有上限 所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时 原生支持储存JS的对象 是个正经的数据库，意味着数据库能干的事它都能干 缺点： 操作非常繁琐 本身有一定门槛 关于indexedDB的使用基本使用步骤如下： 打开数据库并且开始一个事务 创建一个 object store 构建一个请求来执行一些数据库操作，像增加或提取数据等。 通过监听正确类型的 DOM 事件以等待操作完成。 在操作结果上进行一些操作（可以在 request对象中找到） 关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度 二、区别 关于cookie、sessionStorage、localStorage三者的区别主要如下： 存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 三、应用场景 在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择： 标记用户与跟踪用户行为的情况，推荐使用cookie 适合长期保存在本地的数据（令牌），推荐使用localStorage 敏感账号一次性登录，推荐使用sessionStorage 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB 相关连接 https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ https://github.com/chenstarx/GoDB.js 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/closure.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/closure.html","title":"Closure","keywords":"","body":"面试官：说说你对闭包的理解？闭包使用场景 一、是什么 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域 在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁 下面给出一个简单的例子 function init() { var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 } displayName(); } init(); displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量 二、使用场景 任何闭包的使用场景都离不开这两点： 创建私有变量 延长变量的生命周期 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的 下面举个例子： 在页面上添加一些可以调整字号的按钮 function makeSizer(size) { return function() { document.body.style.fontSize = size + 'px'; }; } var size12 = makeSizer(12); var size14 = makeSizer(14); var size16 = makeSizer(16); document.getElementById('size-12').onclick = size12; document.getElementById('size-14').onclick = size14; document.getElementById('size-16').onclick = size16; 柯里化函数 柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用 // 假设我们有一个求长方形面积的函数 function getArea(width, height) { return width * height } // 如果我们碰到的长方形的宽老是10 const area1 = getArea(10, 20) const area2 = getArea(10, 30) const area3 = getArea(10, 40) // 我们可以使用闭包柯里化这个计算面积的函数 function getArea(width) { return height => { return width * height } } const getTenWidthArea = getArea(10) // 之后碰到宽度为10的长方形就可以这样计算面积 const area1 = getTenWidthArea(20) // 而且如果遇到宽度偶尔变化也可以轻松复用 const getTwentyWidthArea = getArea(20) 使用闭包模拟私有方法 在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法 下面举个例子： var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); var Counter1 = makeCounter(); var Counter2 = makeCounter(); console.log(Counter1.value()); /* logs 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* logs 2 */ Counter1.decrement(); console.log(Counter1.value()); /* logs 1 */ console.log(Counter2.value()); /* logs 0 */ 上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式 两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量 其他 例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期 三、注意事项 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。 原因在于每个对象的创建，方法都会被重新赋值 function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; } 上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function() { return this.name; }; MyObject.prototype.getMessage = function() { return this.message; }; 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/context_stack.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/context_stack.html","title":"Context Stack","keywords":"","body":"面试官：JavaScript中执行上下文和执行栈是什么？ 一、执行上下文 简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中 执行上下文的类型分为三种： 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 下面给出全局上下文和函数上下文的例子： 紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问 可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问 二、生命周期 执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段 创建阶段 创建阶段即当函数被调用，但未执行任何其内部代码之前 创建阶段做了三件事： 确定 this 的值，也被称为 This Binding LexicalEnvironment（词法环境） 组件被创建 VariableEnvironment（变量环境） 组件被创建 伪代码如下： ExecutionContext = { ThisBinding = , // 确定this LexicalEnvironment = { ... }, // 词法环境 VariableEnvironment = { ... }, // 变量环境 } This Binding 确定this的值我们前面讲到，this的值是在执行的时候才能确认，定义的时候不能确认 词法环境 词法环境有两个组成部分： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为null，有一个全局对象，this 的值指向这个全局对象 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境 伪代码如下： GlobalExectionContext = { // 全局执行上下文 LexicalEnvironment: { // 词法环境 EnvironmentRecord: { // 环境记录 Type: \"Object\", // 全局环境 // 标识符绑定在这里 outer: // 对外部环境的引用 } } FunctionExectionContext = { // 函数执行上下文 LexicalEnvironment: { // 词法环境 EnvironmentRecord: { // 环境记录 Type: \"Declarative\", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: } } 变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性 在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定 举个例子 let a = 20; const b = 30; var c; function multiply(e, f) { var g = 20; return e * f * g; } c = multiply(20, 30); 执行上下文如下： GlobalExectionContext = { ThisBinding: , LexicalEnvironment: { // 词法环境 EnvironmentRecord: { Type: \"Object\", // 标识符绑定在这里 a: , b: , multiply: } outer: }, VariableEnvironment: { // 变量环境 EnvironmentRecord: { Type: \"Object\", // 标识符绑定在这里 c: undefined, } outer: } } FunctionExectionContext = { ThisBinding: , LexicalEnvironment: { EnvironmentRecord: { Type: \"Declarative\", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: }, VariableEnvironment: { EnvironmentRecord: { Type: \"Declarative\", // 标识符绑定在这里 g: undefined }, outer: } } 留意上面的代码，let和const定义的变量a和b在创建阶段没有被赋值，但var声明的变量从在创建阶段被赋值为undefined 这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中 但变量会被初始化为undefined(var声明的情况下)和保持uninitialized(未初始化状态)(使用let和const声明的情况下) 这就是变量提升的实际原因 执行阶段 在这阶段，执行变量赋值、代码执行 如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值 回收阶段 执行上下文出栈等待虚拟机回收执行上下文 二、执行栈 执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文 当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中 每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中 引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文 举个例子： let a = 'Hello World!'; function first() { console.log('Inside first function'); second(); console.log('Again inside first function'); } function second() { console.log('Inside second function'); } first(); console.log('Inside Global Execution Context'); 转化成图的形式 简单分析一下流程： 创建全局上下文请压入执行栈 first函数被调用，创建函数执行上下文并压入栈 执行first函数过程遇到second函数，再创建一个函数执行上下文并压入栈 second函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first函数 first函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文 所有代码执行完毕，全局上下文也会被推出栈中，程序结束 参考文献 https://zhuanlan.zhihu.com/p/107552264 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/continue_to_upload.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/continue_to_upload.html","title":"Continue To Upload","keywords":"","body":"面试官：大文件上传如何做断点续传？ 一、是什么 不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂 文件上传简单，文件变大就复杂 上传大文件时，以下几个变量会影响我们的用户体验 服务器处理数据的能力 请求超时 网络波动 上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等 为了解决上述问题，我们需要对大文件上传单独处理 这里涉及到分片上传及断点续传两个概念 分片上传 分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传 如下图 上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件 大致流程如下： 将需要上传的文件按照一定的分割规则，分割成相同大小的数据块； 初始化一个分片上传任务，返回本次分片上传唯一标识； 按照一定的策略（串行或并行）发送各个分片数据块； 发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件 断点续传 断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分 每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度 一般实现方式有两种： 服务器端返回，告知从哪开始 浏览器端自行处理 上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可 如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可 二、实现思路 整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕 下面的内容都是伪代码 读取文件内容： const input = document.querySelector('input'); input.addEventListener('change', function() { var file = this.files[0]; }); 可以使用md5实现文件的唯一性 const md5code = md5(file); 然后开始对文件进行分割 var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.addEventListener(\"load\", function(e) { //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割， var slice = e.target.result.slice(0, 10*1024*1024); }); h5上传一个（一片） const formdata = new FormData(); formdata.append('0', slice); //这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案 formdata.append('filename', file.filename); var xhr = new XMLHttpRequest(); xhr.addEventListener('load', function() { //xhr.responseText }); xhr.open('POST', ''); xhr.send(formdata); xhr.addEventListener('progress', updateProgress); xhr.upload.addEventListener('progress', updateProgress); function updateProgress(event) { if (event.lengthComputable) { //进度条 } } 这里给出常见的图片和视频的文件类型判断 function checkFileType(type, file, back) { /** * type png jpg mp4 ... * file input.change=> this.files[0] * back callback(boolean) */ var args = arguments; if (args.length != 3) { back(0); } var type = args[0]; // type = '(png|jpg)' , 'png' var file = args[1]; var back = typeof args[2] == 'function' ? args[2] : function() {}; if (file.type == '') { // 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型 var imgType = [ 'ff d8 ff', //jpg '89 50 4e', //png '0 0 0 14 66 74 79 70 69 73 6F 6D', //mp4 '0 0 0 18 66 74 79 70 33 67 70 35', //mp4 '0 0 0 0 66 74 79 70 33 67 70 35', //mp4 '0 0 0 0 66 74 79 70 4D 53 4E 56', //mp4 '0 0 0 0 66 74 79 70 69 73 6F 6D', //mp4 '0 0 0 18 66 74 79 70 6D 70 34 32', //m4v '0 0 0 0 66 74 79 70 6D 70 34 32', //m4v '0 0 0 14 66 74 79 70 71 74 20 20', //mov '0 0 0 0 66 74 79 70 71 74 20 20', //mov '0 0 0 0 6D 6F 6F 76', //mov '4F 67 67 53 0 02', //ogg '1A 45 DF A3', //ogg '52 49 46 46 x x x x 41 56 49 20', //avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54) ]; var typeName = [ 'jpg', 'png', 'mp4', 'mp4', 'mp4', 'mp4', 'mp4', 'm4v', 'm4v', 'mov', 'mov', 'mov', 'ogg', 'ogg', 'avi', ]; var sliceSize = /png|jpg|jpeg/.test(type) ? 3 : 12; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.addEventListener(\"load\", function(e) { var slice = e.target.result.slice(0, sliceSize); reader = null; if (slice && slice.byteLength == sliceSize) { var view = new Uint8Array(slice); var arr = []; view.forEach(function(v) { arr.push(v.toString(16)); }); view = null; var idx = arr.join(' ').indexOf(imgType); if (idx > -1) { back(typeName[idx]); } else { arr = arr.map(function(v) { if (i > 3 && i -1) { back(typeName[idx]); } else { back(false); } } } else { back(false); } }); } else { var type = file.name.match(/\\.(\\w+)$/)[1]; back(type); } } 调用方法如下 checkFileType('(mov|mp4|avi)',file,function(fileType){ // fileType = mp4, // 如果file的类型不在枚举之列，则返回false }); 上面上传文件的一步，可以改成： formdata.append('filename', md5code+'.'+fileType); 有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断 后端主要做的内容为：根据前端传给后台的md5值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传 如果想要暂停切片的上传，可以使用XMLHttpRequest的 abort方法 三、使用场景 大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度 网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part 流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见 小结 当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如 切片上传失败怎么办 上传过程中刷新页面怎么办 如何进行并行上传 切片什么时候按数量切，什么时候按大小切 如何结合 Web Worker 处理大文件上传 如何实现秒传 人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 ~_~ 参考文献 https://segmentfault.com/a/1190000009448892 https://baike.baidu.com/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/copy.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/copy.html","title":"Copy","keywords":"","body":"面试官：深拷贝浅拷贝的区别？如何实现一个深拷贝？ 一、数据类型存储 前面文章我们讲到，JavaScript中存在两大数据类型： 基本类型 引用类型 基本类型数据保存在在栈内存中 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中 二、浅拷贝 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 下面简单实现一个浅拷贝 function shallowClone(obj) { const newObj = {}; for(let prop in obj) { if(obj.hasOwnProperty(prop)){ newObj[prop] = obj[prop]; } } return newObj; } 在JavaScript中，存在浅拷贝的现象有： Object.assign Array.prototype.slice(), Array.prototype.concat() 使用拓展运算符实现的复制 Object.assign var obj = { age: 18, nature: ['smart', 'good'], names: { name1: 'fx', name2: 'xka' }, love: function () { console.log('fx is a great girl') } } var newObj = Object.assign({}, fxObj); slice() const fxArr = [\"One\", \"Two\", \"Three\"] const fxArrs = fxArr.slice(0) fxArrs[1] = \"love\"; console.log(fxArr) // [\"One\", \"Two\", \"Three\"] console.log(fxArrs) // [\"One\", \"love\", \"Three\"] concat() const fxArr = [\"One\", \"Two\", \"Three\"] const fxArrs = fxArr.concat() fxArrs[1] = \"love\"; console.log(fxArr) // [\"One\", \"Two\", \"Three\"] console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 拓展运算符 const fxArr = [\"One\", \"Two\", \"Three\"] const fxArrs = [...fxArr] fxArrs[1] = \"love\"; console.log(fxArr) // [\"One\", \"Two\", \"Three\"] console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 三、深拷贝 深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 _.cloneDeep() const _ = require('lodash'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f);// false jQuery.extend() const $ = require('jquery'); const obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; const obj2 = $.extend(true, {}, obj1); console.log(obj1.b.f === obj2.b.f); // false JSON.stringify() const obj2=JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数 const obj = { name: 'A', name1: undefined, name3: function() {}, name4: Symbol('A') } const obj2 = JSON.parse(JSON.stringify(obj)); console.log(obj2); // {name: \"A\"} 循环递归 function deepClone(obj, hash = new WeakMap()) { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== \"object\") return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; } 四、区别 下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别 从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样 浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象 // 浅拷贝 const obj1 = { name : 'init', arr : [1,[2,3],4], }; const obj3=shallowClone(obj1) // 一个浅拷贝方法 obj3.name = \"update\"; obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存 console.log('obj1',obj1) // obj1 { name: 'init', arr: [ 1, [ 5, 6, 7 ], 4 ] } console.log('obj3',obj3) // obj3 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] } 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 // 深拷贝 const obj1 = { name : 'init', arr : [1,[2,3],4], }; const obj4=deepClone(obj1) // 一个深拷贝方法 obj4.name = \"update\"; obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存 console.log('obj1',obj1) // obj1 { name: 'init', arr: [ 1, [ 2, 3 ], 4 ] } console.log('obj4',obj4) // obj4 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] } 小结 前提为拷贝类型为引用类型的情况下： 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/data_type.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/data_type.html","title":"Data Type","keywords":"","body":"面试官：说说JavaScript中的数据类型？存储上的差别？ 前言 在JavaScript中，我们可以分成两种类型： 基本类型 复杂类型 两种类型的区别是：存储位置不同 一、基本类型 基本类型主要为以下6种： Number String Boolean Undefined null symbol Number 数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头） let intNum = 55 // 10进制的55 let num1 = 070 // 8进制的56 let hexNum1 = 0xA //16进制的10 浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示 let floatNum1 = 1.1; let floatNum2 = 0.1; let floatNum3 = .1; // 有效，但不推荐 let floatNum = 3.125e7; // 等于 31250000 在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误） console.log(0/0); // NaN console.log(-0/+0); // NaN Undefined Undefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值 let message; console.log(message == undefined); // true 包含undefined 值的变量跟未定义变量是有区别的 let message; // 这个变量被声明了，只是值为 undefined console.log(message); // \"undefined\" console.log(age); // 没有声明过这个变量，报错 String 字符串可以使用双引号（\"）、单引号（'）或反引号（`）标示 let firstName = \"John\"; let lastName = 'Jacob'; let lastName = `Jingleheimerschmidt` 字符串是不可变的，意思是一旦创建，它们的值就不能变了 let lang = \"Java\"; lang = lang + \"Script\"; // 先销毁再创建 Null Null类型同样只有一个值，即特殊值 null 逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 \"object\" 的原因 let car = null; console.log(typeof car); // \"object\" undefined 值是由 null值派生而来 console.log(null == undefined); // true 只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量 Boolean Boolean（布尔值）类型有两个字面值： true 和false 通过Boolean可以将其他类型的数据转化成布尔值 规则如下： 数据类型 转换为 true 的值 转换为 false 的值 String 非空字符串 \"\" Number 非零数值（包括无穷值） 0 、 NaN Object 任意对象 null Undefined N/A （不存在） undefined Symbol Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险 let genericSymbol = Symbol(); let otherGenericSymbol = Symbol(); console.log(genericSymbol == otherGenericSymbol); // false let fooSymbol = Symbol('foo'); let otherFooSymbol = Symbol('foo'); console.log(fooSymbol == otherFooSymbol); // false 二、引用类型 复杂类型统称为Object，我们这里主要讲述下面三种： Object Array Function Object 创建object常用方式为对象字面量表示法，属性名可以是字符串或数值 let person = { name: \"Nicholas\", \"age\": 29, 5: true }; Array JavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长 let colors = [\"red\", 2, {age: 20 }] colors.push(2) Function 函数实际上是对象，每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样 函数存在三种常见的表达方式： 函数声明 // 函数声明 function sum (num1, num2) { return num1 + num2; } 函数表达式 let sum = function(num1, num2) { return num1 + num2; }; 箭头函数 函数声明和函数表达式两种方式 let sum = (num1, num2) => { return num1 + num2; }; 其他引用类型 除了上述说的三种之外，还包括Date、RegExp、Map、Set等...... 三、存储区别 基本数据类型和引用数据类型存储在内存中的位置不同： 基本数据类型存储在栈中 引用类型的对象存储于堆中 当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值 下面来举个例子 基本类型 let a = 10; let b = a; // 赋值操作 b = 20; console.log(a); // 10值 a的值为一个基本类型，是存储在栈中，将a的值赋给b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址 下图演示了基本类型赋值的过程： 引用类型 var obj1 = {} var obj2 = obj1; obj2.name = \"Xxx\"; console.log(obj1.name); // xxx 引用类型数据存放在内对内中，每个堆内存中有一个引用地址，该引用地址存放在栈中 obj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会对obj1产生影响 下图演示这个引用类型赋值过程 小结 声明变量时不同的内存地址分配： 简单类型的值存放在栈中，在栈中存放的是对应的值 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址 不同的类型数据导致赋值变量时的不同： 简单类型赋值，是生成相同的值，两个对象对应不同的地址 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/debounce_throttle.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/debounce_throttle.html","title":"Debounce Throttle","keywords":"","body":"面试官：什么是防抖和节流？有什么区别？如何实现？ 一、是什么 本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻: 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制 电梯第一个人进来后，15秒后准时运送一次，这是节流 电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖 代码实现 节流 完成节流可以使用时间戳与定时器的写法 使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行 function throttled1(fn, delay = 500) { let oldtime = Date.now() return function (...args) { let newtime = Date.now() if (newtime - oldtime >= delay) { fn.apply(null, args) oldtime = Date.now() } } } 使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行 function throttled2(fn, delay = 500) { let timer = null return function (...args) { if (!timer) { timer = setTimeout(() => { fn.apply(this, args) timer = null }, delay); } } } 可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下 function throttled(fn, delay) { let timer = null let starttime = Date.now() return function () { let curTime = Date.now() // 当前时间 let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间 let context = this let args = arguments clearTimeout(timer) if (remaining 防抖 简单版本的实现 function debounce(func, wait) { let timeout; return function () { let context = this; // 保存this指向 let args = arguments; // 拿到event对象 clearTimeout(timeout) timeout = setTimeout(function(){ func.apply(context, args) }, wait); } } 防抖如果需要立即执行，可加入第三个参数用于判断，实现如下： function debounce(func, wait, immediate) { let timeout; return function () { let context = this; let args = arguments; if (timeout) clearTimeout(timeout); // timeout 不为null if (immediate) { let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发 timeout = setTimeout(function () { timeout = null; }, wait) if (callNow) { func.apply(context, args) } } else { timeout = setTimeout(function () { func.apply(context, args) }, wait); } } } 二、区别 相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率。节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次 例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次 如下图所示： 三、应用场景 防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/event_Model.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/event_Model.html","title":"Event Model","keywords":"","body":"面试官：说说JavaScript中的事件模型 一、事件与事件流 javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等 由于DOM是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念 事件流都会经历三个阶段： 事件捕获阶段(capture phase) 处于目标阶段(target phase) 事件冒泡阶段(bubbling phase) 事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点 Event Bubbling Click Me 然后，我们给button和它的父元素，加入点击事件 var button = document.getElementById('clickMe'); button.onclick = function() { console.log('1.Button'); }; document.body.onclick = function() { console.log('2.body'); }; document.onclick = function() { console.log('3.document'); }; window.onclick = function() { console.log('4.window'); }; 点击按钮，输出如下 1.button 2.body 3.document 4.window 点击事件首先在button元素上发生，然后逐级向上传播 事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件 二、事件模型 事件模型可以分为三种： 原始事件模型（DOM0级） 标准事件模型（DOM2级） IE事件模型（基本不用） 原始事件模型 事件绑定监听函数比较简单, 有两种方式： HTML代码中直接绑定 通过JS代码绑定 var btn = document.getElementById('.btn'); btn.onclick = fun; 特性 绑定速度快 DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行 只支持冒泡，不支持捕获 同一个类型的事件只能绑定一次 var btn = document.getElementById('.btn'); btn.onclick = fun2; 如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个btn元素绑定2个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件 删除 DOM0 级事件处理程序只要将对应事件属性置为null即可 btn.onclick = null; 标准事件模型 在该事件模型中，一次事件共有三个过程: 事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行 事件绑定监听函数的方式如下: addEventListener(eventType, handler, useCapture) 事件移除监听函数的方式如下: removeEventListener(eventType, handler, useCapture) 参数如下： eventType指定事件类型(不要加on) handler是事件处理函数 useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致 举个例子： var btn = document.getElementById('.btn'); btn.addEventListener(‘click’, showMessage, false); btn.removeEventListener(‘click’, showMessage, false); 特性 可以在一个DOM元素上绑定多个事件处理器，各自并不会冲突 btn.addEventListener(‘click’, showMessage1, false); btn.addEventListener(‘click’, showMessage2, false); btn.addEventListener(‘click’, showMessage3, false); 执行时机 当第三个参数(useCapture)设置为true就在捕获过程中执行，反之在冒泡过程中执行处理函数 下面举个例子： Click Me! 设置点击事件 var div = document.getElementById('div'); var p = document.getElementById('p'); function onClickFn (event) { var tagName = event.currentTarget.tagName; var phase = event.eventPhase; console.log(tagName, phase); } div.addEventListener('click', onClickFn, false); p.addEventListener('click', onClickFn, false); 上述使用了eventPhase，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段 点击Click Me!，输出如下 P 3 DIV 3 可以看到，p和div都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的p率先做出响应 如果把第三个参数都改为true div.addEventListener('click', onClickFn, true); p.addEventListener('click', onClickFn, true); 输出如下 DIV 1 P 1 两者都是在捕获阶段响应事件，所以div比p标签先做出响应 IE事件模型 IE事件模型共有两个过程: 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。 事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行 事件绑定监听函数的方式如下: attachEvent(eventType, handler) 事件移除监听函数的方式如下: detachEvent(eventType, handler) 举个例子： var btn = document.getElementById('.btn'); btn.attachEvent(‘onclick’, showMessage); btn.detachEvent(‘onclick’, showMessage); 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/event_agent.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/event_agent.html","title":"Event Agent","keywords":"","body":"面试官：解释下什么是事件代理？应用场景？ 一、是什么 事件代理，俗地来讲，就是把一个元素响应事件（click、keydown......）的函数委托到另一个元素 前面讲到，事件流的都会经过三个阶段： 捕获阶段 -> 目标阶段 -> 冒泡阶段，而事件委托就是在冒泡阶段完成 事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素 当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数 下面举个例子： 比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取 较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学 在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM元素，而出去统一领取快递的宿舍长就是代理的元素 所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个 二、应用场景 如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件 item 1 item 2 item 3 ...... item n 如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的 // 获取目标元素 const lis = document.getElementsByTagName(\"li\") // 循环遍历绑定事件 for (let i = 0; i 这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素 // 给父层元素绑定事件 document.getElementById('list').addEventListener('click', function (e) { // 兼容性处理 var event = e || window.event; var target = event.target || event.srcElement; // 判断是否匹配目标元素 if (target.nodeName.toLocaleLowerCase === 'li') { console.log('the content is: ', target.innerHTML); } }); 还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件 但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件 如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的 举个例子： 下面html结构中，点击input可以动态添加元素 item 1 item 2 item 3 item 4 使用事件委托 const oBtn = document.getElementById(\"btn\"); const oUl = document.getElementById(\"ul1\"); const num = 4; //事件委托，添加的子元素也有事件 oUl.onclick = function (ev) { ev = ev || window.event; const target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') { console.log('the content is: ', target.innerHTML); } }; //添加新节点 oBtn.onclick = function () { num++; const oLi = document.createElement('li'); oLi.innerHTML = `item ${num}`; oUl.appendChild(oLi); }; 可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的 三、总结 适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress 从上面应用场景中，我们就可以看到使用事件委托存在两大优点： 减少整个页面所需的内存，提升整体性能 动态绑定，减少重复工作 但是使用事件委托也是存在局限性： focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件 mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的 如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/event_loop.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/event_loop.html","title":"Event Loop","keywords":"","body":"面试官：说说你对事件循环的理解 一、是什么 首先，JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环 在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等 同步任务与异步任务的运行流程图如下： 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环 二、宏任务与微任务 如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： console.log(1) setTimeout(()=>{ console.log(2) }, 0) new Promise((resolve, reject)=>{ console.log('new Promise') resolve() }).then(()=>{ console.log('then') }) console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1)，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 => 'new Promise' => 3 => 2 => 'then' 但是实际结果是：1=>'new Promise'=> 3 => 'then' => 2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务 一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 这时候，事件循环，宏任务，微任务的关系如图所示 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 console.log(1) setTimeout(()=>{ console.log(2) }, 0) new Promise((resolve, reject)=>{ console.log('new Promise') resolve() }).then(()=>{ console.log('then') }) console.log(3) 流程如下 // 遇到 console.log(1) ，直接打印 1 // 遇到定时器，属于新的宏任务，留着后面执行 // 遇到 new Promise，这个是直接执行的，打印 'new Promise' // .then 属于微任务，放入微任务队列，后面再执行 // 遇到 console.log(3) 直接打印 3 // 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then' // 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 三、async与await async 是异步的意思，await则可以理解为 async wait。所以可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行 async async函数返回一个promise对象，下面两种方法是等效的 function f() { return Promise.resolve('TEST'); } // asyncF is equivalent to f! async function asyncF() { return 'TEST'; } await 正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值 async function f(){ // 等同于 // return 123 return await 123 } f().then(v => console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 async function fn1 (){ console.log(1) await fn2() console.log(2) // 阻塞 } async function fn2 (){ console.log('fn2') } fn1() console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 四、流程分析 通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解 这里直接上代码： async function async1() { console.log('async1 start') await async2() console.log('async1 end') } async function async2() { console.log('async2') } console.log('script start') setTimeout(function () { console.log('settimeout') }) async1() new Promise(function (resolve) { console.log('promise1') resolve() }).then(function () { console.log('promise2') }) console.log('script end') 分析过程： 执行整段代码，遇到 console.log('script start') 直接打印结果，输出 script start 遇到定时器了，它是宏任务，先放着不执行 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end 继续执行下一个微任务，即执行 then 的回调，打印 promise2 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout 所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/function_cache.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/function_cache.html","title":"Function Cache","keywords":"","body":"面试官：Javascript中如何实现函数缓存？函数缓存有哪些应用场景？ 一、是什么 函数缓存，就是将函数运算过的结果进行缓存 本质上就是用空间（缓存存储）换时间（计算过程） 常用于缓存数据计算结果和缓存对象 const add = (a,b) => a+b; const calc = memoize(add); // 函数缓存 calc(10,20);// 30 calc(10,20);// 30 缓存 缓存只是一个临时的数据存储，它保存数据，以便将来对该数据的请求能够更快地得到处理 二、如何实现 实现函数缓存主要依靠闭包、柯里化、高阶函数，这里再简单复习下： 闭包 闭包可以理解成，函数 + 函数体内可访问的变量总和 (function() { var a = 1; function add() { const b = 2 let sum = b + a console.log(sum); // 3 } add() })() add函数本身，以及其内部可访问的变量，即 a = 1，这两个组合在⼀起就形成了闭包 柯里化 把接受多个参数的函数转换成接受一个单一参数的函数 // 非函数柯里化 var add = function (x,y) { return x+y; } add(3,4) //7 // 函数柯里化 var add2 = function (x) { //**返回函数** return function (y) { return x+y; } } add2(3)(4) //7 将一个二元函数拆分成两个一元函数 高阶函数 通过接收其他函数作为参数或返回其他函数的函数 function foo(){ var a = 2; function bar() { console.log(a); } return bar; } var baz = foo(); baz();//2 函数 foo 如何返回另一个函数 bar，baz 现在持有对 foo 中定义的bar 函数的引用。由于闭包特性，a的值能够得到 下面再看看如何实现函数缓存，实现原理也很简单，把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果 如下所示 const memoize = function (func, content) { let cache = Object.create(null) content = content || this return (...key) => { if (!cache[key]) { cache[key] = func.apply(content, key) } return cache[key] } } 调用方式也很简单 const calc = memoize(add); const num1 = calc(100,200) const num2 = calc(100,200) // 缓存得到的结果 过程分析： 在当前函数作用域定义了一个空对象，用于缓存运行结果 运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到cache 然后判断输入参数是不是在cache的中。如果已经存在，直接返回cache的内容，如果没有存在，使用函数func对输入参数求值，然后把结果存储在cache中 三、应用场景 虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存 以下几种情况下，适合使用缓存： 对于昂贵的函数调用，执行复杂计算的函数 对于具有有限且高度重复输入范围的函数 对于具有重复输入值的递归函数 对于纯函数，即每次使用特定输入调用时返回相同输出的函数 参考文献 https://zhuanlan.zhihu.com/p/112505577 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/functional_programming.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/functional_programming.html","title":"Functional Programming","keywords":"","body":"面试官：说说你对函数式编程的理解？优缺点？ 一、是什么 函数式编程是一种\"编程范式\"（programming paradigm），一种编写程序的方法论 主要的编程范式有三种：命令式编程，声明式编程和函数式编程 相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程 举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下 // 命令式编程 var array = [0, 1, 2, 3] for(let i = 0; i Math.pow(num, 2)) 简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果 即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值 可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合 二、概念 纯函数 函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数 纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变 举一个简单的例子 let double = value=>value*2; 特性： 函数内部传入指定的值，就会返回确定唯一的值 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数 优势： 使用纯函数，我们可以产生可测试的代码 test('double(2) 等于 4', () => { expect(double(2)).toBe(4); }) 不依赖外部环境计算，不会产生副作用，提高函数的复用性 可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读 可以组装成复杂任务的可能性。符合模块化概念及单一职责原则 高阶函数 在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数 编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示 在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数 通过高阶函数抽象过程，注重结果，如下面例子 const forEach = function(arr,fn){ for(let i=0;i{ console.log(item); }) 上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么 高阶函数存在缓存的特性，主要是利用闭包作用 const once = (fn)=>{ let done = false; return function(){ if(!done){ fn.apply(this,fn); }else{ console.log(\"该函数已经执行\"); } done = true; } } 柯里化 柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程 一个二元函数如下： let fn = (x,y)=>x+y; 转化成柯里化函数如下： const curry = function(fn){ return function(x){ return function(y){ return fn(x,y); } } } let myfn = curry(fn); console.log( myfn(1)(2) ); 上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况 // 多参数柯里化； const curry = function(fn){ return function curriedFn(...args){ if(args.lengthx+y+z+a; const myfn = curry(fn); console.log(myfn(1)(2)(3)(1)); 关于柯里化函数的意义如下： 让纯函数更纯，每次接受一个参数，松散解耦 惰性执行 组合与管道 组合函数，目的是将多个函数组合成一个函数 举个简单的例子： function afn(a){ return a*2; } function bfn(b){ return b*3; } const compose = (a,b)=>c=>a(b(c)); let myfn = compose(afn,bfn); console.log( myfn(2)); 可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -> afn 的流水线 下面再来看看如何实现一个多函数组合： const compose = (...fns)=>val=>fns.reverse().reduce((acc,fn)=>fn(acc),val); compose执行是从右到左的。而管道函数，执行顺序是从左到右执行的 const pipe = (...fns)=>val=>fns.reduce((acc,fn)=>fn(acc),val); 组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑 三、优缺点 优点 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性 隐性好处。减少代码量，提高维护性 缺点： 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作 参考文献 https://zhuanlan.zhihu.com/p/81302150 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/inherit.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/inherit.html","title":"Inherit","keywords":"","body":"面试官：Javascript如何实现继承？ 一、是什么 继承（inheritance）是面向对象软件技术当中的一个概念。 如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类” 继承的优点 继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码 在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能 虽然JavaScript并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富 关于继承，我们举个形象的例子： 定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等 class Car{ constructor(color,speed){ this.color = color this.speed = speed // ... } } 由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱 // 货车 class Truck extends Car{ constructor(color,speed){ super(color,speed) this.Container = true // 货箱 } } 这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性 在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法 class Truck extends Car{ constructor(color,speed){ super(color,speed) this.color = \"black\" //覆盖 this.Container = true // 货箱 } } 从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系 二、实现方式 下面给出JavaScripy常见的继承方式： 原型链继承 构造函数继承（借助 call） 组合继承 原型式继承 寄生式继承 寄生组合式继承 原型链继承 原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针 举个例子 function Parent() { this.name = 'parent1'; this.play = [1, 2, 3] } function Child() { this.type = 'child2'; } Child1.prototype = new Parent(); console.log(new Child()) 上面代码看似没问题，实际存在潜在问题 var s1 = new Child2(); var s2 = new Child2(); s1.play.push(4); console.log(s1.play, s2.play); // [1,2,3,4] 改变s1的play属性，会发现s2也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的 构造函数继承 借助 call调用Parent函数 function Parent(){ this.name = 'parent1'; } Parent.prototype.getName = function () { return this.name; } function Child(){ Parent1.call(this); this.type = 'child' } let child = new Child(); console.log(child); // 没问题 console.log(child.getName()); // 会报错 可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法 相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法 组合继承 前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来 function Parent3 () { this.name = 'parent3'; this.play = [1, 2, 3]; } Parent3.prototype.getName = function () { return this.name; } function Child3() { // 第二次调用 Parent3() Parent3.call(this); this.type = 'child3'; } // 第一次调用 Parent3() Child3.prototype = new Parent3(); // 手动挂上构造器，指向自己的构造函数 Child3.prototype.constructor = Child3; var s3 = new Child3(); var s4 = new Child3(); s3.play.push(4); console.log(s3.play, s4.play); // 不互相影响 console.log(s3.getName()); // 正常输出'parent3' console.log(s4.getName()); // 正常输出'parent3' 这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到Parent3 执行了两次，造成了多构造一次的性能开销 原型式继承 这里主要借助Object.create方法实现普通对象的继承 同样举个例子 let parent4 = { name: \"parent4\", friends: [\"p1\", \"p2\", \"p3\"], getName: function() { return this.name; } }; let person4 = Object.create(parent4); person4.name = \"tom\"; person4.friends.push(\"jerry\"); let person5 = Object.create(parent4); person5.friends.push(\"lucy\"); console.log(person4.name); // tom console.log(person4.name === person4.getName()); // true console.log(person5.name); // parent4 console.log(person4.friends); // [\"p1\", \"p2\", \"p3\",\"jerry\",\"lucy\"] console.log(person5.friends); // [\"p1\", \"p2\", \"p3\",\"jerry\",\"lucy\"] 这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能 寄生式继承 寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法 let parent5 = { name: \"parent5\", friends: [\"p1\", \"p2\", \"p3\"], getName: function() { return this.name; } }; function clone(original) { let clone = Object.create(original); clone.getFriends = function() { return this.friends; }; return clone; } let person5 = clone(parent5); console.log(person5.getName()); // parent5 console.log(person5.getFriends()); // [\"p1\", \"p2\", \"p3\"] 其优缺点也很明显，跟上面讲的原型式继承一样 寄生组合式继承 寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在亲全面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式 function clone (parent, child) { // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程 child.prototype = Object.create(parent.prototype); child.prototype.constructor = child; } function Parent6() { this.name = 'parent6'; this.play = [1, 2, 3]; } Parent6.prototype.getName = function () { return this.name; } function Child6() { Parent6.call(this); this.friends = 'child5'; } clone(Parent6, Child6); Child6.prototype.getFriends = function () { return this.friends; } let person6 = new Child6(); console.log(person6); //{friends:\"child5\",name:\"child5\",play:[1,2,3],__proto__:Parent6} console.log(person6.getName()); // parent6 console.log(person6.getFriends()); // child5 可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题 文章一开头，我们是使用ES6 中的extends关键字直接实现 JavaScript的继承 class Person { constructor(name) { this.name = name } // 原型方法 // 即 Person.prototype.getName = function() { } // 下面可以简写为 getName() {...} getName = function () { console.log('Person:', this.name) } } class Gamer extends Person { constructor(name, age) { // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 super(name) this.age = age } } const asuna = new Gamer('Asuna', 20) asuna.getName() // 成功访问到父类的方法 利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式 三、总结 下面以一张图作为总结： 通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似 相关链接 https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/js_data_structure.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/js_data_structure.html","title":"Js Data Structure","keywords":"","body":"面试官：说说你了解的js数据结构？ 什么是数据结构？ 数据结构是计算机存储、组织数据的方式。 数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。 我们每天的编码中都会用到数据结构 数组是最简单的内存数据结构 下面是常见的数据结构： 数组（Array） 栈（Stack） 队列（Queue） 链表（Linked List） 字典 散列表（Hash table） 树（Tree） 图（Graph） 堆（Heap） 数组（Array） 数组是最最基本的数据结构，很多语言都内置支持数组。 数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。 在日常生活中，人们经常使用列表：待办事项列表、购物清单等。 而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用： 数据结构较为简单 不需要在一个长序列中查找元素，或者对其进行排序 反之，如果数据结构非常复杂，列表的作用就没有那么大了。 栈（Stack） 栈是一种遵循后进先出（LIFO）原则的有序集合 在栈里，新元素都接近栈顶，旧元素都接近栈底。 每次加入新的元素和拿走元素都在顶部操作 队列（Queue） 队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项 队列在尾部添加新元素，并从顶部移除元素 最新添加的元素必须排在队列的末尾 链表（Linked List） 链表也是一种列表，已经设计了数组，为什么还需要链表呢？ JavaScript中数组的主要问题时，它们被实现成了对象， 与其他语言（比如C++和Java）的数组相对，效率很低。 如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。 使用条件： 链表几乎可以用在任何可以使用一维数组的情况中。 如果需要随机访问，数组仍然是更好的选择。 字典 字典是一种以键-值对存储数据的数据结构，js中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。 散列表 也称为哈希表，特点是在散列表上插入、删除和取用数据都非常快。 为什么要设计这种数据结构呢？ 用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不知道这个数据存储到了数组的哪个位置。 散列表在JavaScript中可以基础数组去进行设计。 数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。 使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。 即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法（具体概念有兴趣的可以网上自信了解） 使用条件： 可以用于数据的插入、删除和取用，不适用于查找数据 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/loss_accuracy.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/loss_accuracy.html","title":"Loss Accuracy","keywords":"","body":"面试官：说说 Javascript 数字精度丢失的问题，如何解决？ 一、场景复现 一个经典的面试题 0.1 + 0.2 === 0.3 // false 为什么是false呢? 先看下面这个比喻 比如一个数 1÷3=0.33333333...... 3会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但0.333333...... 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题 二、浮点数 “浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储 我们也可以理解成，浮点数就是小数 在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间 对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了 而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下： 其中，a的值为0或者1，e为小数点移动的位置 举个例子： 27.0转化成二进制为11011.0 ，科学计数法表示为： 前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特 64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 如下图所示： 举个例子： 27.5 转换为二进制11011.1 11011.1转换为科学记数法 符号位为1(正数)，指数位为4+，1023+4，即1027 因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000` 所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示 0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000` 二、问题分析 再回到问题上 0.1 + 0.2 === 0.3 // false 通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都转化成二进制后再进行运算 // 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010 + 0.0011001100110011001100110011001100110011001100110011010 = 0.0100110011001100110011001100110011001100110011001100111 // 转成十进制正好是 0.30000000000000004 所以输出false 再来一个问题，那么为什么x=0.1得到0.1？ 主要是存储二进制时小数点的偏移量最大为52位，最多可以表达的位数是2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度 它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理 .10000000000000000555.toPrecision(16) // 返回 0.1000000000000000，去掉末尾的零后正好为 0.1 但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试： 0.1.toPrecision(21) = 0.100000000000000005551 如果整数大于 9007199254740992 会出现什么情况呢？ 由于指数位最大值是1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity > Math.pow(2, 1023) 8.98846567431158e+307 > Math.pow(2, 1024) Infinity 那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？ (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数 ... 依次跳过更多2的倍数 要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多 小结 计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法 因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差 三、解决方案 理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果 当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下： parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True 封装成方法就是： function strip(num, precision = 12) { return +parseFloat(num.toPrecision(precision)); } 对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例： /** * 精确加法 */ function add(num1, num2) { const num1Digits = (num1.toString().split('.')[1] || '').length; const num2Digits = (num2.toString().split('.')[1] || '').length; const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); return (num1 * baseNum + num2 * baseNum) / baseNum; } 最后还可以使用第三方库，如Math.js、BigDecimal.js 参考文献 https://zhuanlan.zhihu.com/p/100353781 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/memory_leak.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/memory_leak.html","title":"Memory Leak","keywords":"","body":"面试官：说说 JavaScript 中内存泄漏的几种情况？ 一、是什么 内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存 并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费 程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存 对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃 在C语言中，因为是手动管理内存，内存泄露是经常出现的事情。 char * buffer; buffer = (char*) malloc(42); // Do something with buffer free(buffer); 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\" 二、垃圾回收机制 Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存 通常情况下有两种实现方式： 标记清除 引用计数 标记清除 JavaScript最常用的垃圾收回机制 当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“ 垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉 在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了 随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存 举个例子： var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。 add(m, n) // 把 a, b, c标记为进入环境。 console.log(n) // a,b,c标记为离开环境，等待垃圾回收。 function add(a, b) { a++ var c = a + b return c } 引用计数 语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏 const arr = [1, 2, 3, 4]; console.log('hello world'); 面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存 如果需要这块内存被垃圾回收机制释放，只需要设置如下： arr = null 通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了 小结 有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用 三、常见内存泄露情况 意外的全局变量 function foo(arg) { bar = \"this is a hidden global variable\"; } 另一种意外的全局变量可能由 this 创建： function foo() { this.variable = \"potential accidental global\"; } // foo 调用自己，this 指向了全局对象（window） foo(); 上述使用严格模式，可以避免意外的全局变量 定时器也常会造成内存泄露 var someResource = getData(); setInterval(function() { var node = document.getElementById('Node'); if(node) { // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); } }, 1000); 如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放 包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放 function bindEvent() { var obj = document.createElement('XXX'); var unused = function () { console.log(obj, '闭包内引用obj obj不会被释放'); }; obj = null; // 解决方法 } 没有清理对DOM元素的引用同样造成内存泄露 const refA = document.getElementById('refA'); document.body.removeChild(refA); // dom删除了 console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收 refA = null; console.log(refA, 'refA'); // 解除引用 包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听 参考文献 http://www.ruanyifeng.com/blog/2017/04/memory-leak.html https://zh.wikipedia.org/wiki 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/new.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/new.html","title":"New","keywords":"","body":"面试官：说说new操作符具体干了什么？ 一、是什么 在JavaScript中，new操作符用于创建一个给定构造函数的实例对象 例子 function Person(name, age){ this.name = name; this.age = age; } Person.prototype.sayName = function () { console.log(this.name) } const person1 = new Person('Tom', 20) console.log(person1) // Person {name: \"Tom\", age: 20} t.sayName() // 'Tom' 从上面可以看到： new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性 new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来） 现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型 function Test(name) { this.name = name return 1 } const t = new Test('xxx') console.log(t.name) // 'xxx' 可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用 下面在构造函数中返回一个对象 function Test(name) { this.name = name console.log(this) // Test { name: 'xxx' } return { age: 26 } } const t = new Test('xxx') console.log(t) // { age: 26 } console.log(t.name) // 'undefined' 从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用 二、流程 从上面介绍中，我们可以看到new关键字主要做了以下的工作： 创建一个新的对象obj 将对象与构建函数通过原型链连接起来 将构建函数中的this绑定到新建的对象obj上 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理 举个例子： function Person(name, age){ this.name = name; this.age = age; } const person1 = new Person('Tom', 20) console.log(person1) // Person {name: \"Tom\", age: 20} t.sayName() // 'Tom' 流程图如下： 三、手写new操作符 现在我们已经清楚地掌握了new的执行过程 那么我们就动手来实现一下new function mynew(Func, ...args) { // 1.创建一个新对象 const obj = {} // 2.新对象原型指向构造函数原型对象 obj.__proto__ = Func.prototype // 3.将构建函数的this指向新对象 let result = Func.apply(obj, args) // 4.根据返回值判断 return result instanceof Object ? result : obj } 测试一下 function mynew(func, ...args) { const obj = {} obj.__proto__ = func.prototype let result = func.apply(obj, args) return result instanceof Object ? result : obj } function Person(name, age) { this.name = name; this.age = age; } Person.prototype.say = function () { console.log(this.name) } let p = mynew(Person, \"huihui\", 123) console.log(p) // Person {name: \"huihui\", age: 123} p.say() // huihui 可以发现，代码虽然很短，但是能够模拟实现new 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/prototype.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/prototype.html","title":"Prototype","keywords":"","body":"面试官：JavaScript原型，原型链 ? 有什么特点？ 一、原型 JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾 准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身 下面举个例子： 函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype function doSomething(){} console.log( doSomething.prototype ); 控制台输出 { constructor: ƒ doSomething(), __proto__: { constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() } } 上面这个对象，就是大家常说的原型对象 可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示 二、原型链 原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法 在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法 下面举个例子： function Person(name) { this.name = name; this.age = 18; this.sayName = function() { console.log(this.name); } } // 第二步 创建实例 var person = new Person('person') 根据代码，我们可以得到下图 下面分析一下： 构造函数Person存在原型对象Person.prototype 构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象 Person.prototype.__proto__ 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象 Person.__proto__ 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建 Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null 三、总结 下面首先要看几个概念： __proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的 每个对象的__proto__都是指向它的构造函数的原型对象prototype的 person1.__proto__ === Person.prototype 构造函数是一个函数对象，是通过 Function构造器产生的 Person.__proto__ === Function.prototype 原型对象本身是一个普通对象，而普通对象的构造函数都是Object Person.prototype.__proto__ === Object.prototype 刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的 Object.__proto__ === Function.prototype Object的原型对象也有__proto__属性指向null，null是原型链的顶端 Object.prototype.__proto__ === null 下面作出总结： 一切对象都是继承自Object对象，Object 对象直接继承根源对象null 一切的函数对象（包括 Object 对象），都是继承自 Function 对象 Object 对象直接继承自 Function 对象 Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象 参考文献 https://juejin.cn/post/6870732239556640775#heading-7 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/pull_up_loading_pull_down_refresh.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/pull_up_loading_pull_down_refresh.html","title":"Pull Up Loading Pull Down Refresh","keywords":"","body":"面试官：如何实现上拉加载，下拉刷新？ 一、前言 下拉刷新和上拉加载这两种交互方式通常出现在移动端中 本质上等同于PC网页中的分页，只是交互形式不同 开源社区也有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等 这些第三方库使用起来非常便捷 我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用 二、实现原理 上拉加载及下拉刷新都依赖于用户交互 最重要的是要理解在什么场景，什么时机下触发交互动作 上拉加载 首先可以看一张图 上拉加载的本质是页面触底，或者快要触底时的动作 判断页面触底我们需要先了解一下下面几个属性 scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值 clientHeight:它是一个定值，表示屏幕可视区域的高度； scrollHeight：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示body所有元素的总长度(包括body元素自身的padding) 综上我们得出一个触底公式： scrollTop + clientHeight >= scrollHeight 简单实现 let clientHeight = document.documentElement.clientHeight; //浏览器高度 let scrollHeight = document.body.scrollHeight; let scrollTop = document.documentElement.scrollTop; let distance = 50; //距离视窗还用50的时候，开始触发； if ((scrollTop + clientHeight) >= (scrollHeight - distance)) { console.log(\"开始加载数据\"); } 下拉刷新 下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作 关于下拉刷新的原生实现，主要分成三步： 监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY； 监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值； 监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置 举个例子： Html结构如下： 111 222 333 444 555 ... 监听touchstart事件，记录初始的值 var _element = document.getElementById('refreshContainer'), _refreshText = document.querySelector('.refreshText'), _startPos = 0, // 初始的值 _transitionHeight = 0; // 移动的距离 _element.addEventListener('touchstart', function(e) { _startPos = e.touches[0].pageY; // 记录初始位置 _element.style.position = 'relative'; _element.style.transition = 'transform 0s'; }, false); 监听touchmove移动事件，记录滑动差值 _element.addEventListener('touchmove', function(e) { // e.touches[0].pageY 当前位置 _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值 if (_transitionHeight > 0 && _transitionHeight 55) { _refreshText.innerText = '释放更新'; } } }, false); 最后，就是监听touchend离开的事件 _element.addEventListener('touchend', function(e) { _element.style.transition = 'transform 0.5s ease 1s'; _element.style.transform = 'translateY(0px)'; _refreshText.innerText = '更新中...'; // todo... }, false); 从上面可以看到，在下拉到松手的过程中，经历了三个阶段： 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作 下拉到一定值时，显示松手释放后的操作提示 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作 三、案例 在实际开发中，我们更多的是使用第三方库，下面以better-scroll进行举例： HTML结构 下拉刷新 查看更多 实例化上拉下拉插件，通过use来注册插件 import BScroll from \"@better-scroll/core\"; import PullDown from \"@better-scroll/pull-down\"; import PullUp from '@better-scroll/pull-up'; BScroll.use(PullDown); BScroll.use(PullUp); 实例化BetterScroll，并传入相关的参数 let pageNo = 1,pageSize = 10,dataList = [],isMore = true; var scroll= new BScroll(\"#position-wrapper\",{ scrollY:true,//垂直方向滚动 click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true pullUpLoad:true,//上拉加载更多 pullDownRefresh:{ threshold:50,//触发pullingDown事件的位置 stop:0//下拉回弹后停留的位置 } }); //监听下拉刷新 scroll.on(\"pullingDown\",pullingDownHandler); //监测实时滚动 scroll.on(\"scroll\",scrollHandler); //上拉加载更多 scroll.on(\"pullingUp\",pullingUpHandler); async function pullingDownHandler(){ dataList=[]; pageNo=1; isMore=true; $(\".more\").text(\"查看更多\"); await getlist();//请求数据 scroll.finishPullDown();//每次下拉结束后，需要执行这个操作 scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作 } async function pullingUpHandler(){ if(!isMore){ $(\".more\").text(\"没有更多数据了\"); scroll.finishPullUp();//每次上拉结束后，需要执行这个操作 return; } pageNo++; await this.getlist();//请求数据 scroll.finishPullUp();//每次上拉结束后，需要执行这个操作 scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作 } function scrollHandler(){ if(this.y>50) $('.refresh').text(\"松手开始加载\"); else $('.refresh').text(\"下拉刷新\"); } function getlist(){ //返回的数据 let result=....; dataList=dataList.concat(result); //判断是否已加载完 if(result.length 注意点： 使用better-scroll实现下拉刷新、上拉加载时要注意以下几点： wrapper里必须只有一个子元素 子元素的高度要比wrapper要高 使用的时候，要确定DOM元素是否已经生成，必须要等到DOM渲染完成后，再new BScroll() 滚动区域的DOM元素结构有变化后，需要执行刷新 refresh() 上拉或者下拉，结束后，需要执行finishPullUp()或者finishPullDown()，否则将不会执行下次操作 better-scroll，默认会阻止浏览器的原生click事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置click:true 小结 下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节 参考文献 https://segmentfault.com/a/1190000014423308 https://github.com/ustbhuangyi/better-scroll 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/regexp.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/regexp.html","title":"Regexp","keywords":"","body":"面试官：说说你对正则表达式的理解？应用场景？ 一、是什么 正则表达式是一种用来匹配字符串的强有力的武器 它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的 在 JavaScript中，正则表达式也是对象，构建正则表达式有两种方式： 字面量创建，其由包含在斜杠之间的模式组成 const re = /\\d+/g; 调用RegExp对象的构造函数 const re = new RegExp(\"\\\\d+\",\"g\"); const rul = \"\\\\d+\" const re1 = new RegExp(rul,\"g\"); 使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\\需要使用\\\\进行转义 二、匹配规则 常见的校验规则如下： 规则 描述 \\ 转义 ^ 匹配输入的开始 $ 匹配输入的结束 * 匹配前一个表达式 0 次或多次 + 匹配前面一个表达式 1 次或者多次。等价于 {1,} ? 匹配前面一个表达式 0 次或者 1 次。等价于{0,1} . 默认匹配除换行符之外的任何单个字符 x(?=y) 匹配'x'仅仅当'x'后面跟着'y'。这种叫做先行断言 (? 匹配'x'仅当'x'前面是'y'.这种叫做后行断言 x(?!y) 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找 (?y)x 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找 x\\ y 匹配‘x’或者‘y’ {n} n 是一个正整数，匹配了前面一个字符刚好出现了 n 次 {n,} n是一个正整数，匹配前一个字符至少出现了n次 {n,m} n 和 m 都是整数。匹配前面的字符至少n次，最多m次 [xyz] 一个字符集合。匹配方括号中的任意字符 xyz\\ 匹配任何没有包含在方括号中的字符 \\b 匹配一个词的边界，例如在字母和空格之间 \\B 匹配一个非单词边界 \\d 匹配一个数字 \\D 匹配一个非数字字符 \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符 \\S 匹配一个非空白字符 \\w 匹配一个单字字符（字母、数字或者下划线） \\W 匹配一个非单字字符 正则表达式标记 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 s 允许 . 匹配换行符。 u 使用unicode码的模式进行匹配。 y 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。 使用方法如下： var re = /pattern/flags; var re = new RegExp(\"pattern\", \"flags\"); 在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性： 贪婪模式 在了解贪婪模式前，首先举个例子： const reg = /ab{1,3}c/ 在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试bbb，然后再看整个正则是否能匹配。不能匹配时，吐出一个b，即在bb的基础上，再继续尝试，以此重复 如果多个贪婪量词挨着，则深度优先搜索 const string = \"12345\"; const regx = /(\\d{1,3})(\\d{1,3})/; console.log( string.match(reg) ); // => [\"12345\", \"123\", \"45\", index: 0, input: \"12345\"] 其中，前面的\\d{1,3}匹配的是\"123\"，后面的\\d{1,3}匹配的是\"45\" 懒惰模式 惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配 var string = \"12345\"; var regex = /(\\d{1,3}?)(\\d{1,3})/; console.log( string.match(regex) ); // => [\"1234\", \"1\", \"234\", index: 0, input: \"12345\"] 其中\\d{1,3}?只匹配到一个字符\"1\"，而后面的\\d{1,3}匹配了\"234\" 分组 分组主要是用过()进行实现，比如beyond{3}，是匹配d字母3次。而(beyond){3}是匹配beyond三次 在()内使用|达到或的效果，如(abc | xxx)可以匹配abc或者xxx 反向引用，巧用$分组捕获 let str = \"John Smith\"; // 交换名字和姓氏 console.log(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John 三、匹配方法 正则表达式常被用于某些方法，我们可以分成两类： 字符串（str）方法：match、matchAll、search、replace、split 正则对象下（regexp）的方法：test、exec 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 str.match(regexp) str.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符 如果 regexp 不带有 g 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str） let str = \"I love JavaScript\"; let result = str.match(/Java(Script)/); console.log( result[0] ); // JavaScript（完全匹配） console.log( result[1] ); // Script（第一个分组） console.log( result.length ); // 2 // 其他信息： console.log( result.index ); // 7（匹配位置） console.log( result.input ); // I love JavaScript（源字符串） 如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息 let str = \"I love JavaScript\"; let result = str.match(/Java(Script)/g); console.log( result[0] ); // JavaScript console.log( result.length ); // 1 如果没有匹配项，则无论是否带有标记 g ，都将返回 null let str = \"I love JavaScript\"; let result = str.match(/HTML/); console.log(result); // null str.matchAll(regexp) 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器 const regexp = /t(e)(st(\\d?))/g; const str = 'test1test2'; const array = [...str.matchAll(regexp)]; console.log(array[0]); // expected output: Array [\"test1\", \"e\", \"st1\", \"1\"] console.log(array[1]); // expected output: Array [\"test2\", \"e\", \"st2\", \"2\"] str.search(regexp) 返回第一个匹配项的位置，如果未找到，则返回 -1 let str = \"A drop of ink may make a million think\"; console.log( str.search( /ink/i ) ); // 10（第一个匹配位置） 这里需要注意的是，search 仅查找第一个匹配项 str.replace(regexp) 替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配g的时候，只替换第一个匹配成功的字符串片段 const reg1=/javascript/i; const reg2=/javascript/ig; console.log('hello Javascript Javascript Javascript'.replace(reg1,'js')); //hello js Javascript Javascript console.log('hello Javascript Javascript Javascript'.replace(reg2,'js')); //hello js js js str.split(regexp) 使用正则表达式（或子字符串）作为分隔符来分割字符串 console.log('12, 34, 56'.split(/,\\s*/)) // 数组 ['12', '34', '56'] regexp.exec(str) regexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的 根据正则表达式是否带有标志 g，它的行为有所不同 如果没有 g，那么 regexp.exec(str) 返回的第一个匹配与 str.match(regexp) 完全相同 如果有标记 g，调用 regexp.exec(str) 会返回第一个匹配项，并将紧随其后的位置保存在属性regexp.lastIndex 中。 下一次同样的调用会从位置 regexp.lastIndex 开始搜索，返回下一个匹配项，并将其后的位置保存在 regexp.lastIndex 中 let str = 'More about JavaScript at https://javascript.info'; let regexp = /javascript/ig; let result; while (result = regexp.exec(str)) { console.log( `Found ${result[0]} at position ${result.index}` ); // Found JavaScript at position 11 // Found javascript at position 33 } regexp.test(str) 查找匹配项，然后返回 true/false 表示是否存在 let str = \"I love JavaScript\"; // 这两个测试相同 console.log( /love/i.test(str) ); // true 四、应用场景 通过上面的学习，我们对正则表达式有了一定的了解 下面再来看看正则表达式一些案例场景： 验证QQ合法性（5~15位、全是数字、不以0开头）： const reg = /^[1-9][0-9]{4,14}$/ const isvalid = patrn.exec(s) 校验用户账号合法性（只能输入5-20个以字母开头、可带数字、“_”、“.”的字串）： var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/; const isvalid = patrn.exec(s) 将url参数解析为对象 const protocol = '(?https?:)'; const host = '(?(?[^/#?:]+)(?::(?\\\\d+))?)'; const path = '(?(?:\\\\/[^/#?]+)*\\\\/?)'; const search = '(?(?:\\\\?[^#]*)?)'; const hash = '(?(?:#.*)?)'; const reg = new RegExp(`^${protocol}\\/\\/${host}${path}${search}${hash}$`); function execURL(url){ const result = reg.exec(url); if(result){ result.groups.port = result.groups.port || ''; return result.groups; } return { protocol:'',host:'',hostname:'',port:'', pathname:'',search:'',hash:'', }; } console.log(execURL('https://localhost:8080/?a=b#xxxx')); protocol: \"https:\" host: \"localhost:8080\" hostname: \"localhost\" port: \"8080\" pathname: \"/\" search: \"?a=b\" hash: \"#xxxx\" 再将上面的search和hash进行解析 function execUrlParams(str){ str = str.replace(/^[#?&]/,''); const result = {}; if(!str){ //如果正则可能配到空字符串，极有可能造成死循环，判断很重要 return result; } const reg = /(?:^|&)([^&=]*)=?([^&]*?)(?=&|$)/y let exec = reg.exec(str); while(exec){ result[exec[1]] = exec[2]; exec = reg.exec(str); } return result; } console.log(execUrlParams('#'));// {} console.log(execUrlParams('##'));//{'#':''} console.log(execUrlParams('?q=3606&src=srp')); //{q: \"3606\", src: \"srp\"} console.log(execUrlParams('test=a=b=c&&==&a='));//{test: \"a=b=c\", \"\": \"=\", a: \"\"} 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/scope.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/scope.html","title":"Scope","keywords":"","body":"面试官：说说你对作用域链的理解 一、作用域 作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合 换句话说，作用域决定了代码区块中变量和其他资源的可见性 举个例子 function myFunction() { let inVariable = \"函数内部变量\"; } myFunction();//要先执行这个函数，否则根本不知道里面是啥 console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错 这就说明我们在全局是无法获取到（闭包除外）函数内部的变量 我们一般将作用域分成： 全局作用域 函数作用域 块级作用域 全局作用域 任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问 // 全局变量 var greeting = 'Hello World!'; function greet() { console.log(greeting); } // 打印 'Hello World!' greet(); 函数作用域 函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问 function greet() { var greeting = 'Hello World!'; console.log(greeting); } // 打印 'Hello World!' greet(); // 报错： Uncaught ReferenceError: greeting is not defined console.log(greeting); 可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域 块级作用域 ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量 { // 块级作用域中的变量 let greeting = 'Hello World!'; var lang = 'English'; console.log(greeting); // Prints 'Hello World!' } // 变量 'English' console.log(lang); // 报错：Uncaught ReferenceError: greeting is not defined console.log(greeting); 二、词法作用域 词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域 var a = 2; function foo(){ console.log(a) } function bar(){ var a = 3; foo(); } n() 上述代码改变成一张图 由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2 三、作用域链 当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错 这里拿《你不知道的Javascript(上)》中的一张图解释： 把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域 变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止 下面代码演示下： var sex = '男'; function person() { var name = '张三'; function student() { var age = 18; console.log(name); // 张三 console.log(sex); // 男 } student(); console.log(age); // Uncaught ReferenceError: age is not defined } person(); 上述代码主要主要做了以下工作： student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三” student内部输出cat时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男” 在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/security.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/security.html","title":"Security","keywords":"","body":"面试官：web常见的攻击方式有哪些？如何防御？ 一、是什么 Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为 如植入恶意代码，修改网站权限，获取网站用户隐私信息等等 Web应用程序的安全性是任何基于Web业务的重要组成部分 确保Web应用程序安全十分重要，即使是代码中很小的 bug 也有可能导致隐私信息被泄露 站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践 我们常见的Web攻击方式有 XSS (Cross Site Scripting) 跨站脚本攻击 CSRF（Cross-site request forgery）跨站请求伪造 SQL注入攻击 二、XSS XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中 XSS涉及到三方，即攻击者、客户端与Web应用 XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互 举个例子： 一个搜索页面，根据url参数决定关键词的内容 \"> 搜索 您搜索的关键词是： 这里看似并没有问题，但是如果不按套路出牌呢？ 用户输入\">alert('XSS');，拼接到 HTML 中返回给浏览器。形成了如下的 HTML： alert('XSS');\"> 搜索 您搜索的关键词是：\">alert('XSS'); 浏览器无法分辨出 alert('XSS'); 是恶意代码，因而将其执行，试想一下，如果是获取cookie发送对黑客服务器呢？ 根据攻击的来源，XSS攻击可以分成： 存储型 反射型 DOM 型 存储型 存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等 反射型 XSS 反射型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见 DOM 型 XSS DOM 型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码 用户打开带有恶意代码的 URL 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞 XSS的预防 通过前面介绍，看到XSS攻击的两大要素： 攻击者提交而恶意代码 浏览器执行恶意代码 针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了 而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示 例如： 一个正常的用户输入了 5 这个内容，在写入数据库前，被转义，变成了 5 在客户端中，一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 ) 在前端中，不同的位置所需的编码也不同。 当 5 作为 HTML 拼接页面时，可以正常显示： 5 &lt; 7 当 5 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等 可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码： 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免 1 // setTimeout()/setInterval() 中调用恶意代码 setTimeout(\"UNTRUSTED\") setInterval(\"UNTRUSTED\") // location 调用恶意代码 location.href = 'UNTRUSTED' // eval() 中调用恶意代码 eval(\"UNTRUSTED\") 三、CSRF CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求 利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目 一个典型的CSRF攻击有着如下的流程： 受害者登录a.com，并保留了登录凭证（Cookie） 攻击者引诱受害者访问了b.com b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 a.com以受害者的名义执行了act=xx 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作 csrf可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求 同样，也可以设置一个自动提交的表单发送post请求，如下： document.forms[0].submit(); 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作 还有一种为使用a标签的，需要用户点击链接才会触发 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作 重磅消息！！ CSRF的特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用” 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪 CSRF的预防 CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性 防止csrf常用方案如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 这里主要讲讲token这种形式，流程如下： 用户打开页面的时候，服务器需要给这个用户生成一个Token 对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性 四、SQL注入 Sql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击 流程如下所示： 找出SQL漏洞的注入点 判断数据库的类型以及版本 猜解用户名和密码 利用工具查找Web后台管理入口 入侵和破坏 预防方式如下： 严格检查输入变量的类型和格式 过滤和转义特殊字符 对访问数据库的Web应用程序采用Web应用防火墙 上述只是列举了常见的web攻击方式，实际开发过程中还会遇到很多安全问题，对于这些问题， 切记不可忽视 参考文献 https://tech.meituan.com/2018/09/27/fe-security.html https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/single_sign.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/single_sign.html","title":"Single Sign","keywords":"","body":"面试官：什么是单点登录？如何实现？ 一、是什么 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一 SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统 SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作 当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证 上图有四个系统，分别是Application1、Application2、Application3、和SSO，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了 举个例子 淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录 二、如何实现 同域名下的单点登录 cookie的domain属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径 利用 Cookie 的这个特点，没错，我们只需要将Cookie的domain属性设置为父域的域名（主域名），同时将 Cookie的path属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个Cookie 不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com这个主域名之下，那么它们就可以通过这种方式来实现单点登录 不同域名下的单点登录(一) 如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web服务 用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个 Cookie是认证中心的，应用系统是访问不到的） 应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心 由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了 如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录 如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL，并在跳转前生成一个 Token，拼接在目标URL 的后面，回传给目标应用系统 应用系统拿到 Token之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token写入Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了 此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法 不同域名下的单点登录(二) 可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将LocalStorage的数据传递给服务端 这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID（或 Token）放在响应体中传递给前端 单点登录完全可以在前端实现。前端拿到 Session ID（或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中 关键代码如下： // 获取 token var token = result.data.token; // 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML var iframe = document.createElement(\"iframe\"); iframe.src = \"http://app1.com/localstorage.html\"; document.body.append(iframe); // 使用postMessage()方法将token传递给iframe setTimeout(function () { iframe.contentWindow.postMessage(token, \"http://app1.com\"); }, 4000); setTimeout(function () { iframe.remove(); }, 6000); // 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage window.addEventListener('message', function (event) { localStorage.setItem('token', event.data) }, false); 前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取Token并在请求中携带，这样就实现了同一份Token 被多个域所共享 此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域 三、流程 单点登录的流程图如下所示： 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话 用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心 全局会话与局部会话有如下约束关系： 局部会话存在，全局会话一定存在 全局会话存在，局部会话不一定存在 全局会话销毁，局部会话必须销毁 参考文献 https://blog.csdn.net/weixin_36380516/article/details/109006828 https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95 https://juejin.cn/post/6844903664985866253 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/string_api.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/string_api.html","title":"String Api","keywords":"","body":"面试官：JavaScript字符串的常用方法有哪些？ 一、操作方法 我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变 增 这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作 除了常用+以及${}进行字符串拼接之外，还可通过concat concat 用于将一个或多个字符串拼接成一个新字符串 let stringValue = \"hello \"; let result = stringValue.concat(\"world\"); console.log(result); // \"hello world\" console.log(stringValue); // \"hello\" 删 这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作 常见的有： slice() substr() substring() 这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。 let stringValue = \"hello world\"; console.log(stringValue.slice(3)); // \"lo world\" console.log(stringValue.substring(3)); // \"lo world\" console.log(stringValue.substr(3)); // \"lo world\" console.log(stringValue.slice(3, 7)); // \"lo w\" console.log(stringValue.substring(3,7)); // \"lo w\" console.log(stringValue.substr(3, 7)); // \"lo worl\" 改 这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作 常见的有： trim()、trimLeft()、trimRight() repeat() padStart()、padEnd() toLowerCase()、 toUpperCase() trim()、trimLeft()、trimRight() 删除前、后或前后所有空格符，再返回新的字符串 let stringValue = \" hello world \"; let trimmedStringValue = stringValue.trim(); console.log(stringValue); // \" hello world \" console.log(trimmedStringValue); // \"hello world\" repeat() 接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果 let stringValue = \"na \"; let copyResult = stringValue.repeat(2) // na na padEnd() 复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件 let stringValue = \"foo\"; console.log(stringValue.padStart(6)); // \" foo\" console.log(stringValue.padStart(9, \".\")); // \"......foo\" toLowerCase()、 toUpperCase() 大小写转化 let stringValue = \"hello world\"; console.log(stringValue.toUpperCase()); // \"HELLO WORLD\" console.log(stringValue.toLowerCase()); // \"hello world\" 查 除了通过索引的方式获取字符串的值，还可通过： chatAt() indexOf() startWith() includes() charAt() 返回给定索引位置的字符，由传给方法的整数参数指定 let message = \"abcde\"; console.log(message.charAt(2)); // \"c\" indexOf() 从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ） let stringValue = \"hello world\"; console.log(stringValue.indexOf(\"o\")); // 4 startWith()、includes() 从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值 let message = \"foobarbaz\"; console.log(message.startsWith(\"foo\")); // true console.log(message.startsWith(\"bar\")); // false console.log(message.includes(\"bar\")); // true console.log(message.includes(\"qux\")); // false 二、转换方法 split 把字符串按照指定的分割符，拆分成数组中的每一项 let str = \"12+23+34\" let arr = str.split(\"+\") // [12,23,34] 三、模板匹配方法 针对正则表达式，字符串设计了几个方法： match() search() replace() match() 接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回数组 let text = \"cat, bat, sat, fat\"; let pattern = /.at/; let matches = text.match(pattern); console.log(matches[0]); // \"cat\" search() 接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，找到则返回匹配索引，否则返回 -1 let text = \"cat, bat, sat, fat\"; let pos = text.search(/at/); console.log(pos); // 1 replace() 接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数） let text = \"cat, bat, sat, fat\"; let result = text.replace(\"at\", \"ond\"); console.log(result); // \"cond, bat, sat, fat\" 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/tail_recursion.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/tail_recursion.html","title":"Tail Recursion","keywords":"","body":"面试官：举例说明你对尾递归的理解，有哪些应用场景 一、递归 递归（英语：Recursion） 在数学与计算机科学中，是指在函数的定义中使用函数自身的方法 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数 其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回 下面实现一个函数 pow(x, n)，它可以计算 x 的 n 次方 使用迭代的方式，如下： function pow(x, n) { let result = 1; // 再循环中，用 x 乘以 result n 次 for (let i = 0; i 使用递归的方式，如下： function pow(x, n) { if (n == 1) { return x; } else { return x * pow(x, n - 1); } } pow(x, n) 被调用时，执行分为两个分支： if n==1 = x / pow(x, n) = \\ else = x * pow(x, n - 1) 也就是说pow 递归地调用自身 直到 n == 1 为了计算 pow(2, 4)，递归变体经过了下面几个步骤： pow(2, 4) = 2 * pow(2, 3) pow(2, 3) = 2 * pow(2, 2) pow(2, 2) = 2 * pow(2, 1) pow(2, 1) = 2 因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果 二、尾递归 尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数 尾递归在普通尾调用的基础上，多出了2个特征： 在尾部调用的是函数自身 可通过优化，使得计算仅占用常量栈空间 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出 这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误 实现一下阶乘，如果用普通的递归，如下： function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 如果n等于5，这个方法要执行5次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为O(n) 如果我们使用尾递归，则如下： function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1) 二、应用场景 数组求和 function sumArray(arr, total) { if(arr.length === 1) { return total } return sum(arr, total + arr.pop()) } 使用尾递归优化求斐波那契数列 function factorial2 (n, start = 1, total = 1) { if(n 数组扁平化 let a = [1,2,3, [1,2,3, [1,2,3]]] // 变成 let a = [1,2,3,1,2,3,1,2,3] // 具体实现 function flat(arr = [], result = []) { arr.forEach(v => { if(Array.isArray(v)) { result = result.concat(flat(v, [])) }else { result.push(v) } }) return result } 数组对象格式化 let obj = { a: '1', b: { c: '2', D: { E: '3' } } } // 转化为如下： let obj = { a: '1', b: { c: '2', d: { e: '3' } } } // 代码实现 function keysLower(obj) { let reg = new RegExp(\"([A-Z]+)\", \"g\"); for (let key in obj) { if (obj.hasOwnProperty(key)) { let temp = obj[key]; if (reg.test(key.toString())) { // 将修改后的属性名重新赋值给temp，并在对象obj内添加一个转换后的属性 temp = obj[key.replace(reg, function (result) { return result.toLowerCase() })] = obj[key]; // 将之前大写的键属性删除 delete obj[key]; } // 如果属性是对象或者数组，重新执行函数 if (typeof temp === 'object' || Object.prototype.toString.call(temp) === '[object Array]') { keysLower(temp); } } } return obj; }; 参考文献 https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/this.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/this.html","title":"This","keywords":"","body":"面试官：谈谈this对象的理解 一、定义 函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 举个例子： function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // bar --> foo // 因此，当前调用位置在bar中 console.log( \"foo\" ); } baz(); // 同时，this在函数执行过程中，this一旦被确定了，就不可以再更改 var a = 10; var obj = { a: 20 } function fn() { this = obj; // 修改this，运行后会报错 console.log(this.a); } fn(); 二、绑定规则 根据不同的使用场合，this有不同的值，主要分为下面几种情况： 默认绑定 隐式绑定 new绑定 显示绑定 默认绑定 全局环境中定义person函数，内部使用this关键字 var name = 'Jenny'; function person() { return this.name; } console.log(person()); //Jenny 上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny 注意： 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象 隐式绑定 函数还可以作为某个对象的方法调用，这时this就指这个上级对象 function test() { console.log(this.x); } var obj = {}; obj.x = 1; obj.m = test; obj.m(); // 1 这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 var o = { a:10, b:{ fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined 这里再举一种特殊情况 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var j = o.b.fn; j(); 此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window new绑定 通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象 function test() { 　this.x = 1; } var obj = new test(); obj.x // 1 上述代码之所以能过输出1，是因为new关键字改变了this的指向 这里再列举一些特殊情况： new过程遇到return一个对象，此时this指向为返回的对象 function fn() { this.user = 'xxx'; return {}; } var a = new fn(); console.log(a.user); //undefined 如果返回一个简单类型的时候，则this指向实例对象 function fn() { this.user = 'xxx'; return 1; } var a = new fn; console.log(a.user); //xxx 注意的是null虽然也是对象，但是此时new仍然指向实例对象 function fn() { this.user = 'xxx'; return null; } var a = new fn; console.log(a.user); //xxx 显示修改 apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数 var x = 0; function test() { 　console.log(this.x); } var obj = {}; obj.x = 1; obj.m = test; obj.m.apply(obj) // 1 关于apply、call、bind三者的区别，我们后面再详细说 三、箭头函数 在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定） 举个例子： const obj = { sayThis: () => { console.log(this); } }; obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了 const globalSay = obj.sayThis; globalSay(); // window 浏览器中的 global 对象 虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑 下面举个例子： 绑定事件监听 const button = document.getElementById('mngb'); button.addEventListener('click', ()=> { console.log(this === window) // true this.innerHTML = 'clicked button' }) 上述可以看到，我们其实是想要this为点击的button，但此时this指向了window 包括在原型上添加方法时候，此时this指向window Cat.prototype.sayName = () => { console.log(this === window) //true return this.name } const cat = new Cat('mm'); cat.sayName() 同样的，箭头函数不能作为构建函数 四、优先级 隐式绑定 VS 显式绑定 function foo() { console.log( this.a ); } var obj1 = { a: 2, foo: foo }; var obj2 = { a: 3, foo: foo }; obj1.foo(); // 2 obj2.foo(); // 3 obj1.foo.call( obj2 ); // 3 obj2.foo.call( obj1 ); // 2 显然，显示绑定的优先级更高 new绑定 VS 隐式绑定 function foo(something) { this.a = something; } var obj1 = { foo: foo }; var obj2 = {}; obj1.foo( 2 ); console.log( obj1.a ); // 2 obj1.foo.call( obj2, 3 ); console.log( obj2.a ); // 3 var bar = new obj1.foo( 4 ); console.log( obj1.a ); // 2 console.log( bar.a ); // 4 可以看到，new绑定的优先级>隐式绑定 new绑定 VS 显式绑定 因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试 function foo(something) { this.a = something; } var obj1 = {}; var bar = foo.bind( obj1 ); bar( 2 ); console.log( obj1.a ); // 2 var baz = new bar( 3 ); console.log( obj1.a ); // 2 console.log( baz.a ); // 3 bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this 我们可认为new绑定优先级>显式绑定 综上，new绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级 相关链接 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/type_conversion.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/type_conversion.html","title":"Type Conversion","keywords":"","body":"面试官：谈谈 JavaScript 中的类型转换机制 一、概述 前面我们讲到，JS中有六种简单数据类型：undefined、null、boolean、string、number、symbol，以及引用类型：object 但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型 let x = y ? 1 : a; 上面代码中，x的值在编译阶段是无法获取的，只有等到程序运行时才能知道 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制 常见的类型转换有： 强制转换（显示转换） 自动转换（隐式转换） 二、显示转换 显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有： Number() parseInt() String() Boolean() Number() 将任意类型的值转化为数值 先给出类型转换规则： 实践一下： Number(324) // 324 // 字符串：如果可以被解析为数值，则转换为相应的数值 Number('324') // 324 // 字符串：如果不可以被解析为数值，返回 NaN Number('324abc') // NaN // 空字符串转为0 Number('') // 0 // 布尔值：true 转成 1，false 转成 0 Number(true) // 1 Number(false) // 0 // undefined：转成 NaN Number(undefined) // NaN // null：转成0 Number(null) // 0 // 对象：通常转换成NaN(除了只包含单个数值的数组) Number({a: 1}) // NaN Number([1, 2, 3]) // NaN Number([5]) // 5 从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN parseInt() parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来 parseInt('32a3') //32 String() 可以将任意类型的值转化成字符串 给出转换规则图： 实践一下： // 数值：转为相应的字符串 String(1) // \"1\" //字符串：转换后还是原来的值 String(\"a\") // \"a\" //布尔值：true转为字符串\"true\"，false转为字符串\"false\" String(true) // \"true\" //undefined：转为字符串\"undefined\" String(undefined) // \"undefined\" //null：转为字符串\"null\" String(null) // \"null\" //对象 String({a: 1}) // \"[object Object]\" String([1, 2, 3]) // \"1,2,3\" Boolean() 可以将任意类型的值转为布尔值，转换规则如下： 实践一下： Boolean(undefined) // false Boolean(null) // false Boolean(0) // false Boolean(NaN) // false Boolean('') // false Boolean({}) // true Boolean([]) // true Boolean(new Boolean(false)) // true 三、隐式转换 在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？ 我们这里可以归纳为两种情况发生隐式转换的场景： 比较运算（==、!=、>、）、if、while需要布尔值地方 算术运算（+、-、*、/、%） 除了上面的场景，还要求运算符两边的操作数不是同一类型 自动转换为布尔值 在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数 可以得出个小结： undefined null false +0 -0 NaN \"\" 除了上面几种会被转化成false，其他都换被转化成true 自动转换成字符串 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串 常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作 '5' + 1 // '51' '5' + true // \"5true\" '5' + false // \"5false\" '5' + {} // \"5[object Object]\" '5' + [] // \"5\" '5' + function (){} // \"5function (){}\" '5' + undefined // \"5undefined\" '5' + null // \"5null\" 自动转换成数值 除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值 '5' - '2' // 3 '5' * '2' // 10 true - 1 // 0 false - 1 // -1 '1' - 1 // 0 '5' * [] // 0 false / '5' // 0 'abc' - 1 // NaN null + 1 // 1 undefined + 1 // NaN null转为数值时，值为0 。undefined转为数值时，值为NaN 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/typeof_instanceof.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/typeof_instanceof.html","title":"Typeof Instanceof","keywords":"","body":"面试官：typeof 与 instanceof 区别 一、typeof typeof 操作符返回一个字符串，表示未经计算的操作数的类型 使用方法如下： typeof operand typeof(operand) operand表示对象或原始值的表达式，其类型将被返回 举个例子 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof null // 'object' typeof [] // 'object' typeof {} // 'object' typeof console // 'object' typeof console.log // 'function' 从上面例子，前6个都是基础数据类型。虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象 所以，null在 typeof之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为 null，直接通过===null来判断就好 同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错) if(typeof a != 'undefined'){ //变量存在 } 二、instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 使用如下： object instanceof constructor object为实例对象，constructor为构造函数 构造函数通过new可以实例对象，instanceof能判断这个对象是否是之前那个构造函数生成的对象 // 定义构建函数 let Car = function() {} let benz = new Car() benz instanceof Car // true let car = new String('xxx') car instanceof String // true let str = 'xxx' str instanceof String // false 关于instanceof的实现原理，可以参考下面： function myInstanceof(left, right) { // 这里先用typeof来判断基础数据类型，如果是，直接返回false if(typeof left !== 'object' || left === null) return false; // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象 let proto = Object.getPrototypeOf(left); while(true) { if(proto === null) return false; if(proto === right.prototype) return true;//找到相同原型对象，返回true proto = Object.getPrototypeof(proto); } } 也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则为false 三、区别 typeof与instanceof都是判断数据类型的方法，区别如下： typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值 instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型 而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断 可以看到，上述两种方法都有弊端，并不能满足所有场景的需求 如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串 如下 Object.prototype.toString({}) // \"[object Object]\" Object.prototype.toString.call({}) // 同上结果，加上call也ok Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call('1') // \"[object String]\" Object.prototype.toString.call(true) // \"[object Boolean]\" Object.prototype.toString.call(function(){}) // \"[object Function]\" Object.prototype.toString.call(null) //\"[object Null]\" Object.prototype.toString.call(undefined) //\"[object Undefined]\" Object.prototype.toString.call(/123/g) //\"[object RegExp]\" Object.prototype.toString.call(new Date()) //\"[object Date]\" Object.prototype.toString.call([]) //\"[object Array]\" Object.prototype.toString.call(document) //\"[object HTMLDocument]\" Object.prototype.toString.call(window) //\"[object Window]\" 了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法 function getType(obj){ let type = typeof obj; if (type !== \"object\") { // 先进行typeof判断，如果是基础数据类型，直接返回 return type; } // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1'); } 使用如下 getType([]) // \"Array\" typeof []是object，因此toString返回 getType('123') // \"string\" typeof 直接返回 getType(window) // \"Window\" toString返回 getType(null) // \"Null\"首字母大写，typeof null是object，需toString来判断 getType(undefined) // \"undefined\" typeof 直接返回 getType() // \"undefined\" typeof 直接返回 getType(function(){}) // \"function\" typeof能判断，因此首字母小写 getType(/123/g) //\"RegExp\" toString返回 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/JavaScript/visible.html":{"url":"笔记/web前端面试-面试官系列/JavaScript/visible.html","title":"Visible","keywords":"","body":"面试官：如何判断一个元素是否在可视区域中？ 一、用途 可视区域即我们浏览网页的设备肉眼可见的区域，如下图 在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如： 图片的懒加载 列表的无限滚动 计算广告元素的曝光情况 可点击链接的预加载 二、实现方式 判断一个元素是否在可视区域，我们常用的有三种办法： offsetTop、scrollTop getBoundingClientRect Intersection Observer offsetTop、scrollTop offsetTop，元素的上外边框至包含元素的上内边框之间的像素距离，其他offset属性如下图所示： 下面再来了解下clientWidth、clientHeight： clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding 这里可以看到client元素都不包括外边距 最后，关于scroll系列的属性如下： scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小 scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置 垂直滚动 scrollTop > 0 水平滚动 scrollLeft > 0 将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置 注意 上述属性都是只读的，每次访问都要重新开始 下面再看看如何实现判断： 公式如下： el.offsetTop - document.documentElement.scrollTop 代码实现： function isInViewPortOfOne (el) { // viewPortHeight 兼容所有浏览器写法 const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight const offsetTop = el.offsetTop const scrollTop = document.documentElement.scrollTop const top = offsetTop - scrollTop return top getBoundingClientRect 返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性 const target = document.querySelector('.target'); const clientRect = target.getBoundingClientRect(); console.log(clientRect); // { // bottom: 556.21875, // height: 393.59375, // left: 333, // right: 1017, // top: 162.625, // width: 684 // } 属性对应的关系图如下所示： 当页面发生滚动的时候，top与left属性值都会随之改变 如果一个元素在视窗之内的话，那么它一定满足下面四个条件： top 大于等于 0 left 大于等于 0 bottom 小于等于视窗高度 right 小于等于视窗宽度 实现代码如下： function isInViewPort(element) { const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const { top, right, bottom, left, } = element.getBoundingClientRect(); return ( top >= 0 && left >= 0 && right Intersection Observer Intersection Observer 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多 使用步骤主要分为两步：创建观察者和传入被观察者 创建观察者 const options = { // 表示重叠面积占被观察者的比例，从 0 - 1 取值， // 1 表示完全被包含 threshold: 1.0, root:document.querySelector('#scrollArea') // 必须是目标元素的父级元素 }; const callback = (entries, observer) => { ....} const observer = new IntersectionObserver(callback, options); 通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold 时会被执行` 关于callback回调函数常用属性如下： // 上段代码中被省略的 callback const callback = function(entries, observer) { entries.forEach(entry => { entry.time; // 触发的时间 entry.rootBounds; // 根元素的位置矩形，这种情况下为视窗位置 entry.boundingClientRect; // 被观察者的位置举行 entry.intersectionRect; // 重叠区域的位置矩形 entry.intersectionRatio; // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算） entry.target; // 被观察者 }); }; 传入被观察者 通过 observer.observe(target) 这一行代码即可简单的注册被观察者 const target = document.querySelector('.target'); observer.observe(target); 三、案例分析 实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色 Html结构如下： css样式如下： .container { display: flex; flex-wrap: wrap; } .target { margin: 5px; width: 20px; height: 20px; background: red; } 往container插入1000个元素 const $container = $(\".container\"); // 插入 100000 个 function createTargets() { const htmlString = new Array(100000) .fill('') .join(\"\"); $container.html(htmlString); } 这里，首先使用getBoundingClientRect方法进行判断元素是否在可视区域 function isInViewPort(element) { const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const { top, right, bottom, left } = element.getBoundingClientRect(); return top >= 0 && left >= 0 && right 然后开始监听scroll事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为yellow $(window).on(\"scroll\", () => { console.log(\"scroll !\"); $targets.each((index, element) => { if (isInViewPort(element)) { $(element).css(\"background-color\", \"yellow\"); } }); }); 通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了scroll事件，scroll事件伴随了大量的计算，会造成资源方面的浪费 下面通过Intersection Observer的形式同样实现相同的功能 首先创建一个观察者 const observer = new IntersectionObserver(getYellow, { threshold: 1.0 }); getYellow回调函数实现对背景颜色改变，如下： function getYellow(entries, observer) { entries.forEach(entry => { $(entry.target).css(\"background-color\", \"yellow\"); }); } 最后传入观察者，即.target元素 $targets.each((index, element) => { observer.observe(element); }); 可以看到功能同样完成，并且页面不会出现卡顿的情况 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"笔记/web前端面试-面试官系列/NodeJS/Buffer.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/Buffer.html","title":"Buffer","keywords":"","body":"面试官：说说对 Node 中的 Buffer 的理解？应用场景？ 一、是什么 在Node应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而Buffer就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据 在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量 如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理 这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 RAM 中 简单来讲，Nodejs不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在Buffer中，即在RAM中，直至将它们发送完毕 上面讲到了Buffer是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：00000000，也就是一个字节 例如： const buffer = Buffer.from(\"why\") 其存储过程如下图所示： 二、使用方法 Buffer 类在全局作用域中，无须require导入 创建Buffer的方法有很多种，我们讲讲下面的两种常见的形式： Buffer.from() Buffer.alloc() Buffer.from() const b1 = Buffer.from('10'); const b2 = Buffer.from('10', 'utf8'); const b3 = Buffer.from([10]); const b4 = Buffer.from(b3); console.log(b1, b2, b3, b4); // Buffer.alloc() const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区 const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节 console.log(bAlloc1); // console.log(bAlloc2); // 在上面创建buffer后，则能够toString的形式进行交互，默认情况下采取utf8字符编码形式，如下 const buffer = Buffer.from(\"你好\"); console.log(buffer); // const str = buffer.toString(); console.log(str); // 你好 如果编码与解码不是相同的格式则会出现乱码的情况，如下： const buffer = Buffer.from(\"你好\",\"utf-8 \"); console.log(buffer); // const str = buffer.toString(\"ascii\"); console.log(str); // d= e%= 当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下： const buf = Buffer.from('Node.js 技术栈', 'UTF-8'); console.log(buf) // console.log(buf.length) // 17 console.log(buf.toString('UTF-8', 0, 9)) // Node.js � console.log(buf.toString('UTF-8', 0, 11)) // Node.js 技 所支持的字符集有如下： ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的 utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8 utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF） ucs2，utf16le 的别名 base64：Base64 编码 latin：一种把 Buffer 编码成一字节编码的字符串的方式 binary：latin1 的别名， hex：将每个字节编码为两个十六进制字符 三、应用场景 Buffer的应用场景常常与流的概念联系在一起，例如有如下： I/O操作 加密解密 zlib.js I/O操作 通过流的形式，将一个文件的内容读取到另外一个文件 const fs = require('fs'); const inputStream = fs.createReadStream('input.txt'); // 创建可读流 const outputStream = fs.createWriteStream('output.txt'); // 创建可写流 inputStream.pipe(outputStream); // 管道读写 加解密 在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 string 或 Buffer 类型 zlib.js zlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能 参考文献 http://nodejs.cn/api/buffer.html https://segmentfault.com/a/1190000019894714 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/EventEmitter.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/EventEmitter.html","title":"EventEmitter","keywords":"","body":"面试官：说说Node中的EventEmitter? 如何实现一个EventEmitter? 一、是什么 我们了解到，Node采用了事件驱动机制，而EventEmitter就是Node实现事件驱动的基础 在EventEmitter的基础上，Node几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作 Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件 这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上 二、使用方法 Node的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式——观察者模式 在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们 基本代码如下所示： const EventEmitter = require('events') class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() function callback() { console.log('触发了event事件！') } myEmitter.on('event', callback) myEmitter.emit('event') myEmitter.removeListener('event', callback); 通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听 关于其常见的方法如下： emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部 emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部 emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件 emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件 emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除 emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件 三、实现过程 通过上面的方法了解，EventEmitter是一个构造函数，内部存在一个包含所有事件的对象 class EventEmitter { constructor() { this.events = {}; } } 其中events存放的监听事件的函数的结构如下： { \"event1\": [f1,f2,f3]， \"event2\": [f4,f5]， ... } 然后开始一步步实现实例方法，首先是emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下： emit(type, ...args) { this.events[type].forEach((item) => { Reflect.apply(item, this, args); }); } 当实现了emit方法之后，然后实现on、addListener、prependListener这三个实例方法，都是添加事件监听触发函数，实现也是大同小异 on(type, handler) { if (!this.events[type]) { this.events[type] = []; } this.events[type].push(handler); } addListener(type,handler){ this.on(type,handler) } prependListener(type, handler) { if (!this.events[type]) { this.events[type] = []; } this.events[type].unshift(handler); } 紧接着就是实现事件监听的方法removeListener/on removeListener(type, handler) { if (!this.events[type]) { return; } this.events[type] = this.events[type].filter(item => item !== handler); } off(type,handler){ this.removeListener(type,handler) } 最后再来实现once方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过fired属性值判断事件函数是否执行过 once(type, handler) { this.on(type, this._onceWrap(type, handler, this)); } _onceWrap(type, handler, target) { const state = { fired: false, handler, type , target}; const wrapFn = this._onceWrapper.bind(state); state.wrapFn = wrapFn; return wrapFn; } _onceWrapper(...args) { if (!this.fired) { this.fired = true; Reflect.apply(this.handler, this.target, args); this.target.off(this.type, this.wrapFn); } } 完整代码如下： class EventEmitter { constructor() { this.events = {}; } on(type, handler) { if (!this.events[type]) { this.events[type] = []; } this.events[type].push(handler); } addListener(type,handler){ this.on(type,handler) } prependListener(type, handler) { if (!this.events[type]) { this.events[type] = []; } this.events[type].unshift(handler); } removeListener(type, handler) { if (!this.events[type]) { return; } this.events[type] = this.events[type].filter(item => item !== handler); } off(type,handler){ this.removeListener(type,handler) } emit(type, ...args) { this.events[type].forEach((item) => { Reflect.apply(item, this, args); }); } once(type, handler) { this.on(type, this._onceWrap(type, handler, this)); } _onceWrap(type, handler, target) { const state = { fired: false, handler, type , target}; const wrapFn = this._onceWrapper.bind(state); state.wrapFn = wrapFn; return wrapFn; } _onceWrapper(...args) { if (!this.fired) { this.fired = true; Reflect.apply(this.handler, this.target, args); this.target.off(this.type, this.wrapFn); } } } 测试代码如下： const ee = new EventEmitter(); // 注册所有事件 ee.once('wakeUp', (name) => { console.log(`${name} 1`); }); ee.on('eat', (name) => { console.log(`${name} 2`) }); ee.on('eat', (name) => { console.log(`${name} 3`) }); const meetingFn = (name) => { console.log(`${name} 4`) }; ee.on('work', meetingFn); ee.on('work', (name) => { console.log(`${name} 5`) }); ee.emit('wakeUp', 'xx'); ee.emit('wakeUp', 'xx'); // 第二次没有触发 ee.emit('eat', 'xx'); ee.emit('work', 'xx'); ee.off('work', meetingFn); // 移除事件 ee.emit('work', 'xx'); // 再次工作 参考文献 http://nodejs.cn/api/events.html#events_class_eventemitter https://segmentfault.com/a/1190000015762318 https://juejin.cn/post/6844903781230968845 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/Stream.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/Stream.html","title":"Stream","keywords":"","body":"面试官：说说对 Node 中的 Stream 的理解？应用场景？ 一、是什么 流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出 Node.js中很多对象都实现了流，总之它是会冒数据（以 Buffer 为单位） 它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中 流可以分成三部分：source、dest、pipe 在source和dest之间有一个连接的管道pipe,它的基本语法是source.pipe(dest)，source和dest就是通过pipe连接，让数据从source流向了dest，如下图所示： 二、种类 在NodeJS，几乎所有的地方都使用到了流的概念，分成四个种类： 可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件 可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容 双工流： 既可读又可写的流。例如 net.Socket 转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据 在NodeJS中HTTP服务器模块中，request 是可读流，response 是可写流。还有fs 模块，能同时处理可读和可写文件流 可读流和可写流都是单向的，比较容易理解，而另外两个是双向的 双工流 之前了解过websocket通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系 如下图所示： 基本代码如下： const { Duplex } = require('stream'); const myDuplex = new Duplex({ read(size) { // ... }, write(chunk, encoding, callback) { // ... } }); 双工流 双工流的演示图如下所示： 除了上述压缩包的例子，还比如一个 babel，把es6转换为，我们在左边写入 es6，从右边读取 es5 基本代码如下所示： const { Transform } = require('stream'); const myTransform = new Transform({ transform(chunk, encoding, callback) { // ... } }); 三、应用场景 stream的应用场景主要就是处理IO操作，而http请求和文件操作都属于IO操作 试想一下，如果一次IO操作过大，硬件的开销就过大，而将此次大的IO操作进行分段操作，让数据像水管一样流动，直到流动完成 常见的场景有： get请求返回文件给客户端 文件操作 一些打包工具的底层操作 get请求返回文件给客户端 使用stream流返回文件，res也是一个stream对象，通过pipe管道将文件数据返回 const server = http.createServer(function (req, res) { const method = req.method; // 获取请求方法 if (method === 'GET') { // get 请求 const fileName = path.resolve(__dirname, 'data.txt'); let stream = fs.createReadStream(fileName); stream.pipe(res); // 将 res 作为 stream 的 dest } }); server.listen(8000); 文件操作 创建一个可读数据流readStream，一个可写数据流writeStream，通过pipe管道把数据流转过去 const fs = require('fs') const path = require('path') // 两个文件名 const fileName1 = path.resolve(__dirname, 'data.txt') const fileName2 = path.resolve(__dirname, 'data-bak.txt') // 读取文件的 stream 对象 const readStream = fs.createReadStream(fileName1) // 写入文件的 stream 对象 const writeStream = fs.createWriteStream(fileName2) // 通过 pipe执行拷贝，数据流转 readStream.pipe(writeStream) // 数据读取完成监听，即拷贝完成 readStream.on('end', function () { console.log('拷贝完成') }) 一些打包工具的底层操作 目前一些比较火的前端打包构建工具，都是通过node.js编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来stream，如gulp 参考文献 https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa https://juejin.cn/post/6844903891083984910 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/event_loop.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/event_loop.html","title":"Event Loop","keywords":"","body":"面试官：说说对Nodejs中的事件循环机制理解? 一、是什么 在浏览器事件循环中，我们了解到javascript在浏览器中的事件循环机制，其是根据HTML5定义的规范来实现 而在NodeJS中，事件循环是基于libuv实现，libuv是一个多平台的专注于异步IO的库，如下图最右侧所示： 上图EVENT_QUEUE 给人看起来只有一个队列，但EventLoop存在6个阶段，每个阶段都有对应的一个先进先出的回调队列 二、流程 上节讲到事件循环分成了六个阶段，对应如下： timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数 I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调 闲置阶段(idle, prepare)：仅系统内部使用 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞 检查阶段(check)：setImmediate() 回调函数在这里执行 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...) 每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段 除了上述6个阶段，还存在process.nextTick，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队 流程图如下所示： 在Node中，同样存在宏任务和微任务，与浏览器中的事件循环相似 微任务对应有： next tick queue：process.nextTick other queue：Promise的then回调、queueMicrotask 宏任务对应有： timer queue：setTimeout、setInterval poll queue：IO事件 check queue：setImmediate close queue：close事件 其执行顺序为： next tick microtask queue other microtask queue timer queue poll queue check queue close queue 三、题目 通过上面的学习，下面开始看看题目 async function async1() { console.log('async1 start') await async2() console.log('async1 end') } async function async2() { console.log('async2') } console.log('script start') setTimeout(function () { console.log('setTimeout0') }, 0) setTimeout(function () { console.log('setTimeout2') }, 300) setImmediate(() => console.log('setImmediate')); process.nextTick(() => console.log('nextTick1')); async1(); process.nextTick(() => console.log('nextTick2')); new Promise(function (resolve) { console.log('promise1') resolve(); console.log('promise2') }).then(function () { console.log('promise3') }) console.log('script end') 分析过程： 先找到同步任务，输出script start 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中 遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中 遇到第一个setImmediate，将里面的回调函数放到 check 队列中 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行 执行 async1函数，输出 async1 start 执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环 遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2 then里面的回调函数进入微任务队列 遇到同步任务，输出 script end 执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2 然后执行微任务队列，依次输出 async1 end、promise3 执行timer 队列，依次输出 setTimeout0 接着执行 check 队列，依次输出 setImmediate 300ms后，timer 队列存在任务，执行输出 setTimeout2 执行结果如下： script start async1 start async2 promise1 promise2 script end nextTick1 nextTick2 async1 end promise3 setTimeout0 setImmediate setTimeout2 最后有一道是关于setTimeout与setImmediate的输出顺序 setTimeout(() => { console.log(\"setTimeout\"); }, 0); setImmediate(() => { console.log(\"setImmediate\"); }); 输出情况如下： 情况一： setTimeout setImmediate 情况二： setImmediate setTimeout 分析下流程： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入times阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 这里的关键在于这1ms，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout先执行，如果1毫秒还没到，就先执行了setImmediate 参考文献 https://segmentfault.com/a/1190000012258592 https://juejin.cn/post/6844904100195205133 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/file_upload.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/file_upload.html","title":"File Upload","keywords":"","body":"面试官：如何实现文件上传？说说你的思路 一、是什么 文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能 因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里 对于文件上传，我们需要设置请求头为content-type:multipart/form-data multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件 结构如下： POST /t2/upload.do HTTP/1.1 User-Agent: SOHUWapRebot Accept-Language: zh-cn,zh;q=0.5 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Content-Length: 60408 Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC Host: w.sohu.com --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC Content-Disposition: form-data; name=\"city\" Santa colo --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC Content-Disposition: form-data;name=\"desc\" Content-Type: text/plain; charset=UTF-8 Content-Transfer-Encoding: 8bit ... --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC Content-Disposition: form-data;name=\"pic\"; filename=\"photo.jpg\" Content-Type: application/octet-stream Content-Transfer-Encoding: binary ... binary data of the jpg ... --ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC-- boundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由———XXX开始，以———XXX结尾 而xxx是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现 每个表单项必须包含一个 Content-Disposition 头，其他的头信息则为可选项， 比如 Content-Type Content-Disposition 包含了 type和 一个名字为name的 parameter，type 是 form-data，name参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 filename参数，值就是文件名 Content-Disposition: form-data; name=\"user\"; filename=\"logo.png\" 至于使用multipart/form-data，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高 二、如何实现 关于文件的上传的上传，我们可以分成两步骤： 文件的上传 文件的解析 文件上传 传统前端文件上传的表单结构如下： action 就是我们的提交到的接口，enctype=\"multipart/form-data\" 就是指定上传文件格式，input 的 name 属性一定要等于file 文件解析 在服务器中，这里采用koa2中间件的形式解析上传的文件数据，分别有下面两种形式： koa-body koa-multer koa-body 安装依赖 npm install koa-body 引入koa-body中间件 const koaBody = require('koa-body'); app.use(koaBody({ multipart: true, formidable: { maxFileSize: 200*1024*1024 // 设置上传文件大小最大限制，默认2M } })); 获取上传的文件 const file = ctx.request.files.file; // 获取上传文件 获取文件数据后，可以通过fs模块将文件保存到指定目录 router.post('/uploadfile', async (ctx, next) => { // 上传单个文件 const file = ctx.request.files.file; // 获取上传文件 // 创建可读流 const reader = fs.createReadStream(file.path); let filePath = path.join(__dirname, 'public/upload/') + `/${file.name}`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); return ctx.body = \"上传成功！\"; }); koa-multer 安装依赖： npm install koa-multer 使用 multer 中间件实现文件上传 const storage = multer.diskStorage({ destination: (req, file, cb) => { cb(null, \"./upload/\") }, filename: (req, file, cb) => { cb(null, Date.now() + path.extname(file.originalname)) } }) const upload = multer({ storage }); const fileRouter = new Router(); fileRouter.post(\"/upload\", upload.single('file'), (ctx, next) => { console.log(ctx.req.file); // 获取文件 }) app.use(fileRouter.routes()); 参考文献 https://segmentfault.com/a/1190000037411957 https://www.jianshu.com/p/29e38bcc8a1d 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/fs.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/fs.html","title":"Fs","keywords":"","body":"面试官：说说对 Node 中的 fs模块的理解? 有哪些常用方法 一、是什么 fs（filesystem），该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装 可以说，所有与文件的操作都是通过fs核心模块实现 导入模块如下： const fs = require('fs'); 这个模块对所有文件系统操作提供异步（不具有sync 后缀）和同步（具有 sync 后缀）两种操作方式，而供开发者选择 二、文件知识 在计算机中有关于文件的知识： 权限位 mode 标识位 flag 文件描述为 fd 权限位 mode 针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0 如在linux查看文件权限位： drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core -rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md 在开头前十位中，d为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限 标识位 标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示： 符号 含义 r 读取文件，如果文件不存在则抛出异常。 r+ 读取并写入文件，如果文件不存在则抛出异常。 rs 读取并写入文件，指示操作系统绕开本地文件系统缓存。 w 写入文件，文件不存在会被创建，存在则清空后写入。 wx 写入文件，排它方式打开。 w+ 读取并写入文件，文件不存在则创建文件，存在则清空后写入。 wx+ 和 w+ 类似，排他方式打开。 a 追加写入，文件不存在则创建文件。 ax 与 a 类似，排他方式打开。 a+ 读取并追加写入，不存在则创建。 ax+ 与 a+ 类似，排他方式打开。 文件描述为 fd 操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件 Window系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符 在 NodeJS中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出） 三、方法 下面针对fs模块常用的方法进行展开： 文件读取 文件写入 文件追加写入 文件拷贝 创建目录 文件读取 fs.readFileSync 同步读取，参数如下： 第一个参数为读取文件的路径或文件描述符 第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding 结果为返回文件的内容 const fs = require(\"fs\"); let buf = fs.readFileSync(\"1.txt\"); let data = fs.readFileSync(\"1.txt\", \"utf8\"); console.log(buf); // console.log(data); // Hello fs.readFile 异步读取方法 readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行 const fs = require(\"fs\"); fs.readFile(\"1.txt\", \"utf8\", (err, data) => { if(!err){ console.log(data); // Hello } }); 文件写入 writeFileSync 同步写入，有三个参数： 第一个参数为写入文件的路径或文件描述符 第二个参数为写入的数据，类型为 String 或 Buffer 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding const fs = require(\"fs\"); fs.writeFileSync(\"2.txt\", \"Hello world\"); let data = fs.readFileSync(\"2.txt\", \"utf8\"); console.log(data); // Hello world writeFile 异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行 const fs = require(\"fs\"); fs.writeFile(\"2.txt\", \"Hello world\", err => { if (!err) { fs.readFile(\"2.txt\", \"utf8\", (err, data) => { console.log(data); // Hello world }); } }); 文件追加写入 appendFileSync 参数如下： 第一个参数为写入文件的路径或文件描述符 第二个参数为写入的数据，类型为 String 或 Buffer 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding const fs = require(\"fs\"); fs.appendFileSync(\"3.txt\", \" world\"); let data = fs.readFileSync(\"3.txt\", \"utf8\"); appendFile 异步追加写入方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行 const fs = require(\"fs\"); fs.appendFile(\"3.txt\", \" world\", err => { if (!err) { fs.readFile(\"3.txt\", \"utf8\", (err, data) => { console.log(data); // Hello world }); } }); 文件拷贝 copyFileSync 同步拷贝 const fs = require(\"fs\"); fs.copyFileSync(\"3.txt\", \"4.txt\"); let data = fs.readFileSync(\"4.txt\", \"utf8\"); console.log(data); // Hello world copyFile 异步拷贝 const fs = require(\"fs\"); fs.copyFile(\"3.txt\", \"4.txt\", () => { fs.readFile(\"4.txt\", \"utf8\", (err, data) => { console.log(data); // Hello world }); }); 创建目录 mkdirSync 同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常 // 假设已经有了 a 文件夹和 a 下的 b 文件夹 fs.mkdirSync(\"a/b/c\") mkdir 异步创建，第二个参数为回调函数 fs.mkdir(\"a/b/c\", err => { if (!err) console.log(\"创建成功\"); }); 参考文献 http://nodejs.cn/api/fs.html https://segmentfault.com/a/1190000019913303 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/global.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/global.html","title":"Global","keywords":"","body":"面试官：说说 Node. js 有哪些全局对象？ 一、是什么 在浏览器 JavaScript 中，通常window 是全局对象， 而 Nodejs中的全局对象是 global 在NodeJS里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过exports对象的使用将其传递给模块外部 所以，在NodeJS中，用var声明的变量并不属于全局的变量，只在当前模块生效 像上述的global全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值 二、有哪些 将全局对象分成两类： 真正的全局对象 模块级别的全局变量 真正的全局对象 下面给出一些常见的全局对象： Class:Buffer process console clearInterval、setInterval clearTimeout、setTimeout global Class:Buffer 可以处理二进制以及非Unicode编码的数据 在Buffer类实例化中存储了原始数据。Buffer类似于一个整数数组，在V8堆原始存储空间给它分配了内存 一旦创建了Buffer实例，则无法改变大小 process 进程对象，提供有关当前进程的信息和控制 包括在执行node程序进程时，如果需要传递参数，我们想要获取这个参数需要在process内置对象中 启动进程： node index.js 参数1 参数2 参数3 index.js文件如下： process.argv.forEach((val, index) => { console.log(`${index}: ${val}`); }); 输出如下： /usr/local/bin/node /Users/mjr/work/node/process-args.js 参数1 参数2 参数3 除此之外，还包括一些其他信息如版本、操作系统等 console 用来打印stdout和stderr 最常用的输入内容的方式：console.log console.log(\"hello\"); 清空控制台：console.clear console.clear 打印函数的调用栈：console.trace function test() { demo(); } function demo() { foo(); } function foo() { console.trace(); } test(); clearInterval、setInterval 设置定时器与清除定时器 setInterval(callback, delay[, ...args]) callback每delay毫秒重复执行一次 clearInterval则为对应发取消定时器的方法 clearTimeout、setTimeout 设置延时器与清除延时器 setTimeout(callback,delay[,...args]) callback在delay毫秒后执行一次 clearTimeout则为对应取消延时器的方法 global 全局命名空间对象，墙面讲到的process、console、setTimeout等都有放到global中 console.log(process === global.process) // true 模块级别的全局对象 这些全局对象是模块中的变量，只是每个模块都有，看起来就像全局变量，像在命令交互中是不可以使用，包括： __dirname __filename exports module require __dirname 获取当前文件所在的路径，不包括后面的文件名 从 /Users/mjr 运行 node example.js： console.log(__dirname); // 打印: /Users/mjr __filename 获取当前文件所在的路径和文件名称，包括后面的文件名称 从 /Users/mjr 运行 node example.js： console.log(__filename); // 打印: /Users/mjr/example.js exports module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容 exports.name = name; exports.age = age; exports.sayHello = sayHello; module 对当前模块的引用，通过module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容 require 用于引入模块、 JSON、或本地文件。 可以从 node_modules 引入模块。 可以使用相对路径引入本地模块或JSON文件，路径会根据__dirname定义的目录名或当前工作目录进行处理 参考文献 http://nodejs.cn/api/globals.html https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/jwt.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/jwt.html","title":"Jwt","keywords":"","body":"面试官：如何实现jwt鉴权机制？说说你的思路 一、是什么 JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息 在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下： 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证 后续访问会根据这个令牌判断用户时候有权限进行访问 Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了编码 header 每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256 { \"alg\": \"HS256\", \"typ\": \"JWT\" } 因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 payload 载荷即消息体，这里会存放实际的内容，也就是Token的数据声明，例如用户的id和name，默认情况下也会携带令牌的签发时间iat，通过还可以设置过期时间，如下： { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 } 同样进行Base64编码后，字符串如下： eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ Signature 签名是对头部和载荷内容进行签名，一般情况，设置一个secretKey，对前两个的结果进行HMACSHA25算法，公式如下： Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey) 一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致 二、如何实现 Token的使用分成了两部分： 生成token：登录成功的时候，颁发token 验证token：访问某些资源或者接口时，验证token 生成 token 借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token： 第一个参数指的是 Payload 第二个是秘钥，服务端特有 第三个参数是 option，可以定义 token 过期时间 const crypto = require(\"crypto\"), jwt = require(\"jsonwebtoken\"); // TODO:使用数据库 // 这里应该是用数据库存储，这里只是演示用 let userList = []; class UserController { // 用户登录 static async login(ctx) { const data = ctx.request.body; if (!data.name || !data.password) { return ctx.body = { code: \"000002\", message: \"参数不合法\" } } const result = userList.find(item => item.name === data.name && item.password === crypto.createHash('md5').update(data.password).digest('hex')) if (result) { // 生成token const token = jwt.sign( { name: result.name }, \"test_token\", // secret { expiresIn: 60 * 60 } // 过期时间：60 * 60 s ); return ctx.body = { code: \"0\", message: \"登录成功\", data: { token } }; } else { return ctx.body = { code: \"000002\", message: \"用户名或密码错误\" }; } } } module.exports = UserController; 在前端接收到token后，一般情况会通过localStorage进行缓存，然后将token放到HTTP请求头Authorization 中，关于Authorization 的设置，前面要加上 Bearer ，注意后面带有空格 axios.interceptors.request.use(config => { const token = localStorage.getItem('token'); config.headers.common['Authorization'] = 'Bearer ' + token; // 留意这里的 Authorization return config; }) 校验token 使用 koa-jwt 中间件进行验证，方式比较简单 / 注意：放在路由前面 app.use(koajwt({ secret: 'test_token' }).unless({ // 配置白名单 path: [/\\/api\\/register/, /\\/api\\/login/] })) secret 必须和 sign 时候保持一致 可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验 校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验 获取token用户的信息方法如下： router.get('/api/userInfo',async (ctx,next) =>{ const authorization = ctx.header.authorization // 获取jwt const token = authorization.replace('Beraer ','') const result = jwt.verify(token,'test_token') ctx.body = result 注意：上述的HMA256加密算法为单秘钥的形式，一旦泄露后果非常的危险 在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌 这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择RS256 三、优缺点 优点： json具有通用性，所以可以跨语言 组成简单，字节占用小，便于传输 服务端无需保存会话信息，很容易进行水平扩展 一处生成，多处使用，可以在分布式系统中，解决单点登录问题 可防护CSRF攻击 缺点： payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息 需要保护好加密密钥，一旦泄露后果不堪设想 为避免token被劫持，最好使用https协议 参考文献 http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html https://blog.wangjunfeng.com/post/golang-jwt/ https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/middleware.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/middleware.html","title":"Middleware","keywords":"","body":"面试官：说说对中间件概念的理解，如何封装 node 中间件？ 一、是什么 中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的 在NodeJS中，中间件主要是指封装http请求细节处理的方法 例如在express、koa等web框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数 在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作 二、封装 koa是基于NodeJS当前比较流行的web框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 Koa 应用 Koa 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数： ctx ：封装了request 和 response 的变量 next ：进入下一个要执行的中间件的函数 下面就针对koa进行中间件的封装： Koa的中间件就是函数，可以是async 函数，或是普通函数 // async 函数 app.use(async (ctx, next) => { const start = Date.now(); await next(); const ms = Date.now() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); }); // 普通函数 app.use((ctx, next) => { const start = Date.now(); return next().then(() => { const ms = Date.now() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); }); }); 下面则通过中间件封装http请求过程中几个常用的功能： token校验 module.exports = (options) => async (ctx, next) { try { // 获取 token const token = ctx.header.authorization if (token) { try { // verify 函数验证 token，并获取用户相关信息 await verify(token) } catch (err) { console.log(err) } } // 进入下一个中间件 await next() } catch (err) { console.log(err) } } 日志模块 const fs = require('fs') module.exports = (options) => async (ctx, next) => { const startTime = Date.now() const requestTime = new Date() await next() const ms = Date.now() - startTime; let logout = `${ctx.request.ip} -- ${requestTime} -- ${ctx.method} -- ${ctx.url} -- ${ms}ms`; // 输出日志文件 fs.appendFileSync('./log.txt', logout + '\\n') } Koa存在很多第三方的中间件，如koa-bodyparser、koa-static等 下面再来看看它们的大体的简单实现： koa-bodyparser koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值 // 文件：my-koa-bodyparser.js const querystring = require(\"querystring\"); module.exports = function bodyParser() { return async (ctx, next) => { await new Promise((resolve, reject) => { // 存储数据的数组 let dataArr = []; // 接收数据 ctx.req.on(\"data\", data => dataArr.push(data)); // 整合数据并使用 Promise 成功 ctx.req.on(\"end\", () => { // 获取请求数据的类型 json 或表单 let contentType = ctx.get(\"Content-Type\"); // 获取数据 Buffer 格式 let data = Buffer.concat(dataArr).toString(); if (contentType === \"application/x-www-form-urlencoded\") { // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body ctx.request.body = querystring.parse(data); } else if (contentType === \"applaction/json\") { // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body ctx.request.body = JSON.parse(data); } // 执行成功的回调 resolve(); }); }); // 继续向下执行 await next(); }; }; koa-static koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件 const fs = require(\"fs\"); const path = require(\"path\"); const mime = require(\"mime\"); const { promisify } = require(\"util\"); // 将 stat 和 access 转换成 Promise const stat = promisify(fs.stat); const access = promisify(fs.access) module.exports = function (dir) { return async (ctx, next) => { // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 / let realPath = path.join(dir, ctx.path); try { // 获取 stat 对象 let statObj = await stat(realPath); // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html if (statObj.isFile()) { ctx.set(\"Content-Type\", `${mime.getType()};charset=utf8`); ctx.body = fs.createReadStream(realPath); } else { let filename = path.join(realPath, \"index.html\"); // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理 await access(filename); // 存在设置文件类型并响应内容 ctx.set(\"Content-Type\", \"text/html;charset=utf8\"); ctx.body = fs.createReadStream(filename); } } catch (e) { await next(); } } } 三、总结 在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据 koa本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得web应用具备良好的可拓展性和组合性 通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式 参考文献 https://segmentfault.com/a/1190000017897279 https://www.jianshu.com/p/81b6ebc0dd85 https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/nodejs.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/nodejs.html","title":"Nodejs","keywords":"","body":"面试官：说说你对Node.js 的理解？优缺点？应用场景？ 一、是什么 Node.js 是一个开源与跨平台的 JavaScript 运行时环境 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能 可以理解为 Node.js 就是一个服务器端的、非阻塞式I/O的、事件驱动的JavaScript运行环境 非阻塞异步 Nodejs采用了非阻塞型I/O机制，在做I/O操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作 例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率 事件驱动 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数 比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理 二、优缺点 优点： 处理高并发场景性能更佳 适合I/O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作 因为Nodejs是单线程，带来的缺点有： 不适合CPU密集型应用 只支持单核CPU，不能充分利用CPU 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 三、应用场景 借助Nodejs的特点和弊端，其应用场景分类如下： 善于I/O，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程 大量并发的I/O，应用程序内部并不需要进行非常复杂的处理 与 websocket 配合，开发长连接的实时交互应用程序 具体场景可以表现为如下： 第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序 第二大类：基于web、canvas等多人联网游戏 第三大类：基于web的多人实时聊天客户端、聊天室、图文直播 第四大类：单页面浏览器应用程序 第五大类：操作数据库、为前端和移动端提供基于json的API 其实，Nodejs能实现几乎一切的应用，只考虑适不适合使用它 参考文献 http://nodejs.cn/ https://segmentfault.com/a/1190000019854308 https://segmentfault.com/a/1190000005173218 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/paging.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/paging.html","title":"Paging","keywords":"","body":"面试官：如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互? 一、是什么 在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据 要实现分页功能，实际上就是从结果集中显示第1~10条记录作为第1页，显示第11~20条记录作为第2页，以此类推 因此，分页实际上就是从结果集中截取出第M~N条记录 二、如何实现 前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据 { \"totalCount\": 1836, // 总的条数 \"totalPages\": 92, // 总页数 \"currentPage\": 1 // 当前页数 \"data\": [ // 当前页的数据 { ... } ] 后端采用mysql作为数据的持久性存储 前端向后端发送目标的页码page以及每页显示数据的数量pageSize，默认情况每次取10条数据，则每一条数据的起始位置start为： const start = (page - 1) * pageSize 当确定了limit和start的值后，就能够确定SQL语句： const sql = `SELECT * FROM record limit ${pageSize} OFFSET ${start};` 上诉SQL语句表达的意思为：截取从start到start+pageSize之间（左闭右开）的数据 关于查询数据总数的SQL语句为，record为表名： SELECT COUNT(*) FROM record 因此后端的处理逻辑为： 获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10 编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询 查询数据库，返回总数据量、总页数、当前页、当前页数据给前端 代码如下所示： router.all('/api', function (req, res, next) { var param = ''; // 获取参数 if (req.method == \"POST\") { param = req.body; } else { param = req.query || req.params; } if (param.page == '' || param.page == null || param.page == undefined) { res.end(JSON.stringify({ msg: '请传入参数page', status: '102' })); return; } const pageSize = param.pageSize || 10; const start = (param.page - 1) * pageSize; const sql = `SELECT * FROM record limit ${pageSize} OFFSET ${start};` pool.getConnection(function (err, connection) { if (err) throw err; connection.query(sql, function (err, results) { connection.release(); if (err) { throw err } else { // 计算总页数 var allCount = results[0][0]['COUNT(*)']; var allPage = parseInt(allCount) / 20; var pageStr = allPage.toString(); // 不能被整除 if (pageStr.indexOf('.') > 0) { allPage = parseInt(pageStr.split('.')[0]) + 1; } var list = results[1]; res.end(JSON.stringify({ msg: '操作成功', status: '200', totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list })); } }) }) }); 三、总结 通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量pageSize，然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT 总是设定为 pageSize OFFSET 计算公式为 pageSize * (pageIndex - 1) 确定了这两个值，就能查询出第 N页的数据 参考文献 https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/performance.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/performance.html","title":"Performance","keywords":"","body":"面试官：Node性能如何进行监控以及优化？ 一、 是什么 Node作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下： CPU 内存 I/O 网络 CPU 主要分成了两部分： CPU负载：在某个时间段内，占用以及等待CPU的进程总数 CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) / CPU总时间 这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标 Node应用一般不会消耗很多的CPU，如果CPU占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞 内存指标 内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标 // /app/lib/memory.js const os = require('os'); // 获取当前Node内存堆栈情况 const { rss, heapUsed, heapTotal } = process.memoryUsage(); // 获取系统空闲内存 const sysFree = os.freemem(); // 获取系统总内存 const sysTotal = os.totalmem(); module.exports = { memory: () => { return { sys: 1 - sysFree / sysTotal, // 系统内存占用率 heap: heapUsed / headTotal, // Node堆内存占用率 node: rss / sysTotal, // Node占用系统内存的比例 } } } rss：表示node进程占用的内存总量。 heapTotal：表示堆内存的总量。 heapUsed：实际堆内存的使用量。 external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量 在Node中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露 磁盘 I/O 硬盘的IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍 内存 IO比磁盘IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached等 并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决 二、如何监控 关于性能方面的监控，一般情况都需要借助工具来实现 这里采用Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require 一次，无需改动任何业务代码即可开启内核级别的性能监控分析 使用方法如下： 在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称： const easyMonitor = require('easy-monitor'); easyMonitor('你的项目名称'); 打开你的浏览器，访问 http://localhost:12333 ，即可看到进程界面 关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档 三、如何优化 关于Node的性能优化的方式有： 使用最新版本Node.js 正确使用流 Stream 代码层面优化 内存管理优化 使用最新版本Node.js 每个版本的性能提升主要来自于两个方面： V8 的版本更新 Node.js 内部代码的更新优化 正确使用流 Stream 在Node中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存 const http = require('http'); const fs = require('fs'); // bad http.createServer(function (req, res) { fs.readFile(__dirname + '/data.txt', function (err, data) { res.end(data); }); }); // good http.createServer(function (req, res) { const stream = fs.createReadStream(__dirname + '/data.txt'); stream.pipe(res); }); 代码层面优化 合并查询，将多次查询合并一次，减少数据库的查询次数 // bad for user_id in userIds let account = user_account.findOne(user_id) // good const user_account_map = {} // 注意这个对象将会消耗大量内存。 user_account.find(user_id in user_ids).forEach(account){ user_account_map[account.user_id] = account } for user_id in userIds var account = user_account_map[user_id] 内存管理优化 在 V8 中，主要将内存分为新生代和老生代两代： 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象 若新生代内存空间不够，直接分配到老生代 通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低 如下面情况： const buffer = fs.readFileSync(__dirname + '/source/index.htm'); app.use( mount('/', async (ctx) => { ctx.status = 200; ctx.type = 'html'; ctx.body = buffer; leak.push(fs.readFileSync(__dirname + '/source/index.htm')); }) ); const leak = []; leak的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一 而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作 例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动 使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能 参考文献 https://segmentfault.com/a/1190000039327565 https://zhuanlan.zhihu.com/p/50055740 https://segmentfault.com/a/1190000010231628 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/process.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/process.html","title":"Process","keywords":"","body":"面试官：说说对 Node 中的 process 的理解？有哪些常用方法？ 一、是什么 process 对象是一个全局变量，提供了有关当前 Node.js进程的信息并对其进行控制，作为一个全局变量 我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器 当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享 由于JavaScript是一个单线程语言，所以通过node xxx启动一个文件后，只有一条主线程 二、属性与方法 关于process常见的属性有如下： process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick：这个在谈及 EventLoop 时经常为会提到 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录， process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出 process.title 指定进程名称，有的时候需要给进程指定一个名称 下面再稍微介绍下某些方法的使用： process.cwd() 返回当前 Node进程执行的目录 一个Node 模块 A 通过 NPM 发布，项目 B 中使用了模块 A。在 A 中需要操作 B 项目下的文件时，就可以用 process.cwd() 来获取 B 项目的路径 process.argv 在终端通过 Node 执行命令的时候，通过 process.argv 可以获取传入的命令行参数，返回值是一个数组： 0: Node 路径（一般用不到，直接忽略） 1: 被执行的 JS 文件路径（一般用不到，直接忽略） 2~n: 真实传入命令的参数 所以，我们只要从 process.argv[2] 开始获取就好了 const args = process.argv.slice(2); process.env 返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。 一般我们会在 process.env 上挂载一些变量标识当前的环境。比如最常见的用 process.env.NODE_ENV 区分 development 和 production 在 vue-cli 的源码中也经常会看到 process.env.VUE_CLI_DEBUG 标识当前是不是 DEBUG 模式 process.nextTick() 我们知道NodeJs是基于事件轮询，在这个过程中，同一时间只会处理一件事情 在这种处理模式下，process.nextTick()就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行 例如下面例子将一个foo函数在下一个时间点调用 function foo() { console.error('foo'); } process.nextTick(foo); console.error('bar'); 输出结果为bar、foo 虽然下述方式也能实现同样效果： setTimeout(foo, 0); console.log('bar'); 两者区别在于： process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的 参考文献 http://nodejs.cn/api/process.html https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/NodeJS/require_order.html":{"url":"笔记/web前端面试-面试官系列/NodeJS/require_order.html","title":"Require Order","keywords":"","body":"面试官：说说 Node 文件查找的优先级以及 Require 方法的文件查找策略? 一、模块规范 NodeJS对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发： 在Node中每一个js文件都是一个单独的模块 模块中包括CommonJS规范的核心变量：exports、module.exports、require 通过上述变量进行模块化开发 而模块化的核心是导出与导入，在Node中通过exports与module.exports负责对模块中的内容进行导出，通过require函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容 二、查找策略 require方法接收一下几种参数的传递： 原生模块：http、fs、path等 相对路径的文件模块：./mod或../mod 绝对路径的文件模块：/pathtomodule/mod 目录作为模块：./dirname 非原生模块的文件模块：mod require参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图： 从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块 原生模块 而像原生模块这些，通过require方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载 绝对路径、相对路径 如果require绝对路径的文件，则直接查找对应的路径，速度最快 相对路径的模块则相对于当前调用require的文件去查找 如果按确切的文件名没有找到模块，则 NodeJs 会尝试带上 .js、.json或 .node拓展名再加载 目录作为模块 默认情况是根据根目录中package.json文件的main来指定目录模块，如： { \"name\" : \"some-library\", \"main\" : \"main.js\" } 如果这是在./some-library node_modules目录中，则 require('./some-library') 会试图加载 ./some-library/main.js 如果目录里没有 package.json文件，或者 main入口不存在或无法解析，则会试图加载目录下的 index.js 或 index.node 文件 非原生模块 在每个文件中都存在module.paths，表示模块的搜索路径，require就是根据其来寻找文件 在window下输出如下： [ 'c:\\\\nodejs\\\\node_modules', 'c:\\\\node_modules' ] 可以看出module path的生成规则为：从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录，依次迭代，直到根目录下的node_modules目录 当都找不到的时候，则会从系统NODE_PATH环境变量查找 举个例子： 如果在/home/ry/projects/foo.js文件里调用了 require('bar.js')，则 Node.js 会按以下顺序查找： /home/ry/projects/node_modules/bar.js /home/ry/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 这使得程序本地化它们的依赖，避免它们产生冲突 三、总结 通过上面模块的文件查找策略之后，总结下文件查找的优先级： 缓存的模块优先级最高 如果是内置模块，则直接返回，优先级仅次缓存的模块 如果是绝对路径 / 开头，则从根目录找 如果是相对路径 ./开头，则从当前require文件相对位置找 如果文件没有携带后缀，先从js、json、node按顺序查找 如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js 如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录 参考文献 http://nodejs.cn/api/modules.html#modules_file_modules https://blog.csdn.net/qq_36801250/article/details/106352686 https://www.cnblogs.com/samve/p/10805908.html 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:12 "},"笔记/web前端面试-面试官系列/css/BFC.html":{"url":"笔记/web前端面试-面试官系列/css/BFC.html","title":"BFC","keywords":"","body":"面试官：谈谈你对BFC的理解？ 一、是什么 我们在页面布局的时候，经常出现以下情况： 这个元素高度怎么没了？ 这两栏布局怎么没法自适应？ 这两个元素的间距怎么有点奇怪的样子？ ...... 原因是元素之间相互的影响，导致了意料之外的情况，这里就涉及到BFC概念 BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则： 内部的盒子会在垂直方向上一个接一个的放置 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素 二、触发条件 触发BFC的条件包含不限于： 根元素，即HTML元素 浮动元素：float值为left、right overflow值不为 visible，为 auto、scroll、hidden display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed 三、应用场景 利用BFC的特性，我们将BFC应用在以下场景： 防止margin重叠（塌陷） p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } Haha Hehe 页面显示如下： 两个p元素之间的距离为100px，发生了margin重叠（塌陷），以最大的为准，如果第一个P的margin为80的话，两个P之间的距离还是100，以最大的为准。 前面讲到，同一个BFC的俩个相邻的盒子的margin会发生重叠 可以在p外面包裹一层容器，并触发这个容器生成一个BFC，那么两个p就不属于同一个BFC，则不会出现margin重叠 .wrap { overflow: hidden;// 新的BFC } p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } Haha Hehe 这时候，边距则不会重叠： 清除内部浮动 .par { border: 5px solid #fcc; width: 300px; } .child { border: 5px solid #f66; width:100px; height: 100px; float: left; } 页面显示如下： 而BFC在计算高度时，浮动元素也会参与，所以我们可以触发.par元素生活才能BFC，则内部浮动元素计算高度时候也会计算 .par { overflow: hidden; } 实现效果如下： 自适应多栏布局 这里举个两栏的布局 body { width: 300px; position: relative; } .aside { width: 100px; height: 150px; float: left; background: #f66; } .main { height: 200px; background: #fcc; } 效果图如下： 前面讲到，每个元素的左外边距与包含块的左边界相接触 因此，虽然.aslide为浮动元素，但是main的左边依然会与包含块的左边相接触 而BFC的区域不会与浮动盒子重叠 所以我们可以通过触发main生成BFC，以此适应两栏布局 .main { overflow: hidden; } 这时候，新的BFC不会与浮动的.aside元素重叠。因此会根据包含块的宽度，和.aside的宽度，自动变窄 效果如下： 小结 可以看到上面几个案例，都体现了BFC实际就是页面一个独立的容器，里面的子元素不影响外面的元素 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/animation.html":{"url":"笔记/web前端面试-面试官系列/css/animation.html","title":"Animation","keywords":"","body":"面试官：css3动画有哪些？ 一、是什么 CSS动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用CSS的动画的模块 即指元素从一种样式逐渐过渡为另一种样式的过程 常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合 css实现动画的方式，有如下几种： transition 实现渐变动画 transform 转变动画 animation 实现自定义动画 二、实现方式 transition 实现渐变动画 transition的属性如下： property:填写需要变化的css属性 duration:完成过渡效果需要的时间单位(s或者ms) timing-function:完成效果的速度曲线 delay: 动画效果的延迟触发时间 其中timing-function的值有如下： 值 描述 linear 匀速（等于 cubic-bezier(0,0,1,1)） ease 从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)） ease-in 慢慢变快（等于 cubic-bezier(0.42,0,1,1)） ease-out 慢慢变慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值 注意：并不是所有的属性都能使用过渡的，如display:nonedisplay:block 举个例子，实现鼠标移动上去发生变化动画效果 .base { width: 100px; height: 100px; display: inline-block; background-color: #0EA9FF; border-width: 5px; border-style: solid; border-color: #5daf34; transition-property: width, height, background-color, border-width; transition-duration: 2s; transition-timing-function: ease-in; transition-delay: 500ms; } /*简写*/ /*transition: all 2s ease-in 500ms;*/ .base:hover { width: 200px; height: 200px; background-color: #5daf34; border-width: 10px; border-color: #3a8ee6; } transform 转变动画 包含四个常用的功能： translate：位移 scale：缩放 rotate：旋转 skew：倾斜 一般配合transition过度使用 注意的是，transform不支持inline元素，使用前把它变成block 举个例子 .base { width: 100px; height: 100px; display: inline-block; background-color: #0EA9FF; border-width: 5px; border-style: solid; border-color: #5daf34; transition-property: width, height, background-color, border-width; transition-duration: 2s; transition-timing-function: ease-in; transition-delay: 500ms; } .base2 { transform: none; transition-property: transform; transition-delay: 5ms; } .base2:hover { transform: scale(0.8, 1.5) rotate(35deg) skew(5deg) translate(15px, 25px); } 可以看到盒子发生了旋转，倾斜，平移，放大 animation 实现自定义动画 animation是由 8 个属性的简写，分别如下： 属性 描述 属性值 animation-duration 指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0 animation-timing-function 指定动画计时函数，即动画的速度曲线，默认是 \"ease\" linear、ease、ease-in、ease-out、ease-in-out animation-delay 指定动画延迟时间，即动画何时开始，默认是 0 animation-iteration-count 指定动画播放的次数，默认是 1 animation-direction 指定动画播放的方向 默认是 normal normal、reverse、alternate、alternate-reverse animation-fill-mode 指定动画填充模式。默认是 none forwards、backwards、both animation-play-state 指定动画播放状态，正在运行或暂停。默认是 running running、pauser animation-name 指定 @keyframes 动画的名称 CSS 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来， 通过 @keyframes 来定义关键帧 因此，如果我们想要让元素旋转一圈，只需要定义开始和结束两帧即可： @keyframes rotate{ from{ transform: rotate(0deg); } to{ transform: rotate(360deg); } } from 表示最开始的那一帧，to 表示结束时的那一帧 也可以使用百分比刻画生命周期 @keyframes rotate{ 0%{ transform: rotate(0deg); } 50%{ transform: rotate(180deg); } 100%{ transform: rotate(360deg); } } 定义好了关键帧后，下来就可以直接用它了： animation: rotate 2s; 三、总结 属性 含义 transition（过度） 用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同 transform（变形） 用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表” translate（移动） 只是transform的一个属性值，即移动 animation（动画） 用于设置动画属性，他是一个简写的属性，包含6个属性 参考文献 https://segmentfault.com/a/1190000022540857 https://zh.m.wikipedia.org/wiki/CSS%E5%8A%A8%E7%94%BB https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/box.html":{"url":"笔记/web前端面试-面试官系列/css/box.html","title":"Box","keywords":"","body":"面试官：说说你对盒子模型的理解? 一、是什么 当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box） 一个盒子由四个部分组成：content、padding、border、margin content，即实际内容，显示文本和图像 boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成 padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响 margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域 上述是一个从二维的角度观察盒子，下面再看看看三维图： 下面来段代码： .box { width: 200px; height: 100px; padding: 20px; } 盒子模型 当我们在浏览器查看元素时，却发现元素的大小变成了240px 这是因为，在CSS中，盒子模型可以分成： W3C 标准盒子模型 IE 怪异盒子模型 默认情况下，盒子模型为W3C 标准盒子模型 二、标准盒子模型 标准盒子模型，是浏览器默认的盒子模型 下面看看标准盒子模型的模型图： 从上图可以看到： 盒子总宽度 = width + padding + border + margin; 盒子总高度 = height + padding + border + margin 也就是，width/height 只是内容高度，不包含 padding 和 border值 所以上面问题中，设置width为200px，但由于存在padding，但实际上盒子的宽度有240px 三、IE 怪异盒子模型 同样看看IE 怪异盒子模型的模型图： 从上图可以看到： 盒子总宽度 = width + margin; 盒子总高度 = height + margin; 也就是，width/height 包含了 padding和 border值 Box-sizing CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度 语法： box-sizing: content-box|border-box|inherit: content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致 border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致 inherit 指定 box-sizing 属性的值，应该从父元素继承 回到上面的例子里，设置盒子为 border-box 模型 .box { width: 200px; height: 100px; padding: 20px; box-sizing: border-box; } 盒子模型 这时候，就可以发现盒子的所占据的宽度为200px 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/center.html":{"url":"笔记/web前端面试-面试官系列/css/center.html","title":"Center","keywords":"","body":"面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ 一、背景 在开发中经常遇到这个问题，即让某个元素的内容在水平和垂直方向上都居中，内容不仅限于文字，可能是图片或其他元素 居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类： 居中元素（子元素）的宽高已知 居中元素宽高未知 二、实现方式 实现元素水平垂直居中的方式： 利用定位+margin:auto 利用定位+margin:负值 利用定位+transform table布局 flex布局 grid布局 利用定位+margin:auto 先上代码： .father{ width:500px; height:300px; border:1px solid #0a3b98; position: relative; } .son{ width:100px; height:40px; background: #f0a238; position: absolute; top:0; left:0; right:0; bottom:0; margin:auto; } 父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高 这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个margin：auto它就可以上下左右都居中了 利用定位+margin:负值 绝大多数情况下，设置父元素为相对定位， 子元素移动自身50%实现水平垂直居中 .father { position: relative; width: 200px; height: 200px; background: skyblue; } .son { position: absolute; top: 50%; left: 50%; margin-left:-50px; margin-top:-50px; width: 100px; height: 100px; background: red; } 整个实现思路如下图所示： 初始位置为方块1的位置 当设置left、top为50%的时候，内部子元素为方块2的位置 设置margin为负数时，使内部子元素到方块3的位置，即中间位置 这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作 但是该方案需要知道子元素自身的宽高，但是我们可以通过下面transform属性进行移动 利用定位+transform 实现代码如下： .father { position: relative; width: 200px; height: 200px; background: skyblue; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 100px; height: 100px; background: red; } translate(-50%, -50%)将会将元素位移自己宽度和高度的-50% 这种方法其实和最上面被否定掉的margin负值用法一样，可以说是margin负值的替代方案，并不需要知道自身元素的宽高 table布局 设置父元素为display:table-cell，子元素设置 display: inline-block。利用vertical和text-align可以让所有的行内块级元素水平垂直居中 .father { display: table-cell; width: 200px; height: 200px; background: skyblue; vertical-align: middle; text-align: center; } .son { display: inline-block; width: 100px; height: 100px; background: red; } flex弹性布局 还是看看实现的整体代码： .father { display: flex; justify-content: center; align-items: center; width: 200px; height: 200px; background: skyblue; } .son { width: 100px; height: 100px; background: red; } css3中了flex布局，可以非常简单实现垂直水平居中 这里可以简单看看flex布局的关键属性作用： display: flex时，表示该容器内部的元素将按照flex进行布局 align-items: center表示这些元素将相对于本容器水平居中 justify-content: center也是同样的道理垂直居中 grid网格布局 .father { display: grid; align-items:center; justify-content: center; width: 200px; height: 200px; background: skyblue; } .son { width: 10px; height: 10px; border: 1px solid red } 这里看到，gird网格布局和flex弹性布局都简单粗暴 小结 上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有： 利用定位+margin:auto 利用定位+transform 利用定位+margin:负值 flex布局 grid布局 三、总结 根据元素标签的性质，可以分为： 内联元素居中布局 块级元素居中布局 内联元素居中布局 水平居中 行内元素可设置：text-align: center flex布局设置父元素：display: flex; justify-content: center 垂直居中 单行文本父元素确认高度：height === line-height 多行文本父元素确认高度：disaply: table-cell; vertical-align: middle 块级元素居中布局 水平居中 定宽: margin: 0 auto 绝对定位+left:50%+margin:负自身一半 垂直居中 position: absolute设置left、top、margin-left、margin-top(定高) display: table-cell transform: translate(x, y) flex(不定高，不定宽) grid(不定高，不定宽)，兼容性相对比较差 参考文献 https://juejin.cn/post/6844903982960214029#heading-10 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/column_layout.html":{"url":"笔记/web前端面试-面试官系列/css/column_layout.html","title":"Column Layout","keywords":"","body":"面试官：如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？ 一、背景 在日常布局中，无论是两栏布局还是三栏布局，使用的频率都非常高 两栏布局 两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满， 比如 Ant Design 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器 这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器 这种布局适用于内容上具有明显主次关系的网页 三栏布局 三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之 大家最常见的就是github： 二、双栏布局 双栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 实现思路也非常的简单： 使用 float 左浮左边栏 右边模块使用 margin-left 撑出内容块做内容展示 为父级元素添加BFC，防止下方元素飞到上方内容 代码如下： .box{ overflow: hidden; 添加BFC } .left { float: left; width: 200px; background-color: gray; height: 400px; } .right { margin-left: 210px; background-color: lightgray; height: 200px; } 左边 右边 还有一种更为简单的使用则是采取：flex弹性布局 flex弹性布局 .box{ display: flex; } .left { width: 100px; } .right { flex: 1; } 左边 右边 flex可以说是最好的方案了，代码少，使用简单 注意的是，flex容器的一个默认属性值:align-items: stretch; 这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start 三、三栏布局 实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin 两边使用 float 和负 margin display: table 实现 flex实现 grid网格布局 两边使用 float，中间使用 margin 需要将中间的内容放在html结构最后，否则右侧会臣在中间内容的下方 实现代码如下： .wrap { background: #eee; overflow: hidden; padding: 20px; height: 200px; } .left { width: 200px; height: 200px; float: left; background: coral; } .right { width: 120px; height: 200px; float: right; background: lightblue; } .middle { margin-left: 220px; height: 200px; background: lightpink; margin-right: 140px; } 左侧 右侧 中间 原理如下： 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距 宽度小于左右部分宽度之和时，右侧部分会被挤下去 这种实现方式存在缺陷： 主体内容是最后加载的。 右边在主体内容之前，如果是响应式设计，不能简单的换行展示 两边使用 absolute，中间使用 margin 基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 .container { position: relative; } .left, .right, .main { height: 200px; line-height: 200px; text-align: center; } .left { position: absolute; top: 0; left: 0; width: 100px; background: green; } .right { position: absolute; top: 0; right: 0; width: 100px; background: green; } .main { margin: 0 110px; background: black; color: white; } 左边固定宽度 右边固定宽度 中间自适应 实现流程： 左右两边使用绝对定位，固定在两侧。 中间占满一行，但通过 margin和左右两边留出10px的间隔 两边使用 float 和负 margin .left, .right, .main { height: 200px; line-height: 200px; text-align: center; } .main-wrapper { float: left; width: 100%; } .main { margin: 0 110px; background: black; color: white; } .left, .right { float: left; width: 100px; margin-left: -100%; background: green; } .right { margin-left: -100px; /* 同自身宽度 */ } 中间自适应 左边固定宽度 右边固定宽度 实现过程： 中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示 左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧 右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧 缺点： 增加了 .main-wrapper 一层，结构变复杂 使用负 margin，调试也相对麻烦 使用 display: table 实现 标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果 .container { height: 200px; line-height: 200px; text-align: center; display: table; table-layout: fixed; width: 100%; } .left, .right, .main { display: table-cell; } .left, .right { width: 100px; background: green; } .main { background: black; color: white; width: 100%; } 左边固定宽度 中间自适应 右边固定宽度 实现原理： 层通过 display: table设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。 内层的左中右通过 display: table-cell设置为表格单元。 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度 使用flex实现 利用flex弹性布局，可以简单实现中间自适应 代码如下： .wrap { display: flex; justify-content: space-between; } .left, .right, .middle { height: 100px; } .left { width: 200px; background: coral; } .right { width: 120px; background: lightblue; } .middle { background: #555; width: 100%; margin: 0 20px; } 左侧 中间 右侧 实现过程： 仅需将容器设置为display:flex;， 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白 盒内元素的高度撑开容器的高度 优点： 结构简单直观 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间 grid网格布局 代码如下： .wrap { display: grid; width: 100%; grid-template-columns: 300px auto 300px; } .left, .right, .middle { height: 100px; } .left { background: coral; } .right { width: 300px; background: lightblue; } .middle { background: #555; } 左侧 中间 右侧 跟flex弹性布局一样的简单 参考文献 https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/ https://segmentfault.com/a/1190000008705541 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/css3_features.html":{"url":"笔记/web前端面试-面试官系列/css/css3_features.html","title":"Css3 Features","keywords":"","body":"面试官：CSS3新增了哪些新特性？ 一、是什么 css，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观 css3是css的最新标准，是向后兼容的，CSS1/2的特性在CSS3 里都是可以使用的 而CSS3 也增加了很多新特性，为开发带来了更佳的开发体验 二、选择器 css3中新增了一些选择器，主要为如下图所示： 三、新样式 边框 css3新增了三个边框属性，分别是： border-radius：创建圆角边框 box-shadow：为元素添加阴影 border-image：使用图片来绘制边框 box-shadow 设置元素阴影，设置属性如下： 水平阴影 垂直阴影 模糊距离(虚实) 阴影尺寸(影子大小) 阴影颜色 内/外阴影 其中水平阴影和垂直阴影是必须设置的 背景 新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break background-clip 用于确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从border开始显示 background-clip: padding-box; 背景从padding开始显示 background-clip: content-box; 背景显content区域开始显示 background-clip: no-clip; 默认属性，等同于border-box 通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围 background-origin 当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的 background-origin: border-box; 从border开始计算background-position background-origin: padding-box; 从padding开始计算background-position background-origin: content-box; 从content开始计算background-position 默认情况是padding-box，即以padding的左上角为原点 background-size background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break 元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景 文字 word-wrap 语法：word-wrap: normal|break-word normal：使用浏览器默认的换行 break-all：允许在单词内换行 text-overflow text-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择： clip：修剪文本 ellipsis：显示省略符号来代表被修剪的文本 text-shadow text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色 text-decoration CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度 颜色 css3新增了新的颜色表示方式rgba与hsla rgba分为两部分，rgb为颜色值，a为透明度 hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度 四、transition 过渡 transition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容： 过度效果 持续时间 语法如下： transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0) 上面为简写模式，也可以分开写各个属性 transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; 五、transform 转换 transform属性允许你旋转，缩放，倾斜或平移给定元素 transform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0) 使用方式： transform: translate(120px, 50%)：位移 transform: scale(2, 0.5)：缩放 transform: rotate(0.5turn)：旋转 transform: skew(30deg, 20deg)：倾斜 六、animation 动画 动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬 animation也有很多的属性 animation-name：动画名称 animation-duration：动画持续时间 animation-timing-function：动画时间函数 animation-delay：动画延迟时间 animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环 animation-direction：动画执行方向 animation-paly-state：动画播放状态 animation-fill-mode：动画填充模式 七、渐变 颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括 linear-gradient：线性渐变 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); radial-gradient：径向渐变 linear-gradient(0deg, red, green); 八、其他 关于css3其他的新特性还包括flex弹性布局、Grid栅格布局，这两个布局在以前就已经讲过，这里就不再展示 除此之外，还包括多列布局、媒体查询、混合模式等等...... 参考文献 https://juejin.cn/post/6844903518520901639#heading-1 https://www.w3school.com.cn/css/index.asp 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/css_performance.html":{"url":"笔记/web前端面试-面试官系列/css/css_performance.html","title":"Css Performance","keywords":"","body":"面试官：如果要做优化，CSS提高性能的方法有哪些？ 一、前言 每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的 作为页面渲染和内容展现的重要环节，css影响着用户对整个网站的第一体验 因此，在整个产品研发过程中，css性能优化同样需要贯穿全程 二、实现方式 实现方式有很多种，主要有如下： 内联首屏关键CSS 异步加载CSS 资源压缩 合理使用选择器 减少使用昂贵的属性 不要使用@import 内联首屏关键CSS 在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染 而如果外部引用css代码，在解析html结构过程中遇到外部css文件，才会开始下载css代码，再渲染 所以，CSS内联使用使渲染时间提前 注意：但是较大的css代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式 异步加载CSS 在CSS文件请求、下载、解析完成之前，CSS会阻塞渲染，浏览器将不会渲染任何已处理的内容 前面加载内联代码后，后面的外部引用css则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下： 使用javascript将link标签插到head标签最后 // 创建link标签 const myCSS = document.createElement( \"link\" ); myCSS.rel = \"stylesheet\"; myCSS.href = \"mystyles.css\"; // 插入到header的最后位置 document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling ); 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet 资源压缩 利用webpack、gulp/grunt、rollup等模块化工具，将css代码进行压缩，使文件变小，大大降低了浏览器的加载时间 合理使用选择器 css匹配的规则是从右往左开始匹配，例如#markdown .content h3匹配规则如下： 先找到h3标签元素 然后去除祖先不是.content的元素 最后去除祖先不是#markdown的元素 如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高 所以我们在编写选择器的时候，可以遵循以下规则： 不要嵌套使用过多复杂选择器，最好不要三层以上 使用id选择器就没必要再进行嵌套 通配符和属性选择器效率最低，避免使用 减少使用昂贵的属性 在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能 不要使用@import css样式文件有两种引入方式，一种是link元素，另一种是@import @import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时 而且多个@import可能会导致下载顺序紊乱 比如一个css文件index.css包含了以下内容：@import url(\"reset.css\") 那么浏览器就必须先把index.css下载、解析和执行后，才下载、解析和执行第二个文件reset.css 其他 减少重排操作，以及减少不必要的重绘 了解哪些属性可以继承而来，避免对这些属性重复编写 cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，减少了http请求 把小的icon图片转成base64编码 CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性 三、总结 css实现性能的方式可以从选择器嵌套、属性特性、减少http这三面考虑，同时还要注意css代码的加载顺序 参考文献 https://www.zhihu.com/question/19886806 https://juejin.cn/post/6844903649605320711#heading-1 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/dp_px_dpr_ppi.html":{"url":"笔记/web前端面试-面试官系列/css/dp_px_dpr_ppi.html","title":"Dp Px Dpr Ppi","keywords":"","body":"面试官：说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？ 一、背景 在css中我们通常使用px作为单位，在PC浏览器中css的1个像素都是对应着电脑屏幕的1个物理像素 这会造成一种错觉，我们会认为css中的像素就是设备的物理像素 但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的 当我们做移动端开发时，同为1px的设置，在不同分辨率的移动设备上显示效果却有很大差异 这背后就涉及了css像素、设备像素、设备独立像素、dpr、ppi的概念 二、介绍 CSS像素 CSS像素（css pixel, px）: 适用于web编程，在 CSS 中以 px 为后缀，是一个长度单位 在 CSS 规范中，长度单位可以分为两类，绝对单位以及相对单位 px是一个相对单位，相对的是设备像素（device pixel） 一般情况，页面缩放比为1，1个CSS像素等于1个设备独立像素 CSS像素又具有两个方面的相对性： 在同一个设备上，每1个 CSS 像素所代表的设备像素是可以变化的（比如调整屏幕的分辨率） 在不同的设备之间，每1个 CSS 像素所代表的设备像素是可以变化的（比如两个不同型号的手机） 在页面进行缩放操作也会 引起css中px的变化，假设页面放大一倍，原来的 1px 的东西变成 2px，在实际宽度不变的情况下1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素） 假设原来需要 320px 才能填满的宽度现在只需要 160px px会受到下面的因素的影响而变化： 每英寸像素（PPI） 设备像素比（DPR） 设备像素 设备像素（device pixels），又称为物理像素 指设备能控制显示的最小物理单位，不一定是一个小正方形区块，也没有标准的宽高，只是用于显示丰富色彩的一个“点”而已 可以参考公园里的景观变色彩灯，一个彩灯(物理像素)由红、蓝、绿小灯组成，三盏小灯不同的亮度混合出各种色彩 从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为pt 设备独立像素 设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素 在javaScript中可以通过window.screen.width/ window.screen.height 查看 比如我们会说“电脑屏幕在 2560x1600分辨率下不适合玩游戏，我们把它调为 1440x900”，这里的“分辨率”（非严谨说法）指的就是设备独立像素 一个设备独立像素里可能包含1个或者多个物理像素点，包含的越多则屏幕看起来越清晰 至于为什么出现设备独立像素这种虚拟像素单位概念，下面举个例子： iPhone 3GS 和 iPhone 4/4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4/4s 的分辨率是 640x960 这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4/4s 有 640 个物理像素 如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640 物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位 我们统一 iPhone 3GS 和 iPhone 4/4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素 至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比，也就是下面介绍的dpr dpr dpr（device pixel ratio），设备像素比，代表设备独立像素到设备像素的转换关系，在JavaScript中可以通过 window.devicePixelRatio 获取 计算公式如下： 当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素 如下图所示： 当dpr为3，那么1px的CSS像素宽度对应3px的物理像素的宽度，1px的CSS像素高度对应3px的物理像素高度 ppi ppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像 计算公式如下： 三、总结 无缩放情况下，1个CSS像素等于1个设备独立像素 设备像素由屏幕生产之后就不发生改变，而设备独立像素是一个虚拟单位会发生改变 PC端中，1个设备独立像素 = 1个设备像素 （在100%，未缩放的情况下） 在移动端中，标准屏幕（160ppi）下 1个设备独立像素 = 1个设备像素 设备像素比（dpr） = 设备像素 / 设备独立像素 每英寸像素（ppi），值越大，图像越清晰 参考文献 https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introduction/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/em_px_rem_vh_vw.html":{"url":"笔记/web前端面试-面试官系列/css/em_px_rem_vh_vw.html","title":"Em Px Rem Vh Vw","keywords":"","body":"面试官：说说em/px/rem/vh/vw区别? 一、介绍 传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性 从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了rem、vh、vw、vm等一些新的计量单位 利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等 二、单位 在css单位中，可以分为长度单位、绝对单位，如下表所指示 CSS单位 相对长度单位 em、ex、ch、rem、vw、vh、vmin、vmax、% 绝对长度单位 cm、mm、in、px、pt、pc 这里我们主要讲述px、em、rem、vh、vw px px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中 有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的 这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关 em em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px） 为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5% = 10px 这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的px 数值除以 10，然后换上 em作为单位就行了 特点： em 的值并不是固定的 em 会继承父级元素的字体大小 em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸 任意浏览器的默认字体高都是 16px 举个例子 我是14px=1.4rem我是12px=1.2rem 样式为 html {font-size: 10px; } /* 公式16px*62.5%=10px */ .big{font-size: 1.4rem} .small{font-size: 1.2rem} 这时候.big元素的font-size为14px，而.small元素的font-size为12px rem rem，相对单位，相对的只是HTML根元素font-size的值 同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5% html {font-size: 62.5%; } /* 公式16px*62.5%=10px */ 这样页面中1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助 特点： rem单位可谓集相对大小和绝对大小的优点于一身 和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸 vh、vw vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度 这里的窗口分成几种情况： 在桌面端，指的是浏览器的可视区域 移动端指的就是布局视口 像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素： 对于普通定位元素就是我们理解的父元素 对于position: absolute;的元素是相对于已定位的父元素 对于position: fixed;的元素是相对于 ViewPort（可视窗口） 三、总结 px：绝对单位，页面按精确像素展示 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值 rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算 vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/flexbox.html":{"url":"笔记/web前端面试-面试官系列/css/flexbox.html","title":"Flexbox","keywords":"","body":"面试官：说说flexbox（弹性盒布局模型）,以及适用场景？ 一、是什么 Flexible Box 简称 flex，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局 采用Flex布局的元素，称为flex容器container 它的所有子元素自动成为容器成员，称为flex项目item 容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过flex-direction来决定主轴的方向 每根轴都有起点和终点，这对于元素的对齐非常重要 二、属性 关于flex常用的属性，我们可以划分为容器属性和容器成员属性 容器属性有： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction 决定主轴的方向(即项目的排列方向) .container { flex-direction: row | row-reverse | column | column-reverse; } 属性对应如下： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 如下图所示： flex-wrap 弹性元素永远沿主轴排列，那么如果主轴排不下，通过flex-wrap决定容器内项目是否可换行 .container { flex-wrap: nowrap | wrap | wrap-reverse; } 属性对应如下： nowrap（默认值）：不换行 wrap：换行，第一行在下方 wrap-reverse：换行，第一行在上方 默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩 flex-flow 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap .box { flex-flow: || ; } justify-content 定义了项目在主轴上的对齐方式 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 属性对应如下： flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：两个项目两侧间隔相等 效果图如下： align-items 定义项目在交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 属性对应如下： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 属性对应如吓： flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值）：轴线占满整个交叉轴 效果图如下： 容器成员属性如下： order flex-grow flex-shrink flex-basis flex align-self order 定义项目的排列顺序。数值越小，排列越靠前，默认为0 .item { order: ; } flex-grow 上面讲到当容器设为flex-wrap: nowrap;不换行的时候，容器宽度有不够分的情况，弹性元素会根据flex-grow来决定 定义项目的放大比例（容器宽度>元素总宽度时如何伸展） 默认为0，即如果存在剩余空间，也不放大 .item { flex-grow: ; } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话） 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 flex-shrink 定义了项目的缩小比例（容器宽度 .item { flex-shrink: ; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 在容器宽度有剩余时，flex-shrink也是不会生效的 flex-basis 设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸 浏览器根据这个属性，计算主轴是否有多余空间，默认值为auto，即项目的本来大小，如设置了width则元素尺寸由width/height决定（主轴方向），没有设置则由内容决定 .item { flex-basis: | auto; /* default auto */ } 当设置为0的是，会根据内容撑开 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，也是比较难懂的一个复合属性 .item { flex: none | [ ? || ] } 一些属性有： flex: 1 = flex: 1 1 0% flex: 2 = flex: 2 1 0% flex: auto = flex: 1 1 auto flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩 flex:1 和 flex:auto 的区别，可以归结于flex-basis:0和flex-basis:auto的区别 当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸 当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑 注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 效果图如下： 三、应用场景 在以前的文章中，我们能够通过flex简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过flex完成，这里就不再展开代码的演示 包括现在在移动端、小程序这边的开发，都建议使用flex进行布局 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/grid.html":{"url":"笔记/web前端面试-面试官系列/css/grid.html","title":"Grid","keywords":"","body":"面试官：介绍一下grid网格布局 一、是什么 Grid 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列 擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系 这与之前讲到的flex一维布局不相同 设置display:grid/inline-grid的元素就是网格布局容器，这样就能出发浏览器渲染引擎的网格布局算法 上述代码实例中，.container元素就是网格布局容器，.item元素就是网格的项目，由于网格元素只能是容器的顶层子元素，所以p元素并不是网格元素 这里提一下，网格线概念，有助于下面对grid-column系列属性的理解 网格线，即划分网格的线，如下图所示： 上图是一个 2 x 3 的网格，共有3根水平网格线和4根垂直网格线 二、属性 同样，Grid 布局属性可以分为两大类： 容器属性， 项目属性 关于容器属性有如下： display 属性 文章开头讲到，在元素上设置display：grid 或 display：inline-grid 来创建一个网格容器 display：grid 则该容器是一个块级元素 display: inline-grid 则容器元素为行内元素 grid-template-columns 属性，grid-template-rows 属性 grid-template-columns 属性设置列宽，grid-template-rows 属性设置行高 .wrapper { display: grid; /* 声明了三列，宽度分别为 200px 200px 200px */ grid-template-columns: 200px 200px 200px; grid-gap: 5px; /* 声明了两行，行高分别为 50px 50px */ grid-template-rows: 50px 50px; } 以上表示固定列宽为 200px 200px 200px，行高为 50px 50px 上述代码可以看到重复写单元格宽高，通过使用repeat()函数，可以简写重复的值 第一个参数是重复的次数 第二个参数是重复的值 所以上述代码可以简写成 .wrapper { display: grid; grid-template-columns: repeat(3,200px); grid-gap: 5px; grid-template-rows:repeat(2,50px); } 除了上述的repeact关键字，还有： auto-fill：示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格 grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素 fr：片段，为了方便表示比例关系 grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3 minmax：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值 minmax(100px, 1fr)表示列宽不小于100px，不大于1fr auto：由浏览器自己决定长度 grid-template-columns: 100px auto 100px 表示第一第三列为 100px，中间由浏览器决定长度 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 grid-row-gap 属性、grid-column-gap 属性分别设置行间距和列间距。grid-gap 属性是两者的简写形式 grid-row-gap: 10px 表示行间距是 10px grid-column-gap: 20px 表示列间距是 20px grid-gap: 10px 20px 等同上述两个属性 grid-template-areas 属性 用于定义区域，一个区域由一个或者多个单元格组成 .container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i'; } 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下 grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成a、b、c三个区域 如果某些区域不需要利用，则使用\"点\"（.）表示 grid-auto-flow 属性 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。 顺序就是由grid-auto-flow决定，默认为行，代表\"先行后列\"，即先填满第一行，再开始放入第二行 当修改成column后，放置变为如下： justify-items 属性， align-items 属性， place-items 属性 justify-items 属性设置单元格内容的水平位置（左中右），align-items 属性设置单元格的垂直位置（上中下） 两者属性的值完成相同 .container { justify-items: start | end | center | stretch; align-items: start | end | center | stretch; } 属性对应如下： start：对齐单元格的起始边缘 end：对齐单元格的结束边缘 center：单元格内部居中 stretch：拉伸，占满单元格的整个宽度（默认值） place-items属性是align-items属性和justify-items属性的合并简写形式 justify-content 属性， align-content 属性， place-content 属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下） .container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 两个属性的写法完全相同，都可以取下面这些值： start - 对齐容器的起始边框 end - 对齐容器的结束边框 center - 容器内部居中 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 stretch - 项目大小没有指定时，拉伸占据整个网格容器 grid-auto-columns 属性和 grid-auto-rows 属性 有时候，一些项目的指定位置，在现有网格的外部，就会产生显示网格和隐式网格 比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。超出的部分就是隐式网格 而grid-auto-rows与grid-auto-columns就是专门用于指定隐式网格的宽高 关于项目属性，有如下： grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性 指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置 grid-column-start 属性：左边框所在的垂直网格线 grid-column-end 属性：右边框所在的垂直网格线 grid-row-start 属性：上边框所在的水平网格线 grid-row-end 属性：下边框所在的水平网格线 举个例子： #container{ display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; } .item-1 { grid-column-start: 2; grid-column-end: 4; } 1 2 3 通过设置grid-column属性，指定1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线 grid-area 属性 grid-area 属性指定项目放在哪一个区域 .item-1 { grid-area: e; } 意思为将1号项目位于e区域 与上述讲到的grid-template-areas搭配使用 justify-self 属性、align-self 属性以及 place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目 .item { justify-self: start | end | center | stretch; align-self: start | end | center | stretch; } 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值） 三、应用场景 文章开头就讲到，Grid是一个强大的布局，如一些常见的 CSS 布局，如居中，两列布局，三列布局等等是很容易实现的，在以前的文章中，也有使用Grid布局完成对应的功能 关于兼容性问题，结果如下： 总体兼容性还不错，但在 IE 10 以下不支持 目前，Grid布局在手机端支持还不算太友好 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html https://juejin.cn/post/6854573220306255880#heading-2 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/hide_attributes.html":{"url":"笔记/web前端面试-面试官系列/css/hide_attributes.html","title":"Hide Attributes","keywords":"","body":"面试官：css中，有哪些方式可以隐藏页面元素？区别? 一、前言 在平常的样式排版中，我们经常遇到将某个模块隐藏的场景 通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的 但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法 二、实现方式 通过css实现隐藏元素方法有如下： display:none visibility:hidden opacity:0 设置height、width模型属性为0 position:absolute clip-path display:none 设置元素的display为none是最常用的隐藏元素的方法 .hide { display:none; } 将元素设置为display:none后，元素在页面上将彻底消失 元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘 消失后，自身绑定的事件不会触发，也不会有过渡效果 特点：元素不可见，不占据空间，无法响应点击事件 visibility:hidden 设置元素的visibility为hidden也是一种常用的隐藏元素的方法 从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘 .hidden{ visibility:hidden } 给人的效果是隐藏了，所以他自身的事件不会触发 特点：元素不可见，占据页面空间，无法响应点击事件 opacity:0 opacity属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的 不会引发重排，一般情况下也会引发重绘 如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘 .transparent { opacity:0; } 由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的 需要注意的是：其子元素不能设置opacity来达到显示的效果 特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件 设置height、width属性为0 将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素 .hiddenBox { margin:0; border:0; padding:0; height:0; width:0; overflow:hidden; } 特点：元素不可见，不占据页面空间，无法响应点击事件 position:absolute 将元素移出可视区域 .hide { position: absolute; top: -9999px; left: -9999px; } 特点：元素不可见，不影响页面布局 clip-path 通过裁剪的形式 .hide { clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px); } 特点：元素不可见，占据页面空间，无法响应点击事件 小结 最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们 三、区别 关于display: none、visibility: hidden、opacity: 0的区别，如下表所示： display: none visibility: hidden opacity: 0 页面中 不存在 存在 存在 重排 会 不会 不会 重绘 会 会 不一定 自身绑定事件 不触发 不触发 可触发 transition 不支持 支持 支持 子元素可复原 不能 能 不能 被遮挡的元素可触发事件 能 能 不能 参考文献 https://www.cnblogs.com/a-cat/p/9039962.html 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/layout_painting.html":{"url":"笔记/web前端面试-面试官系列/css/layout_painting.html","title":"Layout Painting","keywords":"","body":"面试官：怎么理解回流跟重绘？什么场景下会触发？ 一、是什么 在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘： 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制 具体的浏览器解析渲染机制如下所示： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上 在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变 当我们对 DOM 的修改引发了 DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来 当我们对 DOM的修改导致了样式的变化（color或background-color），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了回流 二、如何触发 要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的 回流触发时机 回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代 页面一开始渲染的时候（这避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 还有一些容易被忽略的操作：获取一些特定属性的值 offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流 除此还包括getComputedStyle方法，原理是一样的 重绘触发时机 触发回流一定会触发重绘 可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘） 除此之外还有一些其他引起重绘行为： 颜色的修改 文本方向的修改 阴影的修改 浏览器优化机制 由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列 当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据 因此浏览器不得不清空队列，触发回流重绘来返回正确的值 三、如何减少 我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验： 如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层) 避免设置多项内联样式 应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提) 避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算 对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 避免使用 CSS 的 JavaScript 表达式 在使用 JavaScript 动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能 但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们 例如，多次修改一个把元素布局的时候，我们很可能会如下操作 const el = document.getElementById('el') for(let i=0;i 每次循环都需要获取多次offset属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求 // 缓存offsetLeft与offsetTop的值 const el = document.getElementById('el') let offLeft = el.offsetLeft, offTop = el.offsetTop // 在JS层面进行计算 for(let i=0;i 我们还可避免改变样式，使用类名去合并样式 const container = document.getElementById('container') container.style.width = '100px' container.style.height = '200px' container.style.border = '10px solid red' container.style.color = 'red' 使用类名去合并样式 .basic_style { width: 100px; height: 200px; border: 10px solid red; color: red; } const container = document.getElementById('container') container.classList.add('basic_style') 前者每次单独操作，都去触发一次渲染树更改（新浏览器不会）， 都去触发一次渲染树更改，从而导致相应的回流与重绘过程 合并之后，等于我们将所有的更改一次性发出 我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作 const container = document.getElementById('container') container.style.width = '100px' container.style.height = '200px' container.style.border = '10px solid red' container.style.color = 'red' 离线操作后 let container = document.getElementById('container') container.style.display = 'none' container.style.width = '100px' container.style.height = '200px' container.style.border = '10px solid red' container.style.color = 'red' ...（省略了许多类似的后续操作） container.style.display = 'block' 参考文献 https://juejin.cn/post/6844903942137053192 https://segmentfault.com/a/1190000017329980 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/less_12px.html":{"url":"笔记/web前端面试-面试官系列/css/less_12px.html","title":"Less 12px","keywords":"","body":"面试官：让Chrome支持小于12px 的文字方式有哪些？区别？ 一、背景 Chrome 中文版浏览器会默认设定页面的最小字号是12px，英文版没有限制 原由 Chrome 团队认为汉字小于12px就会增加识别难度 中文版浏览器 与网页语言无关，取决于用户在Chrome的设置里（chrome://settings/languages）把哪种语言设置为默认显示语言 系统级最小字号 浏览器默认设定页面的最小字号，用户可以前往 chrome://settings/fonts 根据需求更改 而我们在实际项目中，不能奢求用户更改浏览器设置 对于文本需要以更小的字号来显示，就需要用到一些小技巧 二、解决方案 常见的解决方案有： zoom -webkit-transform:scale() -webkit-text-size-adjust:none Zoom zoom 的字面意思是“变焦”，可以改变页面上元素的尺寸，属于真实尺寸 其支持的值类型有： zoom:50%，表示缩小到原来的一半 zoom:0.5，表示缩小到原来的一半 使用 zoom 来”支持“ 12px 以下的字体 代码如下： .span1{ font-size: 12px; display: inline-block; zoom: 0.8; } .span2{ display: inline-block; font-size: 12px; } 测试10px 测试12px 效果如下： 需要注意的是，Zoom 并不是标准属性，需要考虑其兼容性 -webkit-transform:scale() 针对chrome浏览器,加webkit前缀，用transform:scale()这个属性进行放缩 注意的是，使用scale属性只对可以定义宽高的元素生效，所以，下面代码中将span元素转为行内块元素 实现代码如下： .span1{ font-size: 12px; display: inline-block; -webkit-transform:scale(0.8); } .span2{ display: inline-block; font-size: 12px; } 测试10px 测试12px 效果如下： -webkit-text-size-adjust:none 该属性用来设定文字大小是否根据设备(浏览器)来自动调整显示大小 属性值： percentage：字体显示的大小； auto：默认，字体大小会根据设备/浏览器来自动调整； none:字体大小不会自动调整 html { -webkit-text-size-adjust: none; } 这样设置之后会有一个问题，就是当你放大网页时，一般情况下字体也会随着变大，而设置了以上代码后，字体只会显示你当前设置的字体大小，不会随着网页放大而变大了 所以，我们不建议全局应用该属性，而是单独对某一属性使用 需要注意的是，自从chrome 27之后，就取消了对这个属性的支持。同时，该属性只对英文、数字生效，对中文不生效 三、总结 Zoom 非标属性，有兼容问题，缩放会改变了元素占据的空间大小，触发重排 -webkit-transform:scale() 大部分现代浏览器支持，并且对英文、数字、中文也能够生效，缩放不会改变了元素占据的空间大小，页面布局不会发生变化 -webkit-text-size-adjust对谷歌浏览器有版本要求，在27之后，就取消了该属性的支持，并且只对英文、数字生效 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-size-adjust https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/responsive_layout.html":{"url":"笔记/web前端面试-面试官系列/css/responsive_layout.html","title":"Responsive Layout","keywords":"","body":"面试官：什么是响应式设计？响应式设计的基本原理是什么？如何做？ 一、是什么 响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整 描述响应式界面最著名的一句话就是“Content is like water” 大白话便是“如果将屏幕看作容器，那么内容就像水一样” 响应式网站常见特点： 同时适配PC + 平板 + 手机等 标签导航在接近手持终端设备时改变为经典的抽屉式导航 网站的布局会根据视口来调整模块的大小和位置 二、实现方式 响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport 属性对应如下： width=device-width: 是自适应手机屏幕的尺寸宽度 maximum-scale:是缩放比例的最大值 inital-scale:是缩放的初始化 user-scalable:是用户的可以缩放的操作 实现响应式布局的方式有如下： 媒体查询 百分比 vw/vh rem 媒体查询 CSS3中的增加了更多的媒体查询，就像if条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表 使用@Media查询，可以针对不同的媒体类型定义不同的样式，如： @media screen and (max-width: 1920px) { ... } 当视口在375px - 600px之间，设置特定字体大小18px @media screen (min-width: 375px) and (max-width: 600px) { body { font-size: 18px; } } 通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片 比如给小屏幕手机设置@2x图，为大屏幕手机设置@3x图，通过媒体查询就能很方便的实现 百分比 通过百分比单位 \" % \" 来实现响应式的效果 比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果 height、width属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素： 子元素的top/left和bottom/right如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度/宽度 子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。 子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度 可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式 vw/vh vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一 与百分比布局很相似，在以前文章提过与%的区别，这里就不再展开述说 rem 在以前也讲到，rem是相对于根元素html的font-size属性，默认情况下浏览器字体大小为16px，此时1rem = 16px 可以利用前面提到的媒体查询，针对不同设备分辨率改变font-size的值，如下： @media screen and (max-width: 414px) { html { font-size: 18px } } @media screen and (max-width: 375px) { html { font-size: 16px } } @media screen and (max-width: 320px) { html { font-size: 12px } } 为了更准确监听设备可视窗口变化，我们可以在css之前插入script标签，内容如下： //动态为根元素设置字体大小 function init () { // 获取屏幕宽度 var width = document.documentElement.clientWidth // 设置根元素字体大小。此时为宽的10等分 document.documentElement.style.fontSize = width / 10 + 'px' } //首次加载应用，设置一次 init() // 监听手机旋转的事件的时机，重新设置 window.addEventListener('orientationchange', init) // 监听手机窗口变化，重新设置 window.addEventListener('resize', init) 无论设备可视窗口如何变化，始终设置rem为width的1/10，实现了百分比布局 除此之外，我们还可以利用主流UI框架，如：element ui、antd提供的栅格布局实现响应式 小结 响应式设计实现通常会从以下几方面思考： 弹性盒子（包括图片、表格、视频）和媒体查询等技术 使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围 使用相对单位使得内容自适应调节 选择断点，针对不同断点实现不同布局和内容展示 三、总结 响应式布局优点可以看到： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 缺点： 仅适用布局、信息、框架并不复杂的部门类型网站 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 参考文献 https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1 https://juejin.cn/post/6844904082751111176 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/sass_less_stylus.html":{"url":"笔记/web前端面试-面试官系列/css/sass_less_stylus.html","title":"Sass Less Stylus","keywords":"","body":"面试官：说说对Css预编语言的理解？有哪些区别? 一、是什么 Css 作为一门标记性语言，语法相对简单，对使用者的要求较低，但同时也带来一些问题 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 Css 编写经验而很难写出组织良好且易于维护的 Css 代码 Css预处理器便是针对上述问题的解决方案 预处理语言 扩充了 Css 语言，增加了诸如变量、混合（mixin）、函数等功能，让 Css 更易维护、方便 本质上，预处理是Css的超集 包含一套自定义的语法及一个解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 Css 文件 二、有哪些 Css预编译语言在前端里面有三大优秀的预编处理器，分别是： sass less stylus sass 2007 年诞生，最早也是最成熟的 Css预处理器，拥有 Ruby 社区的支持和 Compass 这一最强大的 Css框架，目前受 LESS 影响，已经进化到了全面兼容 Css 的 Scss 文件后缀名为.sass与scss，可以严格按照 sass 的缩进方式省去大括号和分号 less 2009年出现，受SASS的影响较大，但又使用 Css 的语法，让大部分开发者和设计师更容易上手，在 Ruby社区之外支持者远超过 SASS 其缺点是比起 SASS来，可编程功能不够，不过优点是简单和兼容 Css，反过来也影响了 SASS演变到了Scss 的时代 stylus Stylus是一个Css的预处理框架，2010 年产生，来自 Node.js社区，主要用来给 Node 项目进行 Css 预处理支持 所以Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的Css。比较年轻，其本质上做的事情与SASS/LESS等类似 三、区别 虽然各种预处理器功能强大，但使用最多的，还是以下特性： 变量（variables） 作用域（scope） 代码混合（ mixins） 嵌套（nested rules） 代码模块化（Modules） 因此，下面就展开这些方面的区别 基本使用 less和scss .box { display: block; } sass .box display: block stylus .box display: block 嵌套 三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 & 也相同 区别只是 Sass 和 Stylus 可以用没有大括号的方式书写 less .a { &.b { color: red; } } 变量 变量无疑为 Css 增加了一种有效的复用方式，减少了原来在 Css 中无法避免的重复「硬编码」 less声明的变量必须以@开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号:分隔开 @red: #c00; strong { color: @red; } sass声明的变量跟less十分的相似，只是变量名前面使用@开头 $red: #c00; strong { color: $red; } stylus声明的变量没有任何的限定，可以使用$开头，结尾的分号;可有可无，但变量与变量值之间需要使用= 在stylus中我们不建议使用@符号开头声明变量 red = #c00 strong color: red 作用域 Css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js一样，它会先从局部作用域查找变量，依次向上级作用域查找 sass中不存在全局变量 $color: black; .scoped { $bg: blue; $color: white; color: $color; background-color:$bg; } .unscoped { color:$color; } 编译后 .scoped { color:white;/*是白色*/ background-color:blue; } .unscoped { color:white;/*白色（无全局变量概念）*/ } 所以，在sass中最好不要定义相同的变量名 less与stylus的作用域跟javascript十分的相似，首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止 @color: black; .scoped { @bg: blue; @color: white; color: @color; background-color:@bg; } .unscoped { color:@color; } 编译后： .scoped { color:white;/*白色（调用了局部变量）*/ background-color:blue; } .unscoped { color:black;/*黑色（调用了全局变量）*/ } 混入 混入（mixin）应该说是预处理器最精髓的功能之一了，简单点来说，Mixins可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用 可以在Mixins中定义变量或者默认参数 在less中，混合的用法是指将定义好的ClassA中引入另一个已经定义的Class，也能使用够传递参数，参数变量为@声明 .alert { font-weight: 700; } .highlight(@color: red) { font-size: 1.2em; color: @color; } .heads-up { .alert; .highlight(red); } 编译后 .alert { font-weight: 700; } .heads-up { font-weight: 700; font-size: 1.2em; color: red; } Sass声明mixins时需要使用@mixinn，后面紧跟mixin的名，也可以设置参数，参数名为变量$声明的形式 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } .page-title { @include large-text; padding: 4px; margin-top: 10px; } stylus中的混合和前两款Css预处理器语言的混合略有不同，他可以不使用任何符号，就是直接声明Mixins名，然后在定义参数和默认值之间用等号（=）来连接 error(borderWidth= 2px) { border: borderWidth solid #F00; color: #F00; } .generic-error { padding: 20px; margin: 4px; error(); /* 调用error mixins */ } .login-error { left: 12px; position: absolute; top: 20px; error(5px); /* 调用error mixins，并将参数$borderWidth的值指定为5px */ } 代码模块化 模块化就是将Css代码分成一个个模块 scss、less、stylus三者的使用方法都如下所示 @import './common'; @import './github-markdown'; @import './mixin'; @import './variables'; 参考文献 https://jelly.jd.com/article/5dcb9c73641a030153732a89 https://zhuanlan.zhihu.com/p/23382462 https://baike.baidu.com/item/Less/17570158 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/selector.html":{"url":"笔记/web前端面试-面试官系列/css/selector.html","title":"Selector","keywords":"","body":"面试官：css选择器有哪些？优先级？哪些属性可以继承？ 一、选择器 CSS选择器是CSS规则的第一部分 它是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式 选择器所选择的元素，叫做“选择器的对象” 我们从一个Html结构开始 关于css属性选择器常用的有： id选择器（#box），选择id为box的元素 类选择器（.one），选择类名为one的所有元素 标签选择器（div），选择标签为div的所有元素 后代选择器（#box div），选择id为box元素内部所有的div元素 子选择器（.one>one_1），选择父元素为.one的所有.one_1的元素 相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素 群组选择器（div,p），选择div、p的所有元素 还有一些使用频率相对没那么多的选择器： 伪类选择器 :link ：选择未被访问的链接 :visited：选取已被访问的链接 :active：选择活动链接 :hover ：鼠标指针浮动在上面的元素 :focus ：选择具有焦点的 :first-child：父元素的首个子元素 伪元素选择器 :first-letter ：用于选取指定选择器的首字母 :first-line ：选取指定选择器的首行 :before : 选择器在被选元素的内容前面插入内容 :after : 选择器在被选元素的内容后面插入内容 属性选择器 [attribute] 选择带有attribute属性的元素 [attribute=value] 选择所有使用attribute=value的元素 [attribute~=value] 选择attribute属性包含value的元素 [attribute|=value]：选择attribute属性以value开头的元素 在CSS3中新增的选择器有如下： 层次选择器（p~ul），选择前面有p元素的每个ul元素 伪类选择器 :first-of-type 表示一组同级元素中其类型的第一个元素 :last-of-type 表示一组同级元素中其类型的最后一个元素 :only-of-type 表示没有同类型兄弟元素的元素 :only-child 表示没有任何兄弟的元素 :nth-child(n) 根据元素在一组同级中的位置匹配元素 :nth-last-of-type(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数 :last-child 表示一组兄弟元素中的最后一个元素 :root 设置HTML文档 :empty 指定空的元素 :enabled 选择可用元素 :disabled 选择被禁用元素 :checked 选择选中的元素 :not(selector) 选择与 不匹配的所有元素 属性选择器 [attribute*=value]：选择attribute属性值包含value的所有元素 [attribute^=value]：选择attribute属性开头为value的所有元素 [attribute$=value]：选择attribute属性结尾为value的所有元素 二、优先级 相信大家对CSS选择器的优先级都不陌生： 内联 > ID选择器 > 类选择器 > 标签选择器 到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： 如果存在内联样式，那么 A = 1, 否则 A = 0 B的值等于 ID选择器出现的次数 C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数 D 的值等于 标签选择器 和 伪元素 出现的总次数 这里举个例子： #nav-global > ul > li > a.nav-link 套用上面的算法，依次求出 A B C D 的值： 因为没有内联样式 ，所以 A = 0 ID选择器总共出现了1次， B = 1 类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1 标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3 上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3) 知道了优先级是如何计算之后，就来看看比较规则： 从左往右依次进行比较 ，较大者优先级更高 如果相等，则继续往右移动一位进行比较 如果4位全部相等，则后面的会覆盖前面的 经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用!important 三、继承属性 在css中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性 关于继承属性，可以分成： 字体系列属性 font:组合字体 font-family:规定元素的字体系列 font-weight:设置字体的粗细 font-size:设置字体的尺寸 font-style:定义字体的风格 font-variant:偏大或偏小的字体 文本系列属性 text-indent：文本缩进 text-align：文本水平对刘 line-height：行高 word-spacing：增加或减少单词间的空白 letter-spacing：增加或减少字符间的空白 text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 元素可见性 visibility 表格布局属性 caption-side：定位表格标题位置 border-collapse：合并表格边框 border-spacing：设置相邻单元格的边框间的距离 empty-cells：单元格的边框的出现与消失 table-layout：表格的宽度由什么决定 列表属性 list-style-type：文字前面的小点点样式 list-style-position：小点点位置 list-style：以上的属性可通过这属性集合 引用 quotes：设置嵌套引用的引号类型 光标属性 cursor：箭头可以变成需要的形状 继承中比较特殊的几点： a 标签的字体颜色不能被继承 h1-h6标签字体的大下也是不能被继承的 无继承的属性 display 文本属性：vertical-align、text-decoration 盒子模型的属性：宽度、高度、内外边距、边框等 背景属性：背景图片、颜色、位置等 定位属性：浮动、清除浮动、定位position等 生成内容属性：content、counter-reset、counter-increment 轮廓样式属性：outline-style、outline-width、outline-color、outline 页面样式属性：size、page-break-before、page-break-after 参考文献 https://www.html.cn/qa/css3/13444.html https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/single_multi_line.html":{"url":"笔记/web前端面试-面试官系列/css/single_multi_line.html","title":"Single Multi Line","keywords":"","body":"面试官：如何实现单行／多行文本溢出的省略样式？ 一、前言 在日常开发展示页面，如果一段文本的数量过长，受制于元素宽度的因素，有可能不能完全显示，为了提高用户的使用体验，这个时候就需要我们把溢出的文本显示成省略号 对于文本的溢出，我们可以分成两种形式： 单行文本溢出 多行文本溢出 二、实现方式 单行文本溢出省略 理解也很简单，即文本在一行内显示，超出部分以省略号的形式展现 实现方式也很简单，涉及的css属性有： text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本 white-space：设置文字在一行显示，不能换行 overflow：文字长度超出限定宽度，则隐藏超出的内容 overflow设为hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略 white-space:nowrap，作用是设置文本不换行，是overflow:hidden和text-overflow：ellipsis生效的基础 text-overflow属性值有如下： clip：当对象内文本溢出部分裁切掉 ellipsis：当对象内文本溢出时显示省略标记（...） text-overflow只有在设置了overflow:hidden和white-space:nowrap才能够生效的 举个例子 p{ overflow: hidden; line-height: 40px; width:400px; height:40px; border:1px solid red; text-overflow: ellipsis; white-space: nowrap; } 效果如下： 可以看到，设置单行文本溢出较为简单，并且省略号显示的位置较好 多行文本溢出省略 多行文本溢出的时候，我们可以分为两种情况： 基于高度截断 基于行数截断 基于高度截断 伪元素 + 定位 核心的css代码结构如下： position: relative：为伪元素绝对定位 overflow: hidden：文本溢出限定的宽度就隐藏内容） position: absolute：给省略号绝对定位 line-height: 20px：结合元素高度,高度固定的情况下,设定行高, 控制显示行数 height: 40px：设定当前元素高度 ::after {} ：设置省略号样式 代码如下所示： .demo { position: relative; line-height: 20px; height: 40px; overflow: hidden; } .demo::after { content: \"...\"; position: absolute; bottom: 0; right: 0; padding: 0 20px 0 10px; } 这是一段很长的文本 实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 overflow: hidden 隐藏多余文字 这种实现具有以下优点： 兼容性好，对各大主流浏览器有好的支持 响应式截断，根据不同宽度做出调整 一般文本存在英文的时候，可以设置word-break: break-all使一个单词能够在换行时进行拆分 基于行数截断 纯css实现也非常简单，核心的css代码如下： -webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的WebKit属性） display: -webkit-box：和1结合使用，将对象作为弹性伸缩盒子模型显示 -webkit-box-orient: vertical：和1结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 overflow: hidden：文本溢出限定的宽度就隐藏内容 text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本 p { width: 400px; border-radius: 1px solid red; -webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; } 这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本 这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本 可以看到，上述使用了webkit的CSS属性扩展，所以兼容浏览器范围是PC端的webkit内核的浏览器，由于移动端大多数是使用webkit，所以移动端常用该形式 需要注意的是，如果文本为一段很长的英文或者数字，则需要添加word-wrap: break-word属性 还能通过使用javascript实现配合css，实现代码如下所示： css结构如下： p { position: relative; width: 400px; line-height: 20px; overflow: hidden; } .p-after:after{ content: \"...\"; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -moz-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(left, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); } javascript代码如下： $(function(){ //获取文本的行高，并获取文本的高度，假设我们规定的行数是五行，那么对超过行数的部分进行限制高度，并加上省略号 $('p').each(function(i, obj){ var lineHeight = parseInt($(this).css(\"line-height\")); var height = parseInt($(this).height()); if((height / lineHeight) >3 ){ $(this).addClass(\"p-after\") $(this).css(\"height\",\"60px\"); }else{ $(this).removeClass(\"p-after\"); } }); }) 参考文献 https://www.zoo.team/article/text-overflow https://segmentfault.com/a/1190000017078153 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/triangle.html":{"url":"笔记/web前端面试-面试官系列/css/triangle.html","title":"Triangle","keywords":"","body":"面试官：CSS如何画一个三角形？原理是什么？ 一、前言 在前端开发的时候，我们有时候会需要用到一个三角形的形状，比如地址选择或者播放器里面播放按钮 通常情况下，我们会使用图片或者svg去完成三角形效果图，但如果单纯使用css如何完成一个三角形呢？ 实现过程似乎也并不困难，通过边框就可完成 二、实现过程 在以前也讲过盒子模型，默认情况下是一个矩形，实现也很简单 .border { width: 50px; height: 50px; border: 2px solid; border-color: #96ceb4 #ffeead #d9534f #ffad60; } 效果如下图所示： 将border设置50px，效果图如下所示： 白色区域则为width、height，这时候只需要你将白色区域部分宽高逐渐变小，最终变为0，则变成如下图所示： 这时候就已经能够看到4个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为0就可以得到下方的红色三角形 但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉 最终实现代码如下： .border { width: 0; height: 0; border-style:solid; border-width: 0 50px 50px; border-color: transparent transparent #d9534f; } 如果想要实现一个只有边框是空心的三角形，由于这里不能再使用border属性，所以最直接的方法是利用伪类新建一个小一点的三角形定位上去 .border { width: 0; height: 0; border-style:solid; border-width: 0 50px 50px; border-color: transparent transparent #d9534f; position: relative; } .border:after{ content: ''; border-style:solid; border-width: 0 40px 40px; border-color: transparent transparent #96ceb4; position: absolute; top: 0; left: 0; } 效果图如下所示： 伪类元素定位参照对象的内容区域宽高都为0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位 将元素定位进行微调以及改变颜色，就能够完成下方效果图： 最终代码如下： .border:after { content: ''; border-style: solid; border-width: 0 40px 40px; border-color: transparent transparent #96ceb4; position: absolute; top: 6px; left: -40px; } 三、原理分析 可以看到，边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形 当分别取消边框的时候，发现下面几种情况： 取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的 当仅有邻边时， 两个边会变成对分的三角 当保留边没有其他接触时，极限情况所有东西都会消失 通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形 如设置直角三角形，如上图倒数第三行实现过程，我们就能知道整个实现原理 实现代码如下： .box { /* 内部大小 */ width: 0px; height: 0px; /* 边框大小 只设置两条边*/ border-top: #4285f4 solid; border-right: transparent solid; border-width: 85px; /* 其他设置 */ margin: 50px; } 参考文献 https://www.cnblogs.com/echolun/p/11888612.html https://juejin.cn/post/6844903567795421197 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/css/visual_scrolling.html":{"url":"笔记/web前端面试-面试官系列/css/visual_scrolling.html","title":"Visual Scrolling","keywords":"","body":"面试官：如何使用css完成视差滚动效果? 一、是什么 视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验 我们可以把网页解刨成：背景层、内容层、悬浮层 当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果 二、实现方式 使用css形式实现视觉差滚动效果的方式有： background-attachment transform:translate3D background-attachment 作用是设置背景图像是否固定或者随着页面的其余部分滚动 值分别有如下： scroll：默认值，背景图像会随着页面其余部分的滚动而移动 fixed：当页面的其余部分滚动时，背景图像不会移动 inherit：继承父元素background-attachment属性的值 完成滚动视觉差就需要将background-attachment属性设置为fixed，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚动 也就是说，背景一开始就已经被固定在初始的位置 核心的css代码如下： section { height: 100vh; } .g-img { background-image: url(...); background-attachment: fixed; background-size: cover; background-position: center center; } 整体例子如下： div { height: 100vh; background: rgba(0, 0, 0, .7); color: #fff; line-height: 100vh; text-align: center; font-size: 20vh; } .a-img1 { background-image: url(https://images.pexels.com/photos/1097491/pexels-photo-1097491.jpeg); background-attachment: fixed; background-size: cover; background-position: center center; } .a-img2 { background-image: url(https://images.pexels.com/photos/2437299/pexels-photo-2437299.jpeg); background-attachment: fixed; background-size: cover; background-position: center center; } .a-img3 { background-image: url(https://images.pexels.com/photos/1005417/pexels-photo-1005417.jpeg); background-attachment: fixed; background-size: cover; background-position: center center; } 1 2 3 4 5 6 7 transform:translate3D 同样，让我们先来看一下两个概念transform和perspective： transform: css3 属性，可以对元素进行变换(2d/3d)，包括平移 translate,旋转 rotate,缩放 scale,等等 perspective: css3 属性，当元素涉及 3d 变换时，perspective 可以定义我们眼睛看到的 3d 立体效果，即空间感 3D视角示意图如下所示： 举个例子： html { overflow: hidden; height: 100% } body { /* 视差元素的父级需要3D视角 */ perspective: 1px; transform-style: preserve-3d; height: 100%; overflow-y: scroll; overflow-x: hidden; } #app{ width: 100vw; height:200vh; background:skyblue; padding-top:100px; } .one{ width:500px; height:200px; background:#409eff; transform: translateZ(0px); margin-bottom: 50px; } .two{ width:500px; height:200px; background:#67c23a; transform: translateZ(-1px); margin-bottom: 150px; } .three{ width:500px; height:200px; background:#e6a23c; transform: translateZ(-2px); margin-bottom: 150px; } one two three 而这种方式实现视觉差动的原理如下： 容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于3D空间中， 子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果 参考文献 https://imweb.io/topic/5b73ef73a56e07401e48729d https://juejin.cn/post/6844903654458146823#heading-5 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/array.html":{"url":"笔记/web前端面试-面试官系列/es6/array.html","title":"Array","keywords":"","body":"面试官：数组新增了哪些扩展？ 一、扩展运算符的应用 ES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 [...document.querySelectorAll('div')] // [, , ] 主要用于函数调用的时候，将一个数组变为参数序列 function push(array, ...items) { array.push(...items); } function add(x, y) { return x + y; } const numbers = [4, 38]; add(...numbers) // 42 可以将某些数据结构转为数组 [...document.querySelectorAll('div')] 能够更简单实现数组复制 const a1 = [1, 2]; const [...a2] = a1; // [1,2] 数组的合并也更为简洁了 const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e']; [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组 下面看个例子就清楚多了 const arr1 = ['a', 'b',[1,2]]; const arr2 = ['c']; const arr3 = [...arr1,...arr2] arr[1][0] = 9999 // 修改arr1里面数组成员值 console.log(arr[3]) // 影响到arr3,['a','b',[9999,2],'c'] 扩展运算符可以与解构赋值结合起来，用于生成数组 const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // [] const [first, ...rest] = [\"foo\"]; first // \"foo\" rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 可以将字符串转为真正的数组 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组 let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'], ]); let arr = [...map.keys()]; // [1, 2, 3] 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错 const obj = {a: 1, b: 2}; let arr = [...obj]; // TypeError: Cannot spread non-iterable object 二、构造函数新增的方法 关于构造函数，数组新增的方法有如下： Array.from() Array.of() Array.from() 将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 }; let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 Array.from([1, 2, 3], (x) => x * x) // [1, 4, 9] Array.of() 用于将一组值，转换为数组 Array.of(3, 11, 8) // [3,11,8] 没有参数的时候，返回一个空数组 当参数只有一个的时候，实际上是指定数组的长度 参数个数不少于 2 个时，Array()才会返回由参数组成的新数组 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 三、实例对象新增的方法 关于数组实例对象新增的方法有如下： copyWithin() find()、findIndex() fill() entries()，keys()，values() includes() flat()，flatMap() copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 参数如下： target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 [1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2 // [4, 5, 3, 4, 5] find()、findIndex() find()用于找出第一个符合条件的数组成员 参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 [1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10 findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 function f(v){ return v > this.age; } let person = {name: 'John', age: 20}; [10, 12, 26, 15].find(f, person); // 26 fill() 使用给定值，填充一个数组 ['a', 'b', 'c'].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 注意，如果填充的类型为对象，则是浅拷贝 entries()，keys()，values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 or (let index of ['a', 'b'].keys()) { console.log(index); } // 0 // 1 for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); } // 0 \"a\" includes() 用于判断数组是否包含给定的值 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 方法的第二个参数表示搜索的起始位置，默认为0 参数为负数则表示倒数的位置 [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true flat()，flatMap() 将数组扁平化处理，返回一个新数组，对原数据没有影响 [1, 2, [3, 4]].flat() // [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1 [1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组 // 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8] flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this 四、数组的空位 数组的空位指，数组的某一个位置没有任何值 ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex() 建议大家在日常书写中，避免出现空位 五、排序稳定性 将sort()默认设置为稳定的排序算法 const arr = [ 'peach', 'straw', 'apple', 'spork' ]; const stableSorting = (s1, s2) => { if (s1[0] 排序结果中，straw在spork的前面，跟原始顺序一致 参考文献 https://es6.ruanyifeng.com/#docs/array 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/decorator.html":{"url":"笔记/web前端面试-面试官系列/es6/decorator.html","title":"Decorator","keywords":"","body":"面试官：你是怎么理解ES6中 Decorator 的？使用场景？ 一、介绍 Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式 简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。 ES6中Decorator功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法 这里定义一个士兵，这时候他什么装备都没有 class soldier{ } 定义一个得到 AK 装备的函数，即装饰器 function strong(target){ target.AK = true } 使用该装饰器对士兵进行增强 @strong class soldier{ } 这时候士兵就有武器了 soldier.AK // true 上述代码虽然简单，但也能够清晰看到了使用Decorator两大优点： 代码可读性变强了，装饰器命名相当于一个注释 在不改变原有代码情况下，对原来功能进行扩展 二、用法 Docorator修饰对象为下面两种： 类的装饰 类属性的装饰 类的装饰 当对类本身进行装饰的时候，能够接受一个参数，即类本身 将装饰器行为进行分解，大家能够有个更深入的了解 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 下面@testable就是一个装饰器，target就是传入的类，即MyTestableClass，实现了为类添加静态属性 @testable class MyTestableClass { // ... } function testable(target) { target.isTestable = true; } MyTestableClass.isTestable // true 如果想要传递参数，可以在装饰器外层再封装一层函数 function testable(isTestable) { return function(target) { target.isTestable = isTestable; } } @testable(true) class MyTestableClass {} MyTestableClass.isTestable // true @testable(false) class MyClass {} MyClass.isTestable // false 类属性的装饰 当对类属性进行装饰的时候，能够接受三个参数： 类的原型对象 需要装饰的属性名 装饰属性名的描述对象 首先定义一个readonly装饰器 function readonly(target, name, descriptor){ descriptor.writable = false; // 将可写属性设为false return descriptor; } 使用readonly装饰类的name方法 class Person { @readonly name() { return `${this.first} ${this.last}` } } 相当于以下调用 readonly(Person.prototype, 'name', descriptor); 如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行 function dec(id){ console.log('evaluated', id); return (target, property, descriptor) =>console.log('executed', id); } class Example { @dec(1) @dec(2) method(){} } // evaluated 1 // evaluated 2 // executed 2 // executed 1 外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行 注意 装饰器不能用于修饰函数，因为函数存在变量声明情况 var counter = 0; var add = function () { counter++; }; @add function foo() { } 编译阶段，变成下面 var counter; var add; @add function foo() { } counter = 0; add = function () { counter++; }; 意图是执行后counter等于 1，但是实际上结果是counter等于 0 三、使用场景 基于Decorator强大的作用，我们能够完成各种场景的需求，下面简单列举几种： 使用react-redux的时候，如果写成下面这种形式，既不雅观也很麻烦 class MyReactComponent extends React.Component {} export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); 通过装饰器就变得简洁多了 @connect(mapStateToProps, mapDispatchToProps) export default class MyReactComponent extends React.Component {} 将mixins，也可以写成装饰器，让使用更为简洁了 function mixins(...list) { return function (target) { Object.assign(target.prototype, ...list); }; } // 使用 const Foo = { foo() { console.log('foo') } }; @mixins(Foo) class MyClass {} let obj = new MyClass(); obj.foo() // \"foo\" 下面再讲讲core-decorators.js几个常见的装饰器 @antobind autobind装饰器使得方法中的this对象，绑定原始对象 import { autobind } from 'core-decorators'; class Person { @autobind getPerson() { return this; } } let person = new Person(); let getPerson = person.getPerson; getPerson() === person; // true @readonly readonly装饰器使得属性或方法不可写 import { readonly } from 'core-decorators'; class Meal { @readonly entree = 'steak'; } var dinner = new Meal(); dinner.entree = 'salmon'; // Cannot assign to read only property 'entree' of [object Object] @deprecate deprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除 import { deprecate } from 'core-decorators'; class Person { @deprecate facepalm() {} @deprecate('功能废除了') facepalmHard() {} } let person = new Person(); person.facepalm(); // DEPRECATION Person#facepalm: This function will be removed in future versions. person.facepalmHard(); // DEPRECATION Person#facepalmHard: 功能废除了 参考文献 https://es6.ruanyifeng.com/#docs/decorator 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/function.html":{"url":"笔记/web前端面试-面试官系列/es6/function.html","title":"Function","keywords":"","body":"面试官：对象新增了哪些扩展？ 一、参数 ES6允许为函数的参数设置默认值 function log(x, y = 'World') { console.log(x, y); } console.log('Hello') // Hello World console.log('Hello', 'China') // Hello China console.log('Hello', '') // Hello 函数的形参是默认声明的，不能使用let或const再次声明 function foo(x = 5) { let x = 1; // error const x = 2; // error } 参数默认值可以与解构赋值的默认值结合起来使用 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property 'x' of undefined 上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免 function foo({x, y = 5} = {}) { console.log(x, y); } foo() // undefined 5 参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined] f(, 1) // 报错 f(undefined, 1) // [1, 1] 二、属性 函数的length属性 length将返回没有指定默认值的参数个数 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 rest 参数也不会计入length属性 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 name属性 返回该函数的函数名 var f = function () {}; // ES5 f.name // \"\" // ES6 f.name // \"f\" 如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字 const bar = function baz() {}; bar.name // \"baz\" Function构造函数返回的函数实例，name属性的值为anonymous (new Function).name // \"anonymous\" bind返回的函数，name属性值会加上bound前缀 function foo() {}; foo.bind({}).name // \"bound foo\" (function(){}).bind({}).name // \"bound \" 三、作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的 下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x let x = 1; function f(y = x) { // 等同于 let y = x let x = 2; console.log(y); } f() // 1 四、严格模式 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错 // 报错 function doSomething(a, b = a) { 'use strict'; // code } // 报错 const doSomething = function ({a, b}) { 'use strict'; // code }; // 报错 const doSomething = (...a) => { 'use strict'; // code }; const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code } }; 五、箭头函数 使用“箭头”（=>）定义函数 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 var f = () => 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 var sum = (num1, num2) => { return num1 + num2; } 如果返回对象，需要加括号将对象包裹 let getTempItem = id => ({ id: id, name: \"Temp\" }); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数 参考文献 https://es6.ruanyifeng.com/#docs/function 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/generator.html":{"url":"笔记/web前端面试-面试官系列/es6/generator.html","title":"Generator","keywords":"","body":"面试官：你是怎么理解ES6中 Generator的？使用场景？ 一、介绍 Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 回顾下上文提到的解决异步的手段： 回调函数 promise 那么，上文我们提到promsie已经是一种比较流行的解决异步方案，那么为什么还出现Generator？甚至async/await呢？ 该问题我们留在后面再进行分析，下面先认识下Generator Generator函数 执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态 形式上，Generator函数是一个普通函数，但是有两个特征： function关键字与函数名之间有一个星号 函数体内部使用yield表达式，定义不同的内部状态 function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending'; } 二、使用 Generator 函数会返回一个遍历器对象，即具有Symbol.iterator属性，并且返回给自己 function* gen(){ // some code } var g = gen(); g[Symbol.iterator]() === g // true 通过yield关键字可以暂停generator函数返回的遍历器对象的状态 function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending'; } var hw = helloWorldGenerator(); 上述存在三个状态：hello、world、return 通过next方法才会遍历到下一个内部状态，其运行逻辑如下： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined hw.next() // { value: 'hello', done: false } hw.next() // { value: 'world', done: false } hw.next() // { value: 'ending', done: true } hw.next() // { value: undefined, done: true } done用来判断是否存在下个状态，value对应状态值 yield表达式本身没有返回值，或者说总是返回undefined 通过调用next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值 function* foo(x) { var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z); } var a = foo(5); a.next() // Object{value:6, done:false} a.next() // Object{value:NaN, done:false} a.next() // Object{value:NaN, done:true} var b = foo(5); b.next() // { value:6, done:false } b.next(12) // { value:8, done:false } b.next(13) // { value:42, done:true } 正因为Generator函数返回Iterator对象，因此我们还可以通过for...of进行遍历 function* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (let v of foo()) { console.log(v); } // 1 2 3 4 5 原生对象没有遍历接口，通过Generator函数为它加上这个接口，就能使用for...of进行遍历了 function* objectEntries(obj) { let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) { yield [propKey, obj[propKey]]; } } let jane = { first: 'Jane', last: 'Doe' }; for (let [key, value] of objectEntries(jane)) { console.log(`${key}: ${value}`); } // first: Jane // last: Doe 三、异步解决方案 回顾之前展开异步解决的方案： 回调函数 Promise 对象 generator 函数 async/await 这里通过文件读取案例，将几种解决异步的方案进行一个比较： 回调函数 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数 fs.readFile('/etc/fstab', function (err, data) { if (err) throw err; console.log(data); fs.readFile('/etc/shells', function (err, data) { if (err) throw err; console.log(data); }); }); readFile函数的第三个参数，就是回调函数，等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行 Promise Promise就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用 const fs = require('fs'); const readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) return reject(error); resolve(data); }); }); }; readFile('/etc/fstab').then(data =>{ console.log(data) return readFile('/etc/shells') }).then(data => { console.log(data) }) 这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强 generator yield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化 const gen = function* () { const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; async/await 将上面Generator函数改成async/await形式，更为简洁，语义化更强了 const asyncReadFile = async function () { const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; 区别： 通过上述代码进行分析，将promise、Generator、async/await进行比较： promise和async/await是专门用于处理异步操作的 Generator并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署Interator接口...） promise编写代码相比Generator、async更为复杂化，且可读性也稍差 Generator、async需要与promise对象搭配处理异步情况 async实质是Generator的语法糖，相当于会自动执行Generator函数 async使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案 四、使用场景 Generator是异步解决的一种方案，最大特点则是将异步操作同步化表达出来 function* loadUI() { showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen(); } var loader = loadUI(); // 加载UI loader.next() // 卸载UI loader.next() 包括redux-saga中间件也充分利用了Generator特性 import { call, put, takeEvery, takeLatest } from 'redux-saga/effects' import Api from '...' function* fetchUser(action) { try { const user = yield call(Api.fetchUser, action.payload.userId); yield put({type: \"USER_FETCH_SUCCEEDED\", user: user}); } catch (e) { yield put({type: \"USER_FETCH_FAILED\", message: e.message}); } } function* mySaga() { yield takeEvery(\"USER_FETCH_REQUESTED\", fetchUser); } function* mySaga() { yield takeLatest(\"USER_FETCH_REQUESTED\", fetchUser); } export default mySaga; 还能利用Generator函数，在对象上实现Iterator接口 function* iterEntries(obj) { let keys = Object.keys(obj); for (let i=0; i 参考文献 https://es6.ruanyifeng.com/#docs/generator-async 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/module.html":{"url":"笔记/web前端面试-面试官系列/es6/module.html","title":"Module","keywords":"","body":"面试官：你是怎么理解ES6中Module的？使用场景？ 一、介绍 模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。 两个基本的特征：外部特征和内部特征 外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能 内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码） 为什么需要模块化 代码抽象 代码封装 代码复用 依赖管理 如果没有模块化，我们代码会怎样？ 变量和方法不容易维护，容易污染全局作用域 加载资源的方式通过script标签从上到下。 依赖的环境主观逻辑偏重，代码较多就会比较复杂。 大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃 因此，需要一种将JavaScript程序模块化的机制，如 CommonJs (典型代表：node.js早期) AMD (典型代表：require.js) CMD (典型代表：sea.js) AMD Asynchronous ModuleDefinition（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行 代表库为require.js /** main.js 入口文件/主模块 **/ // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); CommonJs CommonJS 是一套 Javascript 模块规范，用于服务端 // a.js module.exports={ foo , bar} // b.js const { foo,bar } = require('./a.js') 其有如下特点： 所有代码都运行在模块作用域，不会污染全局作用域 模块是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存 require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值 既然存在了AMD以及CommonJs机制，ES6的Module又有什么不一样？ ES6 在语言标准的层面上，实现了Module，即模块功能，完全可以取代 CommonJS和 AMD规范，成为浏览器和服务器通用的模块解决方案 CommonJS 和AMD 模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性 // CommonJS模块 let { stat, exists, readfile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; ES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量 // ES6模块 import { stat, exists, readFile } from 'fs'; 上述代码，只加载3个方法，其他方法不加载，即 ES6 可以在编译时就完成模块加载 由于编译加载，使得静态分析成为可能。包括现在流行的typeScript也是依靠静态分析实现功能 二、使用 ES6模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是ES5之前就已经规定好 模块功能主要由两个命令构成： export：用于规定模块的对外接口 import：用于输入其他模块提供的功能 export 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 // profile.js export var firstName = 'Michael'; export var lastName = 'Jackson'; export var year = 1958; 或 // 建议使用下面写法，这样能瞬间确定输出了哪些变量 var firstName = 'Michael'; var lastName = 'Jackson'; var year = 1958; export { firstName, lastName, year }; 输出函数或类 export function multiply(x, y) { return x * y; }; 通过as可以进行输出变量的重命名 function v1() { ... } function v2() { ... } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; import 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块 // main.js import { firstName, lastName, year } from './profile.js'; function setName(element) { element.textContent = firstName + ' ' + lastName; } 同样如果想要输入变量起别名，通过as关键字 import { lastName as surname } from './profile.js'; 当加载整个模块的时候，需要用到星号* // circle.js export function area(radius) { return Math.PI * radius * radius; } export function circumference(radius) { return 2 * Math.PI * radius; } // main.js import * as circle from './circle'; console.log(circle) // {area:area,circumference:circumference} 输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性 import {a} from './xxx.js' a.foo = 'hello'; // 合法操作 a = {}; // Syntax Error : 'a' is read-only; 不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错 import后面我们常接着from关键字，from指定模块文件的位置，可以是相对路径，也可以是绝对路径 import { a } from './a'; 如果只有一个模块名，需要有配置文件，告诉引擎模块的位置 import { myMethod } from 'util'; 在编译阶段，import会提升到整个模块的头部，首先执行 foo(); import { foo } from 'my_module'; 多次重复执行同样的导入，只会执行一次 import 'lodash'; import 'lodash'; 上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载 如果不需要知道变量名或函数就完成加载，就要用到export default命令，为模块指定默认输出 // export-default.js export default function () { console.log('foo'); } 加载该模块的时候，import命令可以为该函数指定任意名字 // import-default.js import customName from './export-default'; customName(); // 'foo' 动态加载 允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势 这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。 它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出 import('/modules/myModule.mjs') .then((module) => { // Do something with the module. }); 复合写法 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起 export { foo, bar } from 'my_module'; // 可以简单理解为 import { foo, bar } from 'my_module'; export { foo, bar }; 同理能够搭配as、*搭配使用 三、使用场景 如今，ES6模块化已经深入我们日常项目开发中，像vue、react项目搭建项目，组件化开发处处可见，其也是依赖模块化实现 vue组件 组件化开发 ---- 模块化 export default { name: 'HelloWorld', props: { msg: String } } react组件 function App() { return ( 组件化开发 ---- 模块化 ); } export default App; 包括完成一些复杂应用的时候，我们也可以拆分成各个模块 参考文献 https://macsalvation.net/the-history-of-js-module/ https://es6.ruanyifeng.com/#docs/module 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/object.html":{"url":"笔记/web前端面试-面试官系列/es6/object.html","title":"Object","keywords":"","body":"面试官：对象新增了哪些扩展？ 一、属性的简写 ES6中，当对象键名与对应值名相等的时候，可以进行简写 const baz = {foo:foo} // 等同于 const baz = {foo} 方法也能够进行简写 const o = { method() { return \"Hello!\"; } }; // 等同于 const o = { method: function() { return \"Hello!\"; } } 在函数内作为返回值，也会变得方便很多 function getPoint() { const x = 1; const y = 10; return {x, y}; } getPoint() // {x:1, y:10} 注意：简写的对象方法不能用作构造函数，否则会报错 const obj = { f() { this.foo = 'bar'; } }; new obj.f() // 报错 二、属性名表达式 ES6 允许字面量定义对象时，将表达式放在括号内 let lastWord = 'last word'; const a = { 'first word': 'hello', [lastWord]: 'world' }; a['first word'] // \"hello\" a[lastWord] // \"world\" a['last word'] // \"world\" 表达式还可以用于定义方法名 let obj = { ['h' + 'ello']() { return 'hi'; } }; obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错 // 报错 const foo = 'bar'; const bar = 'abc'; const baz = { [foo] }; // 正确 const foo = 'bar'; const baz = { [foo]: 'abc'}; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object] const keyA = {a: 1}; const keyB = {b: 2}; const myObject = { [keyA]: 'valueA', [keyB]: 'valueB' }; myObject // Object {[object Object]: \"valueB\"} 三、super关键字 this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象 const proto = { foo: 'hello' }; const obj = { foo: 'world', find() { return super.foo; } }; Object.setPrototypeOf(obj, proto); // 为obj设置原型对象 obj.find() // \"hello\" 四、扩展运算符的应用 在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 注意：解构赋值必须是最后一个参数，否则会报错 解构赋值是浅拷贝 let obj = { a: { b: 1 } }; let { ...x } = obj; obj.a.b = 2; // 修改obj里面a属性中键值 x.a.b // 2，影响到了结构出来x的值 对象的扩展运算符等同于使用Object.assign()方法 五、属性的遍历 ES6 一共有 5 种方法可以遍历对象的属性。 for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 上述遍历，都遵守同样的属性遍历的次序规则： 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有 Symbol 键，按照加入时间升序排 Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // ['2', '10', 'b', 'a', Symbol()] 六、对象新增的方法 关于对象新增的方法，分别有以下： Object.is() Object.assign() Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries() Object.is() 严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身 +0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true Object.assign() Object.assign()方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象 const target = { a: 1, b: 1 }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换 Object.getOwnPropertyDescriptors() 返回指定对象所有自身属性（非继承属性）的描述对象 const obj = { foo: 123, get bar() { return 'abc' } }; Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } Object.setPrototypeOf() Object.setPrototypeOf方法用来设置一个对象的原型对象 Object.setPrototypeOf(object, prototype) // 用法 const o = Object.setPrototypeOf({}, null); Object.getPrototypeOf() 用于读取一个对象的原型对象 Object.getPrototypeOf(obj); Object.keys() 返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组 var obj = { foo: 'bar', baz: 42 }; Object.keys(obj) // [\"foo\", \"baz\"] Object.values() 返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组 const obj = { foo: 'bar', baz: 42 }; Object.values(obj) // [\"bar\", 42] Object.entries() 返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组 const obj = { foo: 'bar', baz: 42 }; Object.entries(obj) // [ [\"foo\", \"bar\"], [\"baz\", 42] ] Object.fromEntries() 用于将一个键值对数组转为对象 Object.fromEntries([ ['foo', 'bar'], ['baz', 42] ]) // { foo: \"bar\", baz: 42 } 参考文献 https://es6.ruanyifeng.com/#docs/object 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/promise.html":{"url":"笔记/web前端面试-面试官系列/es6/promise.html","title":"Promise","keywords":"","body":"面试官：你是怎么理解ES6中 Promise的？使用场景？ 一、介绍 Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大 在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码 doSomething(function(result) { doSomethingElse(result, function(newResult) { doThirdThing(newResult, function(finalResult) { console.log('得到最终结果: ' + finalResult); }, failureCallback); }, failureCallback); }, failureCallback); 阅读上面代码，是不是很难受，上述形成了经典的回调地狱 现在通过Promise的改写上面的代码 doSomething().then(function(result) { return doSomethingElse(result); }) .then(function(newResult) { return doThirdThing(newResult); }) .then(function(finalResult) { console.log('得到最终结果: ' + finalResult); }) .catch(failureCallback); 瞬间感受到promise解决异步操作的优点： 链式操作减低了编码难度 代码可读性明显增强 下面我们正式来认识promise： 状态 promise对象仅有三种状态 pending（进行中） fulfilled（已成功） rejected（已失败） 特点 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态 一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果 流程 认真阅读下图，我们能够轻松了解promise整个流程 二、用法 Promise对象是一个构造函数，用来生成Promise实例 const promise = new Promise(function(resolve, reject) {}); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功” reject函数的作用是，将Promise对象的状态从“未完成”变为“失败” 实例方法 Promise构建出来的实例存在以下方法： then() then() catch() finally() then() then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数 then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因 getJSON(\"/posts.json\").then(function(json) { return json.post; }).then(function(post) { // ... }); catch catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数 getJSON('/posts.json').then(function(posts) { // ... }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error); }); Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止 getJSON('/post/1.json').then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); 一般来说，使用catch方法代替then()第二个参数 Promise对象抛出的错误不会传递到外层代码，即不会有任何反应 const someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; 浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程 catch()方法之中，还能再抛出错误，通过后面catch方法捕获到 finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作 promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); 构造函数方法 Promise构造函数存在以下方法： all() race() allSettled() resolve() reject() try() all() Promise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例 const p = Promise.all([p1, p2, p3]); 接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例 实例p的状态由p1、p2、p3决定，分为两种： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法 const p1 = new Promise((resolve, reject) => { resolve('hello'); }) .then(result => result) .catch(e => e); const p2 = new Promise((resolve, reject) => { throw new Error('报错了'); }) .then(result => result) .catch(e => e); Promise.all([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // [\"hello\", Error: 报错了] 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法 const p1 = new Promise((resolve, reject) => { resolve('hello'); }) .then(result => result); const p2 = new Promise((resolve, reject) => { throw new Error('报错了'); }) .then(result => result); Promise.all([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // Error: 报错了 race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例 const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变 率先改变的 Promise 实例的返回值则传递给p的回调函数 const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) { setTimeout(() => reject(new Error('request timeout')), 5000) }) ]); p .then(console.log) .catch(console.error); allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束 const promises = [ fetch('/api-1'), fetch('/api-2'), fetch('/api-3'), ]; await Promise.allSettled(promises); removeLoadingIndicator(); resolve() 将现有对象转为 Promise对象 Promise.resolve('foo') // 等价于 new Promise(resolve => resolve('foo')) 参数可以分成四种情况，分别如下： 参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例 参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法 参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved 没有参数时，直接返回一个resolved状态的 Promise 对象 reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected const p = Promise.reject('出错了'); // 等同于 const p = new Promise((resolve, reject) => reject('出错了')) p.then(null, function (s) { console.log(s) }); // 出错了 Promise.reject()方法的参数，会原封不动地变成后续方法的参数 Promise.reject('出错了') .catch(e => { console.log(e === '出错了') }) // true 三、使用场景 将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化 const preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); }; 通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题 // 各司其职 getInfo().then(res=>{ let { bannerList } = res //渲染轮播图 console.log(bannerList) return res }).then(res=>{ let { storeList } = res //渲染店铺列表 console.log(storeList) return res }).then(res=>{ let { categoryList } = res console.log(categoryList) //渲染分类列表 return res }) 通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可 function initLoad(){ // loading.show() //加载loading Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>{ console.log(res) loading.hide() //关闭loading }).catch(err=>{ console.log(err) loading.hide()//关闭loading }) } //数据初始化 initLoad() 通过race可以设置图片请求超时 //请求某个图片资源 function requestImg(){ var p = new Promise(function(resolve, reject){ var img = new Image(); img.onload = function(){ resolve(img); } //img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\"; 正确的 img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1\"; }); return p; } //延时函数，用于给请求计时 function timeout(){ var p = new Promise(function(resolve, reject){ setTimeout(function(){ reject('图片请求超时'); }, 5000); }); return p; } Promise .race([requestImg(), timeout()]) .then(function(results){ console.log(results); }) .catch(function(reason){ console.log(reason); }); 参考文献 https://es6.ruanyifeng.com/#docs/promise 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/proxy.html":{"url":"笔记/web前端面试-面试官系列/es6/proxy.html","title":"Proxy","keywords":"","body":"面试官：你是怎么理解ES6中Proxy的？使用场景? 一、介绍 定义： 用于定义基本操作的自定义行为 本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(meta programming) 元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作 一段代码来理解 #!/bin/bash # metaprogram echo '#!/bin/bash' >program for ((I=1; I>program done chmod +x program 这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为1024行echo，如果我们手动来写1024行代码，效率显然低效 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译 Proxy 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等） 二、用法 Proxy为 构造函数，用来生成 Proxy实例 var proxy = new Proxy(target, handler) 参数 target表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理）） handler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 handler解析 关于handler拦截属性，有如下： get(target,propKey,receiver)：拦截对象属性的读取 set(target,propKey,value,receiver)：拦截对象属性的设置 has(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值 deleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值 ownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc），返回一个布尔值 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作 Reflect 若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API 基本特点： 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false） 让Object操作都变成函数行为 下面我们介绍proxy几种用法： get() get接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选 var person = { name: \"张三\" }; var proxy = new Proxy(person, { get: function(target, propKey) { return Reflect.get(target,propKey) } }); proxy.name // \"张三\" get能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引 function createArray(...elements) { let handler = { get(target, propKey, receiver) { let index = Number(propKey); if (index 注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错 const target = Object.defineProperties({}, { foo: { value: 123, writable: false, configurable: false }, }); const handler = { get(target, propKey) { return 'abc'; } }; const proxy = new Proxy(target, handler); proxy.foo // TypeError: Invariant check failed set() set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求 let validator = { set: function(obj, prop, value) { if (prop === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value > 200) { throw new RangeError('The age seems invalid'); } } // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; } }; let person = new Proxy({}, validator); person.age = 100; person.age // 100 person.age = 'young' // 报错 person.age = 300 // 报错 如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用 const obj = {}; Object.defineProperty(obj, 'foo', { value: 'bar', writable: false, }); const handler = { set: function(obj, prop, value, receiver) { obj[prop] = 'baz'; } }; const proxy = new Proxy(obj, handler); proxy.foo = 'baz'; proxy.foo // \"bar\" 注意，严格模式下，set代理如果没有返回true，就会报错 'use strict'; const handler = { set: function(obj, prop, value, receiver) { obj[prop] = receiver; // 无论有没有下面这一行，都会报错 return false; } }; const proxy = new Proxy({}, handler); proxy.foo = 'bar'; // TypeError: 'set' on proxy: trap returned falsish for property 'foo' deleteProperty() deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除 var handler = { deleteProperty (target, key) { invariant(key, 'delete'); Reflect.deleteProperty(target,key) return true; } }; function invariant (key, action) { if (key[0] === '_') { throw new Error(`无法删除私有属性`); } } var target = { _prop: 'foo' }; var proxy = new Proxy(target, handler); delete proxy._prop // Error: 无法删除私有属性 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错 取消代理 Proxy.revocable(target, handler); 三、使用场景 Proxy其功能非常类似于设计模式中的代理模式，常用功能如下： 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 使用 Proxy 保障数据类型的准确性 let numericDataStore = { count: 0, amount: 1234, total: 14 }; numericDataStore = new Proxy(numericDataStore, { set(target, key, value, proxy) { if (typeof value !== 'number') { throw Error(\"属性只能是number类型\"); } return Reflect.set(target, key, value, proxy); } }); numericDataStore.count = \"foo\" // Error: 属性只能是number类型 numericDataStore.count = 333 // 赋值成功 声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey let api = { _apiKey: '123abc456def', getUsers: function(){ }, getUser: function(userId){ }, setUser: function(userId, config){ } }; const RESTRICTED = ['_apiKey']; api = new Proxy(api, { get(target, key, proxy) { if(RESTRICTED.indexOf(key) > -1) { throw Error(`${key} 不可访问.`); } return Reflect.get(target, key, proxy); }, set(target, key, value, proxy) { if(RESTRICTED.indexOf(key) > -1) { throw Error(`${key} 不可修改`); } return Reflect.get(target, key, value, proxy); } }); console.log(api._apiKey) api._apiKey = '987654321' // 上述都抛出错误 还能通过使用Proxy实现观察者模式 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行 observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数 const queuedObservers = new Set(); const observe = fn => queuedObservers.add(fn); const observable = obj => new Proxy(obj, {set}); function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer => observer()); return result; } 观察者函数都放进Set集合，当修改obj的值，在会set函数中拦截，自动执行Set所有的观察者 参考文献 https://es6.ruanyifeng.com/#docs/proxy https://vue3js.cn/es6 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/es6/set_map.html":{"url":"笔记/web前端面试-面试官系列/es6/set_map.html","title":"Set Map","keywords":"","body":"面试官：你是怎么理解ES6新增Set、Map两种数据结构的？ 如果要用一句来描述，我们可以说 Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构 什么是集合？什么又是字典？ 集合是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合 字典是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同 区别？ 共同点：集合、字典都可以存储不重复的值 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储 一、Set Set是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合 Set本身是一个构造函数，用来生成 Set 数据结构 const s = new Set(); 增删改查 Set的实例关于增删改查的方法： add() delete() has() clear() add() 添加某个值，返回 Set 结构本身 当添加实例中已经存在的元素，set不会进行处理添加 s.add(1).add(2).add(2); // 2只被添加了一次 delete() 删除某个值，返回一个布尔值，表示删除是否成功 s.delete(1) has() 返回一个布尔值，判断该值是否为Set的成员 s.has(2) clear() 清除所有成员，没有返回值 s.clear() 遍历 Set实例遍历的方法有如下： 关于遍历的方法，有如下： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Set的遍历顺序就是插入顺序 keys方法、values方法、entries方法返回的都是遍历器对象 let set = new Set(['red', 'green', 'blue']); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.values()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [\"red\", \"red\"] // [\"green\", \"green\"] // [\"blue\", \"blue\"] forEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this let set = new Set([1, 4, 9]); set.forEach((value, key) => console.log(key + ' : ' + value)) // 1 : 1 // 4 : 4 // 9 : 9 扩展运算符和Set 结构相结合实现数组或字符串去重 // 数组 let arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; // [3, 5, 2] // 字符串 let str = \"352255\"; let unique = [...new Set(str)].join(\"\"); // \"\" 实现并集、交集、和差集 let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3} // （a 相对于 b 的）差集 let difference = new Set([...a].filter(x => !b.has(x))); // Set {1} 二、Map Map类型是键值对的有序列表，而键和值都可以是任意类型 Map本身是一个构造函数，用来生成 Map 数据结构 const m = new Map() 增删改查 Map 结构的实例针对增删改查有以下属性和操作方法： size 属性 set() get() has() delete() clear() size size属性返回 Map 结构的成员总数。 const map = new Map(); map.set('foo', true); map.set('bar', false); map.size // 2 set() 设置键名key对应的键值为value，然后返回整个 Map 结构 如果key已经有值，则键值会被更新，否则就新生成该键 同时返回的是当前Map对象，可采用链式写法 const m = new Map(); m.set('edition', 6) // 键是字符串 m.set(262, 'standard') // 键是数值 m.set(undefined, 'nah') // 键是 undefined m.set(1, 'a').set(2, 'b').set(3, 'c') // 链式操作 get() get方法读取key对应的键值，如果找不到key，返回undefined const m = new Map(); const hello = function() {console.log('hello');}; m.set(hello, 'Hello ES6!') // 键是函数 m.get(hello) // Hello ES6! has() has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中 const m = new Map(); m.set('edition', 6); m.set(262, 'standard'); m.set(undefined, 'nah'); m.has('edition') // true m.has('years') // false m.has(262) // true m.has(undefined) // true delete() delete方法删除某个键，返回true。如果删除失败，返回false const m = new Map(); m.set(undefined, 'nah'); m.has(undefined) // true m.delete(undefined) m.has(undefined) // false clear() clear方法清除所有成员，没有返回值 let map = new Map(); map.set('foo', true); map.set('bar', false); map.size // 2 map.clear() map.size // 0 遍历 Map结构原生提供三个遍历器生成函数和一个遍历方法： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 遍历顺序就是插入顺序 const map = new Map([ ['F', 'no'], ['T', 'yes'], ]); for (let key of map.keys()) { console.log(key); } // \"F\" // \"T\" for (let value of map.values()) { console.log(value); } // \"no\" // \"yes\" for (let item of map.entries()) { console.log(item[0], item[1]); } // \"F\" \"no\" // \"T\" \"yes\" // 或者 for (let [key, value] of map.entries()) { console.log(key, value); } // \"F\" \"no\" // \"T\" \"yes\" // 等同于使用map.entries() for (let [key, value] of map) { console.log(key, value); } // \"F\" \"no\" // \"T\" \"yes\" map.forEach(function(value, key, map) { console.log(\"Key: %s, Value: %s\", key, value); }); 三、WeakSet 和 WeakMap WeakSet 创建WeakSet实例 const ws = new WeakSet(); WeakSet可以接受一个具有 Iterable接口的对象作为参数 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} 在API中WeakSet与Set有两个区别： 没有遍历操作的API 没有size属性 WeackSet只能成员只能是引用类型，而不能是其他类型的值 let ws=new WeakSet(); // 成员不是引用类型 let weakSet=new WeakSet([2,3]); console.log(weakSet) // 报错 // 成员为引用类型 let obj1={name:1} let obj2={name:1} let ws=new WeakSet([obj1,obj2]); console.log(ws) //WeakSet { {…}, {…}} WeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失 WeakMap WeakMap结构与Map结构类似，也是用于生成键值对的集合 在API中WeakMap与Map有两个区别： 没有遍历操作的API 没有clear清空方法 // WeakMap 可以使用 set 方法添加成员 const wm1 = new WeakMap(); const key = {foo: 1}; wm1.set(key, 2); wm1.get(key) // 2 // WeakMap 也可以接受一个数组， // 作为构造函数的参数 const k1 = [1, 2, 3]; const k2 = [4, 5, 6]; const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]); wm2.get(k2) // \"bar\" WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名 const map = new WeakMap(); map.set(1, 2) // TypeError: 1 is not an object! map.set(Symbol(), 2) // TypeError: Invalid value used as weak map key map.set(null, 2) // TypeError: Invalid value used as weak map key WeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用 举个场景例子： 在网页的 DOM 元素上添加数据，就可以使用WeakMap结构，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除 const wm = new WeakMap(); const element = document.getElementById('example'); wm.set(element, 'some information'); wm.get(element) // \"some information\" 注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用 下面代码中，键值obj会在WeakMap产生新的引用，当你修改obj不会影响到内部 const wm = new WeakMap(); let key = {}; let obj = {foo: 1}; wm.set(key, obj); obj = null; wm.get(key) // Object {foo: 1} 参考文献 https://es6.ruanyifeng.com/#docs/set-map 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/es6/var_let_const.html":{"url":"笔记/web前端面试-面试官系列/es6/var_let_const.html","title":"Var Let Const","keywords":"","body":"面试官：说说var、let、const之间的区别 一、var 在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量 注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象 var a = 10; console.log(window.a) // 10 使用var声明的变量存在变量提升的情况 console.log(a) // undefined var a = 20 在编译阶段，编译器会将其变成以下执行 var a console.log(a) a = 20 使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明 var a = 20 var a = 30 console.log(a) // 30 在函数中使用使用var声明变量时候，该变量是局部的 var a = 20 function change(){ var a = 30 } change() console.log(a) // 20 而如果在函数内不使用var，该变量是全局的 var a = 20 function change(){ a = 30 } change() console.log(a) // 30 二、let let是ES6新增的命令，用来声明变量 用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 { let a = 20 } console.log(a) // ReferenceError: a is not defined. 不存在变量提升 console.log(a) // 报错ReferenceError let a = 2 这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误 只要块级作用域内存在let命令，这个区域就不再受外部影响 var a = 123 if (true) { a = 'abc' // ReferenceError let a; } 使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区” 最后，let不允许在相同作用域中重复声明 let a = 20 let a = 30 // Uncaught SyntaxError: Identifier 'a' has already been declared 注意的是相同作用域，下面这种情况是不会报错的 let a = 20 { let a = 30 } 因此，我们不能在函数内部重新声明参数 function func(arg) { let arg; } func() // Uncaught SyntaxError: Identifier 'arg' has already been declared 三、const const声明一个只读的常量，一旦声明，常量的值就不能改变 const a = 1 a = 3 // TypeError: Assignment to constant variable. 这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 const a; // SyntaxError: Missing initializer in const declaration 如果之前用var或let声明过变量，再用const声明同样会报错 var a = 20 let b = 20 const a = 30 const b = 30 // 都会报错 const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动 对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量 对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变 const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only 其它情况，const与let一致 四、区别 var、let、const三者区别可以围绕下面五点展开： 变量提升 暂时性死区 块级作用域 重复声明 修改声明的变量 使用 变量提升 var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错 // var console.log(a) // undefined var a = 10 // let console.log(b) // Cannot access 'b' before initialization let b = 10 // const console.log(c) // Cannot access 'c' before initialization const c = 10 暂时性死区 var不存在暂时性死区 let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 // var console.log(a) // undefined var a = 10 // let console.log(b) // Cannot access 'b' before initialization let b = 10 // const console.log(c) // Cannot access 'c' before initialization const c = 10 块级作用域 var不存在块级作用域 let和const存在块级作用域 // var { var a = 20 } console.log(a) // 20 // let { let b = 20 } console.log(b) // Uncaught ReferenceError: b is not defined // const { const c = 20 } console.log(c) // Uncaught ReferenceError: c is not defined 重复声明 var允许重复声明变量 let和const在同一作用域不允许重复声明变量 // var var a = 10 var a = 20 // 20 // let let b = 10 let b = 20 // Identifier 'b' has already been declared // const const c = 10 const c = 20 // Identifier 'c' has already been declared 修改声明的变量 var和let可以 const声明一个只读的常量。一旦声明，常量的值就不能改变 // var var a = 10 a = 20 console.log(a) // 20 //let let b = 10 b = 20 console.log(b) // 20 // const const c = 10 c = 20 console.log(c) // Uncaught TypeError: Assignment to constant variable 使用 能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var 参考文献 https://es6.ruanyifeng.com/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/404.html":{"url":"笔记/web前端面试-面试官系列/vue/404.html","title":"404","keywords":"","body":"面试官：vue项目本地开发完成后部署到服务器后报404是什么原因呢？ 一、如何部署 前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的web容器指定的静态目录下即可 我们知道vue项目在构建后，是生成一系列的静态文件 常规布署我们只需要将这个目录上传至目标服务器即可 // scp 上传 user为主机登录用户，host为主机外网ip, xx为web容器静态资源路径 scp dist.zip user@host:/xx/xx/xx 让web容器跑起来，以nginx为例 server { listen 80; server_name www.xxx.com; location / { index /data/dist/index.html; } } 配置完成记得重启nginx // 检查配置是否正确 nginx -t // 平滑重启 nginx -s reload 操作完后就可以在浏览器输入域名进行访问了 当然上面只是提到最简单也是最直接的一种布署方式 什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开 二、404问题 这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？ 我们先还原一下场景： vue项目在本地时运行正常，但部署到服务器中，刷新页面，出现了404错误 先定位一下，HTTP 404 错误意味着链接指向的资源不存在 问题在于为什么不存在？且为什么只有history模式下会出现这个问题？ 为什么history模式下有问题 Vue是属于单页应用（single-page application） 而SPA是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个index.html 现在，我们回头来看一下我们的nginx配置 server { listen 80; server_name www.xxx.com; location / { index /data/dist/index.html; } } 可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 www.xxx.com/login 关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况 为什么hash模式下没有问题 router hash 模式我们都知道是用符号#表示的，如 website.com/#/login, hash 的值为 #/login 它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com/#/login 只有 website.com 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误 解决方案 看到这里我相信大部分同学都能想到怎么解决问题了， 产生问题的本质是因为我们的路由是通过JS来执行视图切换的， 当我们进入到子路由时刷新页面，web容器没有相对应的页面此时会出现404 所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理 对nginx配置文件.conf修改，添加try_files $uri $uri/ /index.html; server { listen 80; server_name www.xxx.com; location / { index /data/dist/index.html; try_files $uri $uri/ /index.html; } } 修改完配置文件后记得配置的更新 nginx -s reload 这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件 为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面 const router = new VueRouter({ mode: 'history', routes: [ { path: '*', component: NotFoundComponent } ] }) 关于后端配置方案还有：Apache、nodejs等，思想是一致的，这里就不展开述说了 参考文献 https://juejin.cn/post/6844903872637632525 https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/axios.html":{"url":"笔记/web前端面试-面试官系列/vue/axios.html","title":"Axios","keywords":"","body":"面试官：Vue项目中有封装过axios吗？主要是封装哪方面的？ 一、axios是什么 axios 是一个轻量的 HTTP客户端 基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。自Vue2.0起，尤大宣布取消对 vue-resource 的官方推荐，转而推荐 axios。现在 axios 已经成为大部分 Vue 开发者的首选 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON 数据 客户端支持防御XSRF 基本使用 安装 // 项目中安装 npm install axios --S // cdn 引入 导入 import axios from 'axios' 发送请求 axios({ url:'xxx', // 设置请求的地址 method:\"GET\", // 设置请求方法 params:{ // get请求使用params进行参数凭借,如果是post请求用data type: '', page: 1 } }).then(res => { // res为后端返回的数据 console.log(res); }) 并发请求axios.all([]) function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (res1, res2) { // res1第一个请求的返回的内容，res2第二个请求返回的内容 // 两个请求都执行完成才会执行 })); 二、为什么要封装 axios 的 API 很友好，你完全可以很轻松地在项目中直接使用。 不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍 这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 axios 再使用 举个例子： axios('http://localhost:3000/data', { // 配置代码 method: 'GET', timeout: 1000, withCredentials: true, headers: { 'Content-Type': 'application/json', Authorization: 'xxx', }, transformRequest: [function (data, headers) { return data; }], // 其他请求配置... }) .then((data) => { // todo: 真正业务逻辑代码 console.log(data); }, (err) => { // 错误处理代码 if (err.response.status === 401) { // handle authorization error } if (err.response.status === 403) { // handle server forbidden error } // 其他错误处理..... console.log(err); }); 如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了 这时候我们就需要对axios进行二次封装，让使用更为便利 三、如何封装 封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间....... 设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分 请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务) 状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好 请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便 请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问 响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务 设置接口请求前缀 利用node环境变量来作判断，用来区分开发、测试、生产环境 if (process.env.NODE_ENV === 'development') { axios.defaults.baseURL = 'http://dev.xxx.com' } else if (process.env.NODE_ENV === 'production') { axios.defaults.baseURL = 'http://prod.xxx.com' } 在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域 devServer: { proxy: { '/proxyApi': { target: 'http://dev.xxx.com', changeOrigin: true, pathRewrite: { '/proxyApi': '' } } } } 设置请求头与超时时间 大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置 const service = axios.create({ ... timeout: 30000, // 请求 30s 超时 headers: { get: { 'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8' // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 }, post: { 'Content-Type': 'application/json;charset=utf-8' // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 } }, }) 封装请求方法 先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去 // get 请求 export function httpGet({ url, params = {} }) { return new Promise((resolve, reject) => { axios.get(url, { params }).then((res) => { resolve(res.data) }).catch(err => { reject(err) }) }) } // post // post请求 export function httpPost({ url, data = {}, params = {} }) { return new Promise((resolve, reject) => { axios({ url, method: 'post', transformRequest: [function (data) { let ret = '' for (let it in data) { ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&' } return ret }], // 发送的数据 data, // url参数 params }).then(res => { resolve(res.data) }) }) } 把封装的方法放在一个api.js文件中 import { httpGet, httpPost } from './http' export const getorglist = (params = {}) => httpGet({ url: 'apps/api/org/list', params }) 页面中就能直接调用 // .vue import { getorglist } from '@/assets/js/api' getorglist({ id: 200 }).then(res => { console.log(res) }) 这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可 请求拦截器 请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便 // 请求拦截器 axios.interceptors.request.use( config => { // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的 token && (config.headers.Authorization = token) return config }, error => { return Promise.error(error) }) 响应拦截器 响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权 // 响应拦截器 axios.interceptors.response.use(response => { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { if (response.data.code === 511) { // 未授权调取授权接口 } else if (response.data.code === 510) { // 未登录跳转登录页 } else { return Promise.resolve(response) } } else { return Promise.reject(response) } }, error => { // 我们可以在这里对异常状态作统一处理 if (error.response.status) { // 处理请求失败的情况 // 对不同返回码对相应处理 return Promise.reject(error.response) } }) 小结 封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力 封装 axios 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案 参考文献 https://www.html.cn/qa/vue-js/20544.html https://juejin.cn/post/6844904033782611976 https://juejin.cn/post/6844903801451708429 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:27:28 "},"笔记/web前端面试-面试官系列/vue/axiosCode.html":{"url":"笔记/web前端面试-面试官系列/vue/axiosCode.html","title":"AxiosCode","keywords":"","body":"面试官：你了解axios的原理吗？有看过它的源码吗？ 一、axios的使用 关于axios的基本使用，上篇文章已经有所涉及，这里再稍微回顾下： 发送请求 import axios from 'axios'; axios(config) // 直接传入配置 axios(url[, config]) // 传入url和配置 axios[method](url[, option]) // 直接调用请求方式方法，传入url和配置 axios[method](url[, data[, option]]) // 直接调用请求方式方法，传入data、url和配置 axios.request(option) // 调用 request 方法 const axiosInstance = axios.create(config) // axiosInstance 也具有以上 axios 的能力 axios.all([axiosInstance1, axiosInstance2]).then(axios.spread(response1, response2)) // 调用 all 和传入 spread 回调 请求拦截器 axios.interceptors.request.use(function (config) { // 这里写发送请求前处理的代码 return config; }, function (error) { // 这里写发送请求错误相关的代码 return Promise.reject(error); }); 响应拦截器 axios.interceptors.response.use(function (response) { // 这里写得到响应数据后处理的代码 return response; }, function (error) { // 这里写得到错误响应处理的代码 return Promise.reject(error); }); 取消请求 // 方式一 const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('xxxx', { cancelToken: source.token }) // 取消请求 (请求原因是可选的) source.cancel('主动取消请求'); // 方式二 const CancelToken = axios.CancelToken; let cancel; axios.get('xxxx', { cancelToken: new CancelToken(function executor(c) { cancel = c; }) }); cancel('主动取消请求'); 二、实现一个简易版axios 构建一个Axios构造函数，核心代码为request class Axios { constructor() { } request(config) { return new Promise(resolve => { const {url = '', method = 'get', data = {}} = config; // 发送ajax请求 const xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.onload = function() { console.log(xhr.responseText) resolve(xhr.responseText); } xhr.send(data); }) } } 导出axios实例 // 最终导出axios的方法，即实例的request方法 function CreateAxiosFn() { let axios = new Axios(); let req = axios.request.bind(axios); return req; } // 得到最后的全局变量axios let axios = CreateAxiosFn(); 上述就已经能够实现axios({ })这种方式的请求 下面是来实现下axios.method()这种形式的请求 // 定义get,post...方法，挂在到Axios原型上 const methodsArr = ['get', 'delete', 'head', 'options', 'put', 'patch', 'post']; methodsArr.forEach(met => { Axios.prototype[met] = function() { console.log('执行'+met+'方法'); // 处理单个方法 if (['get', 'delete', 'head', 'options'].includes(met)) { // 2个参数(url[, config]) return this.request({ method: met, url: arguments[0], ...arguments[1] || {} }) } else { // 3个参数(url[,data[,config]]) return this.request({ method: met, url: arguments[0], data: arguments[1] || {}, ...arguments[2] || {} }) } } }) 将Axios.prototype上的方法搬运到request上 首先实现个工具类，实现将b方法混入到a，并且修改this指向 const utils = { extend(a,b, context) { for(let key in b) { if (b.hasOwnProperty(key)) { if (typeof b[key] === 'function') { a[key] = b[key].bind(context); } else { a[key] = b[key] } } } } } 修改导出的方法 function CreateAxiosFn() { let axios = new Axios(); let req = axios.request.bind(axios); // 增加代码 utils.extend(req, Axios.prototype, axios) return req; } 构建拦截器的构造函数 class InterceptorsManage { constructor() { this.handlers = []; } use(fullfield, rejected) { this.handlers.push({ fullfield, rejected }) } } 实现axios.interceptors.response.use和axios.interceptors.request.use class Axios { constructor() { // 新增代码 this.interceptors = { request: new InterceptorsManage, response: new InterceptorsManage } } request(config) { ... } } 执行语句axios.interceptors.response.use和axios.interceptors.request.use的时候，实现获取axios实例上的interceptors对象，然后再获取response或request拦截器，再执行对应的拦截器的use方法 把Axios上的方法和属性搬到request过去 function CreateAxiosFn() { let axios = new Axios(); let req = axios.request.bind(axios); // 混入方法， 处理axios的request方法，使之拥有get,post...方法 utils.extend(req, Axios.prototype, axios) // 新增代码 utils.extend(req, axios) return req; } 现在request也有了interceptors对象，在发送请求的时候，会先获取request拦截器的handlers的方法来执行 首先将执行ajax的请求封装成一个方法 request(config) { this.sendAjax(config) } sendAjax(config){ return new Promise(resolve => { const {url = '', method = 'get', data = {}} = config; // 发送ajax请求 console.log(config); const xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.onload = function() { console.log(xhr.responseText) resolve(xhr.responseText); }; xhr.send(data); }) } 获得handlers中的回调 request(config) { // 拦截器和请求组装队列 let chain = [this.sendAjax.bind(this), undefined] // 成对出现的，失败回调暂时不处理 // 请求拦截 this.interceptors.request.handlers.forEach(interceptor => { chain.unshift(interceptor.fullfield, interceptor.rejected) }) // 响应拦截 this.interceptors.response.handlers.forEach(interceptor => { chain.push(interceptor.fullfield, interceptor.rejected) }) // 执行队列，每次执行一对，并给promise赋最新的值 let promise = Promise.resolve(config); while(chain.length > 0) { promise = promise.then(chain.shift(), chain.shift()) } return promise; } chains大概是['fulfilled1','reject1','fulfilled2','reject2','this.sendAjax','undefined','fulfilled2','reject2','fulfilled1','reject1']这种形式 这样就能够成功实现一个简易版axios 三、源码分析 首先看看目录结构 axios发送请求有很多实现的方法，实现入口文件为axios.js function createInstance(defaultConfig) { var context = new Axios(defaultConfig); // instance指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用 // Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用 var instance = bind(Axios.prototype.request, context); // 把Axios.prototype上的方法扩展到instance对象上， // 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context utils.extend(instance, Axios.prototype, context); // Copy context to instance // 把context对象上的自身属性和方法扩展到instance上 // 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性 // 这样，instance 就有了 defaults、interceptors 属性。 utils.extend(instance, context); return instance; } // Create the default instance to be exported 创建一个由默认配置生成的axios实例 var axios = createInstance(defaults); // Factory for creating new instances 扩展axios.create工厂函数，内部也是 createInstance axios.create = function create(instanceConfig) { return createInstance(mergeConfig(axios.defaults, instanceConfig)); }; // Expose all/spread axios.all = function all(promises) { return Promise.all(promises); }; axios.spread = function spread(callback) { return function wrap(arr) { return callback.apply(null, arr); }; }; module.exports = axios; 主要核心是 Axios.prototype.request，各种请求方式的调用实现都是在 request 内部实现的， 简单看下 request 的逻辑 Axios.prototype.request = function request(config) { // Allow for axios('example/url'[, config]) a la fetch API // 判断 config 参数是否是 字符串，如果是则认为第一个参数是 URL，第二个参数是真正的config if (typeof config === 'string') { config = arguments[1] || {}; // 把 url 放置到 config 对象中，便于之后的 mergeConfig config.url = arguments[0]; } else { // 如果 config 参数是否是 字符串，则整体都当做config config = config || {}; } // 合并默认配置和传入的配置 config = mergeConfig(this.defaults, config); // 设置请求方法 config.method = config.method ? config.method.toLowerCase() : 'get'; /* something... 此部分会在后续拦截器单独讲述 */ }; // 在 Axios 原型上挂载 'delete', 'get', 'head', 'options' 且不传参的请求方法，实现内部也是 request utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { Axios.prototype[method] = function(url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); }; }); // 在 Axios 原型上挂载 'post', 'put', 'patch' 且传参的请求方法，实现内部同样也是 request utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { Axios.prototype[method] = function(url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); }; }); request入口参数为config，可以说config贯彻了axios的一生 axios 中的 config主要分布在这几个地方： 默认配置 defaults.js config.method默认为 get 调用 createInstance 方法创建 axios实例，传入的config 直接或间接调用 request 方法，传入的 config // axios.js // 创建一个由默认配置生成的axios实例 var axios = createInstance(defaults); // 扩展axios.create工厂函数，内部也是 createInstance axios.create = function create(instanceConfig) { return createInstance(mergeConfig(axios.defaults, instanceConfig)); }; // Axios.js // 合并默认配置和传入的配置 config = mergeConfig(this.defaults, config); // 设置请求方法 config.method = config.method ? config.method.toLowerCase() : 'get'; 从源码中，可以看到优先级：默认配置对象default method:get Axios的实例属性this.default request参数 下面重点看看request方法 Axios.prototype.request = function request(config) { /* 先是 mergeConfig ... 等，不再阐述 */ // Hook up interceptors middleware 创建拦截器链. dispatchRequest 是重中之重，后续重点 var chain = [dispatchRequest, undefined]; // push各个拦截器方法 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { // 请求拦截器逆序 注意此处的 forEach 是自定义的拦截器的forEach方法 chain.unshift(interceptor.fulfilled, interceptor.rejected); }); this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { // 响应拦截器顺序 注意此处的 forEach 是自定义的拦截器的forEach方法 chain.push(interceptor.fulfilled, interceptor.rejected); }); // 初始化一个promise对象，状态为resolved，接收到的参数为已经处理合并过的config对象 var promise = Promise.resolve(config); // 循环拦截器的链 while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); // 每一次向外弹出拦截器 } // 返回 promise return promise; }; 拦截器interceptors是在构建axios实例化的属性 function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), // 请求拦截 response: new InterceptorManager() // 响应拦截 }; } InterceptorManager构造函数 // 拦截器的初始化 其实就是一组钩子函数 function InterceptorManager() { this.handlers = []; } // 调用拦截器实例的use时就是往钩子函数中push方法 InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1; }; // 拦截器是可以取消的，根据use的时候返回的ID，把某一个拦截器方法置为null // 不能用 splice 或者 slice 的原因是 删除之后 id 就会变化，导致之后的顺序或者是操作不可控 InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; } }; // 这就是在 Axios的request方法中 中循环拦截器的方法 forEach 循环执行钩子函数 InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } }); } 请求拦截器方法是被 unshift到拦截器中，响应拦截器是被push到拦截器中的。最终它们会拼接上一个叫dispatchRequest的方法被后续的 promise 顺序执行 var utils = require('./../utils'); var transformData = require('./transformData'); var isCancel = require('../cancel/isCancel'); var defaults = require('../defaults'); var isAbsoluteURL = require('./../helpers/isAbsoluteURL'); var combineURLs = require('./../helpers/combineURLs'); // 判断请求是否已被取消，如果已经被取消，抛出已取消 function throwIfCancellationRequested(config) { if (config.cancelToken) { config.cancelToken.throwIfRequested(); } } module.exports = function dispatchRequest(config) { throwIfCancellationRequested(config); // 如果包含baseUrl, 并且不是config.url绝对路径，组合baseUrl以及config.url if (config.baseURL && !isAbsoluteURL(config.url)) { // 组合baseURL与url形成完整的请求路径 config.url = combineURLs(config.baseURL, config.url); } config.headers = config.headers || {}; // 使用/lib/defaults.js中的transformRequest方法，对config.headers和config.data进行格式化 // 比如将headers中的Accept，Content-Type统一处理成大写 // 比如如果请求正文是一个Object会格式化为JSON字符串，并添加application/json;charset=utf-8的Content-Type // 等一系列操作 config.data = transformData( config.data, config.headers, config.transformRequest ); // 合并不同配置的headers，config.headers的配置优先级更高 config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers || {} ); // 删除headers中的method属性 utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); // 如果config配置了adapter，使用config中配置adapter的替代默认的请求方法 var adapter = config.adapter || defaults.adapter; // 使用adapter方法发起请求（adapter根据浏览器环境或者Node环境会有不同） return adapter(config).then( // 请求正确返回的回调 function onAdapterResolution(response) { // 判断是否以及取消了请求，如果取消了请求抛出以取消 throwIfCancellationRequested(config); // 使用/lib/defaults.js中的transformResponse方法，对服务器返回的数据进行格式化 // 例如，使用JSON.parse对响应正文进行解析 response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, // 请求失败的回调 function onAdapterRejection(reason) { if (!isCancel(reason)) { throwIfCancellationRequested(config); if (reason && reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } } return Promise.reject(reason); } ); }; 再来看看axios是如何实现取消请求的，实现文件在CancelToken.js function CancelToken(executor) { if (typeof executor !== 'function') { throw new TypeError('executor must be a function.'); } // 在 CancelToken 上定义一个 pending 状态的 promise ，将 resolve 回调赋值给外部变量 resolvePromise var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; // 立即执行 传入的 executor函数，将真实的 cancel 方法通过参数传递出去。 // 一旦调用就执行 resolvePromise 即前面的 promise 的 resolve，就更改promise的状态为 resolve。 // 那么xhr中定义的 CancelToken.promise.then方法就会执行, 从而xhr内部会取消请求 executor(function cancel(message) { // 判断请求是否已经取消过，避免多次执行 if (token.reason) { return; } token.reason = new Cancel(message); resolvePromise(token.reason); }); } CancelToken.source = function source() { // source 方法就是返回了一个 CancelToken 实例，与直接使用 new CancelToken 是一样的操作 var cancel; var token = new CancelToken(function executor(c) { cancel = c; }); // 返回创建的 CancelToken 实例以及取消方法 return { token: token, cancel: cancel }; }; 实际上取消请求的操作是在 xhr.js 中也有响应的配合的 if (config.cancelToken) { config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } // 取消请求 request.abort(); reject(cancel); }); } 巧妙的地方在 CancelToken中 executor 函数，通过resolve函数的传递与执行，控制promise的状态 小结 参考文献 https://juejin.cn/post/6856706569263677447#heading-4 https://juejin.cn/post/6844903907500490766 https://github.com/axios/axios 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/bind.html":{"url":"笔记/web前端面试-面试官系列/vue/bind.html","title":"Bind","keywords":"","body":"面试官：双向数据绑定是什么 一、什么是双向绑定 我们先从单向绑定切入单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定举个栗子 当用户填写表单时，View的状态就被更新了，如果此时可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定关系图如下 二、双向绑定的原理是什么 我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成 数据层（Model）：应用的数据及业务逻辑 视图层（View）：应用的展示效果，各类UI组件 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来 而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理 理解ViewModel 它的主要职责就是： 数据变化后更新视图 视图变化后更新数据 当然，它还有两个主要部分组成 监听器（Observer）：对所有数据的属性进行监听 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 三、实现双向绑定 我们还是以Vue为例，先来看看Vue中的双向绑定流程是什么的 new Vue()首先执行初始化，对data执行响应化处理，这个过程发生Observe中 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中 同时定义⼀个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数 由于data的某个key在⼀个视图中可能出现多次，所以每个key都需要⼀个管家Dep来管理多个Watcher 将来data中数据⼀旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数 流程图如下： 实现 先来一个构造函数：执行初始化，对data执行响应化处理 class Vue { constructor(options) { this.$options = options; this.$data = options.data; // 对data选项做响应式处理 observe(this.$data); // 代理data到vm上 proxy(this); // 执行编译 new Compile(options.el, this); } } 对data选项执行响应化具体操作 function observe(obj) { if (typeof obj !== \"object\" || obj == null) { return; } new Observer(obj); } class Observer { constructor(value) { this.value = value; this.walk(value); } walk(obj) { Object.keys(obj).forEach((key) => { defineReactive(obj, key, obj[key]); }); } } 编译Compile 对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 class Compile { constructor(el, vm) { this.$vm = vm; this.$el = document.querySelector(el); // 获取dom if (this.$el) { this.compile(this.$el); } } compile(el) { const childNodes = el.childNodes; Array.from(childNodes).forEach((node) => { // 遍历子元素 if (this.isElement(node)) { // 判断是否为节点 console.log(\"编译元素\" + node.nodeName); } else if (this.isInterpolation(node)) { console.log(\"编译插值⽂本\" + node.textContent); // 判断是否为插值文本 { {}} } if (node.childNodes && node.childNodes.length > 0) { // 判断是否有子元素 this.compile(node); // 对子元素进行递归遍历 } }); } isElement(node) { return node.nodeType == 1; } isInterpolation(node) { return node.nodeType == 3 && /\\{\\{(.*)\\}\\}/.test(node.textContent); } } 依赖收集 视图中会用到data中某key，这称为依赖。同⼀个key可能出现多次，每次都需要收集出来用⼀个Watcher来维护它们，此过程称为依赖收集多个Watcher需要⼀个Dep来管理，需要更新时由Dep统⼀通知 实现思路 defineReactive时为每⼀个key创建⼀个Dep实例 初始化视图时读取某个key，例如name1，创建⼀个watcher1 由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中 当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新 // 负责更新视图 class Watcher { constructor(vm, key, updater) { this.vm = vm this.key = key this.updaterFn = updater // 创建实例时，把当前实例指定到Dep.target静态属性上 Dep.target = this // 读一下key，触发get vm[key] // 置空 Dep.target = null } // 未来执行dom更新函数，由dep调用的 update() { this.updaterFn.call(this.vm, this.vm[this.key]) } } 声明Dep class Dep { constructor() { this.deps = []; // 依赖管理 } addDep(dep) { this.deps.push(dep); } notify() { this.deps.forEach((dep) => dep.update()); } } 创建watcher时触发getter class Watcher { constructor(vm, key, updateFn) { Dep.target = this; this.vm[this.key]; Dep.target = null; } } 依赖收集，创建Dep实例 function defineReactive(obj, key, val) { this.observe(val); const dep = new Dep(); Object.defineProperty(obj, key, { get() { Dep.target && dep.addDep(Dep.target);// Dep.target也就是Watcher实例 return val; }, set(newVal) { if (newVal === val) return; dep.notify(); // 通知dep执行更新方法 }, }); } 参考文献 https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416 https://juejin.cn/post/6844903942254510087#heading-9 面试官VUE系列总进度：3／33 面试官：说说你对vue的理解\\?面试官：说说你对SPA（单页应用）的理解\\? 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/communication.html":{"url":"笔记/web前端面试-面试官系列/vue/communication.html","title":"Communication","keywords":"","body":"面试官：Vue组件之间的通信方式都有哪些？ 一、组件间通信的概念 开始之前，我们把组件间通信这个词进行拆分 组件 通信 都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信 二、组件间通信解决了什么 在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统 二、组件间通信的分类 组件间通信的分类可以分成以下 父子组件之间的通信 兄弟组件之间的通信 祖孙与后代组件之间的通信 非关系组件间之间的通信 关系图: 三、组件间通信的方案 整理vue中8种常规的通信方案 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus $parent 或$root attrs 与 listeners Provide 与 Inject Vuex props传递数据 适用场景：父组件传递数据给子组件 子组件设置props属性，定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值 Children.vue props:{ // 字符串形式 name:String // 接收的类型参数 // 对象形式 age:{ type:Number, // 接收的类型为数值 defaule:18, // 默认值为18 require:true // age属性必须传递 } } Father.vue组件 $emit 触发自定义事件 适用场景：子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取到子组件传递过来的参数 Chilfen.vue this.$emit('add', good) Father.vue ref 父组件在使用子组件的时候设置ref 父组件通过设置子组件ref来获取数据 父组件 this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据 EventBus 使用场景：兄弟组件传值 创建一个中央事件总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件 Bus.js // 创建一个中央时间总线类 class Bus { constructor() { this.callbacks = {}; // 存放事件的名字 } $on(name, fn) { this.callbacks[name] = this.callbacks[name] || []; this.callbacks[name].push(fn); } $emit(name, args) { if (this.callbacks[name]) { this.callbacks[name].forEach((cb) => cb(args)); } } } // main.js Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上 // 另一种方式 Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能 Children1.vue this.$bus.$emit('foo') Children2.vue this.$bus.$on('foo', this.handle) $parent 或$ root 通过共同祖辈$parent或者$root搭建通信桥连 兄弟组件 this.$parent.on('add',this.add) 另一个兄弟组件 this.$parent.emit('add') $attrs 与$ listeners 适用场景：祖先传递数据给子孙 设置批量向下传属性$attrs和 $listeners 包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。 可以通过 v-bind=\"$attrs\" 传⼊内部组件 // child：并未在props中声明foo { {$attrs.foo}} // parent // 给Grandson隔代传值，communication/index.vue // Child2做展开 // Grandson使⽤ { {msg}} provide 与 inject 在祖先组件定义provide属性，返回传递的值 在后代组件通过inject接收组件传递过来的值 祖先组件 provide(){ return { foo:'foo' } } 后代组件 inject:['foo'] // 获取到祖先组件传递过来的值 vuex 适用场景: 复杂关系的组件数据传递 Vuex作用相当于一个用来存储共享变量的容器 state用来存放共享变量的地方 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值 mutations用来存放修改state的方法。 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作 小结 父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject 复杂关系的组件数据传递可以通过vuex存放共享的变量 参考文献 https://juejin.cn/post/6844903990052782094#heading-0 https://zh.wikipedia.org/wiki/\\%E9\\%80\\%9A\\%E4\\%BF\\%A1 https://vue3js.cn/docs/zh 面试官VUE系列总进度：5／33 面试官：说说你对vue的理解\\? 面试官：说说你对SPA（单页应用）的理解\\? 面试官：说说你对双向绑定的理解\\? 面试官：说说你对Vue生命周期的理解\\? 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/components_plugin.html":{"url":"笔记/web前端面试-面试官系列/vue/components_plugin.html","title":"Components Plugin","keywords":"","body":"面试官：Vue中组件和插件有什么区别？ 一、组件是什么 回顾以前对组件的定义： 组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件 组件的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 二、插件是什么 插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者属性。如: vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router 三、两者的区别 两者的区别主要表现在以下几个方面： 编写形式 注册形式 使用场景 编写形式 编写组件 编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件 vue文件标准格式 export default{ ... } 我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上 // 组件显示的内容 component! Vue.component('componentA',{ template: '#testComponent' template: `component` // 组件内容少可以通过这种形式 }) 编写插件 vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象 MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或 property Vue.myGlobalMethod = function () { // 逻辑... } // 2. 添加全局资源 Vue.directive('my-directive', { bind (el, binding, vnode, oldVnode) { // 逻辑... } ... }) // 3. 注入组件选项 Vue.mixin({ created: function () { // 逻辑... } ... }) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... } } 注册形式 组件注册 vue组件注册主要分为全局注册与局部注册 全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项 Vue.component('my-component-name', { /* ... */ }) 局部注册只需在用到的地方通过components属性注册一个组件 const component1 = {...} // 定义一个组件 export default { components:{ component1 // 局部注册 } } 插件注册 插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项 Vue.use(插件名字,{ /* ... */} ) 注意的是： 注册插件的时候，需要在调用 new Vue() 启动应用之前完成 Vue.use会自动阻止多次注册相同插件，只会注册一次 使用场景 具体的其实在插件是什么章节已经表述了，这里在总结一下 组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue 插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身 简单来说，插件就是指对Vue的功能的增强或补充 参考文献 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/cors.html":{"url":"笔记/web前端面试-面试官系列/vue/cors.html","title":"Cors","keywords":"","body":"面试官：Vue项目中你是如何解决跨域的呢？ 一、跨域是什么 跨域本质是浏览器基于同源策略的一种安全手段 同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能 所谓同源（即指在同一个域）具有以下三个相同点 协议相同（protocol） 主机相同（host） 端口相同（port） 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域 一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。 二、如何解决 解决跨域的方法有很多，下面列举了三种： JSONP CORS Proxy 而在vue项目中，我们主要针对CORS或Proxy这两种方案进行展开 CORS CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应 CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源 只要后端实现了 CORS，就实现了跨域 以koa框架举例 添加中间件，直接设置Access-Control-Allow-Origin响应头 app.use(async (ctx, next)=> { ctx.set('Access-Control-Allow-Origin', '*'); ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); if (ctx.method == 'OPTIONS') { ctx.body = 200; } else { await next(); } }) ps: Access-Control-Allow-Origin 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将Access-Control-Allow-Origin 值设为我们目标host Proxy 代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击 方案一 如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象 通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域 在vue.config.js文件，新增以下代码 amodule.exports = { devServer: { host: '127.0.0.1', port: 8084, open: true,// vue项目启动时自动打开浏览器 proxy: { '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的 target: \"http://xxx.xxx.xx.xx:8080\", //目标地址，一般是指后台服务器地址 changeOrigin: true, //是否跨域 pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用\"\"代替 '^/api': \"\" } } } } } 通过axios发送请求中，配置请求的根路径 axios.defaults.baseURL = '/api' 方案二 此外，还可通过服务端实现代理请求转发 以express框架为例 var express = require('express'); const proxy = require('http-proxy-middleware') const app = express() app.use(express.static(__dirname + '/')) app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false })); module.exports = app 方案三 通过配置nginx实现代理 server { listen 80; # server_name www.josephxia.com; location / { root /var/www/html; index index.html index.htm; try_files $uri $uri/ /index.html; } location /api { proxy_pass http://127.0.0.1:3000; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/data.html":{"url":"笔记/web前端面试-面试官系列/vue/data.html","title":"Data","keywords":"","body":"面试官：为什么data属性是一个函数而不是一个对象？ 一、实例和组件定义data的区别 vue实例的时候定义data属性既可以是一个对象，也可以是一个函数 const app = new Vue({ el:\"#app\", // 对象格式 data:{ foo:\"foo\" }, // 函数格式 data(){ return { foo:\"foo\" } } }) 组件中定义data属性，只能是一个函数 如果为组件data直接定义为一个对象 Vue.component('component1',{ template:`组件`, data:{ foo:\"foo\" } }) 则会得到警告信息 警告说明：返回的data应该是一个函数在每一个组件实例中 二、组件data定义函数与对象的区别 上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？ 在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例 这里我们模仿组件构造函数，定义data属性，采用对象的形式 function Component(){ } Component.prototype.data = { count : 0 } 创建两个组件实例 const componentA = new Component() const componentB = new Component() 修改componentA组件data属性的值，componentB中的值也发生了改变 console.log(componentB.data.count) // 0 componentA.data.count = 1 console.log(componentB.data.count) // 1 产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响 如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同） function Component(){ this.data = this.data() } Component.prototype.data = function (){ return { count : 0 } } 修改componentA组件data属性的值，componentB中的值不受影响 console.log(componentB.data.count) // 0 componentA.data.count = 1 console.log(componentB.data.count) // 0 vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染 三、原理分析 首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象 源码位置：/vue-dev/src/core/instance/state.js function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} ... } data既能是object也能是function，那为什么还会出现上文警告呢？ 别急，继续看下文 组件在创建的时候，会进行选项的合并 源码位置：/vue-dev/src/core/util/options.js 自定义组件会进入mergeOptions进行选项合并 Vue.prototype._init = function (options?: Object) { ... // merge options if (options && options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } ... } 定义data会进行数据校验 源码位置：/vue-dev/src/core/instance/init.js 这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示 strats.data = function ( parentVal: any, childVal: any, vm?: Component ): ?Function { if (!vm) { if (childVal && typeof childVal !== \"function\") { process.env.NODE_ENV !== \"production\" && warn( 'The \"data\" option should be a function ' + \"that returns a per-instance value in component \" + \"definitions.\", vm ); return parentVal; } return mergeDataOrFn(parentVal, childVal); } return mergeDataOrFn(parentVal, childVal, vm); }; 四、结论 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/data_object_add_attrs.html":{"url":"笔记/web前端面试-面试官系列/vue/data_object_add_attrs.html","title":"Data Object Add Attrs","keywords":"","body":"面试官：动态给vue的data添加一个新的属性时会发生什么？怎样解决？ 一、直接添加属性的问题 我们从一个例子开始 定义一个p标签，通过v-for指令进行遍历 然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行 { { value }} 动态添加新属性 实例化一个vue实例，定义data属性和methods方法 const app = new Vue({ el:\"#app\", data:()=>{ item:{ oldProperty:\"旧属性\" } }, methods:{ addProperty(){ this.items.newProperty = \"新属性\" // 为items添加新属性 console.log(this.items) // 输出带有newProperty的items } } }) 点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新 二、原理分析 为什么产生上面的情况呢？ 下面来分析一下 vue2是用过Object.defineProperty实现数据响应式 const obj = {} Object.defineProperty(obj, 'foo', { get() { console.log(`get foo:${val}`); return val }, set(newVal) { if (newVal !== val) { console.log(`set foo:${newVal}`); val = newVal } } }) } 当我们访问foo属性或者设置foo值的时候都能够触发setter与getter obj.foo obj.foo = 'new' 但是我们为obj添加新属性的时候，却无法触发事件属性的拦截 obj.bar = '新属性' 原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据 三、解决方案 Vue 不允许在已经创建的实例上动态添加新的响应式属性 若想实现数据与视图同步更新，可采取下面三种解决方案： Vue.set() Object.assign() $forcecUpdated() Vue.set() Vue.set( target, propertyName/index, value ) 参数 {Object | Array} target {string | number} propertyName/index {any} value 返回值：设置的值 通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新 关于Vue.set源码（省略了很多与本节不相关的代码） 源码位置：src\\core\\observer\\index.js function set (target: Array | Object, key: any, val: any): any { ... defineReactive(ob.value, key, val) ob.dep.notify() return val } 这里无非再次调用defineReactive方法，实现新增属性的响应式 关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截 大致代码如下： function defineReactive(obj, key, val) { Object.defineProperty(obj, key, { get() { console.log(`get ${key}:${val}`); return val }, set(newVal) { if (newVal !== val) { console.log(`set ${key}:${newVal}`); val = newVal } } }) } Object.assign() 直接使用Object.assign()添加到对象的新属性不会触发更新 应创建一个新的对象，合并原对象和混入对象的属性 this.someObject = Object.assign({},this.someObject,{newProperty1:1,newProperty2:2 ...}) $forceUpdate 如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事 $forceUpdate迫使Vue 实例重新渲染 PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 小结 如果为对象添加少量的新属性，可以直接采用Vue.set() 如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象 如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议) PS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式 参考文献 https://cn.vuejs.org/v2/api/#Vue-set https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/diff.html":{"url":"笔记/web前端面试-面试官系列/vue/diff.html","title":"Diff","keywords":"","body":"面试官：你了解vue的diff算法吗？说说看 一、是什么 diff 算法是一种通过同层的树节点进行比较的高效算法 其有两个特点： 比较只会在同层级进行, 不会跨层级比较 在diff比较的过程中，循环从两边向中间比较 diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 二、比较方式 diff整体策略为：深度优先，同层比较 比较只会在同层级进行, 不会跨层级比较 比较的过程中，循环从两边向中间收拢 下面举个vue通过diff算法更新的例子： 新旧VNode节点如下图所示： 第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C 第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E 第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的startIndex 移动到了 B 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex移动到了 C，新节点的 startIndex 移动到了 F 新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面 三、原理分析 当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 源码位置：src/core/vdom/patch.js function patch(oldVnode, vnode, hydrating, removeOnly) { if (isUndef(vnode)) { // 没有新节点，直接执行destory钩子函数 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { isInitialPatch = true createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素 } else { const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement && sameVnode(oldVnode, vnode)) { // 判断旧节点和新节点自身一样，一致执行patchVnode patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) } else { // 否则直接销毁及旧节点，根据新节点生成dom元素 if (isRealElement) { if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } } oldVnode = emptyNodeAt(oldVnode) } return vnode.elm } } } patch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断： 没有新节点，直接触发旧节点的destory钩子 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点 下面主要讲的是patchVnode部分 function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) { // 如果新旧节点一致，什么都不做 if (oldVnode === vnode) { return } // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化 const elm = vnode.elm = oldVnode.elm // 异步占位符 if (isTrue(oldVnode.isAsyncPlaceholder)) { if (isDef(vnode.asyncFactory.resolved)) { hydrate(oldVnode.elm, vnode, insertedVnodeQueue) } else { vnode.isAsyncPlaceholder = true } return } // 如果新旧都是静态节点，并且具有相同的key // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上 // 也不用再有其他操作 if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { vnode.componentInstance = oldVnode.componentInstance return } let i const data = vnode.data if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) { i(oldVnode, vnode) } const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) && isPatchable(vnode)) { for (i = 0; i patchVnode主要做了几个判断： 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容 新节点和旧节点如果都有子节点，则处理比较更新子节点 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除 子节点不完全一致，则调用updateChildren function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) { let oldStartIdx = 0 // 旧头索引 let newStartIdx = 0 // 新头索引 let oldEndIdx = oldCh.length - 1 // 旧尾索引 let newEndIdx = newCh.length - 1 // 新尾索引 let oldStartVnode = oldCh[0] // oldVnode的第一个child let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child let newStartVnode = newCh[0] // newVnode的第一个child let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束 while (oldStartIdx while循环主要处理了以下五种情景： 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况： 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode，同时将这个真实 dom移动到 oldStartVnode 对应的真实 dom 的前面 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置 小结 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁 通过isSameVnode进行判断，相同则调用patchVnode方法 patchVnode做了以下操作： 找到对应的真实dom，称为el 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点 如果oldVnode有子节点而VNode没有，则删除el子节点 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点 updateChildren主要做了以下操作： 设置新旧VNode的头尾指针 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作 参考文献 https://juejin.cn/post/6881907432541552648#heading-1 https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/directive.html":{"url":"笔记/web前端面试-面试官系列/vue/directive.html","title":"Directive","keywords":"","body":"面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？ 一、什么是指令 开始之前我们先学习一下指令系统这个词 指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力 在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统 我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 指令使用的几种方式： //会实例化一个指令，但这个指令没有参数 `v-xxx` // -- 将值传到指令中 `v-xxx=\"value\"` // -- 将字符串传入到指令中，如`v-html=\"'内容'\"` `v-xxx=\"'string'\"` // -- 传参数（`arg`），如`v-bind:class=\"className\"` `v-xxx:arg=\"value\"` // -- 使用修饰符（`modifier`） `v-xxx:arg.modifier=\"value\"` 二、如何实现 注册一个自定义指令有全局注册与局部注册 全局注册主要是通过Vue.directive方法进行注册 Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 } }) 局部注册通过在组件options选项中设置directive属性 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 } } } 然后你可以在模板中任何元素上使用新的 v-focus property，如下： 自定义指令也像组件那样存在钩子函数： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中) update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用 所有的钩子函数的参数都有以下： el：指令所绑定的元素，可以用来直接操作 DOM binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true } vnode：Vue 编译生成的虚拟节点 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行 举个例子： Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // \"white\" console.log(binding.value.text) // \"hello!\" }) 三、应用场景 使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例： 防抖 图片懒加载 一键 Copy的功能 输入框防抖 防抖这种情况设置一个v-throttle自定义指令来实现 举个例子： // 1.设置v-throttle自定义指令 Vue.directive('throttle', { bind: (el, binding) => { let throttleTime = binding.value; // 防抖时间 if (!throttleTime) { // 用户若不设置防抖时间，则默认2s throttleTime = 2000; } let cbFun; el.addEventListener('click', event => { if (!cbFun) { // 第一次执行 cbFun = setTimeout(() => { cbFun = null; }, throttleTime); } else { event && event.stopImmediatePropagation(); } }, true); }, }); // 2.为button标签设置v-throttle自定义指令 提交 图片懒加载 设置一个v-lazy自定义指令完成图片懒加载 const LazyLoad = { // install方法 install(Vue,options){ // 代替图片的loading图 let defaultSrc = options.default; Vue.directive('lazy',{ bind(el,binding){ LazyLoad.init(el,binding.value,defaultSrc); }, inserted(el){ // 兼容处理 if('IntersectionObserver' in window){ LazyLoad.observe(el); }else{ LazyLoad.listenerScroll(el); } }, }) }, // 初始化 init(el,val,def){ // data-src 储存真实src el.setAttribute('data-src',val); // 设置src为loading图 el.setAttribute('src',def); }, // 利用IntersectionObserver监听el observe(el){ let io = new IntersectionObserver(entries => { let realSrc = el.dataset.src; if(entries[0].isIntersecting){ if(realSrc){ el.src = realSrc; el.removeAttribute('data-src'); } } }); io.observe(el); }, // 监听scroll事件 listenerScroll(el){ let handler = LazyLoad.throttle(LazyLoad.load,300); LazyLoad.load(el); window.addEventListener('scroll',() => { handler(el); }); }, // 加载真实图片 load(el){ let windowHeight = document.documentElement.clientHeight let elTop = el.getBoundingClientRect().top; let elBtm = el.getBoundingClientRect().bottom; let realSrc = el.dataset.src; if(elTop - windowHeight 0){ if(realSrc){ el.src = realSrc; el.removeAttribute('data-src'); } } }, // 节流 throttle(fn,delay){ let timer; let prevTime; return function(...args){ let currTime = Date.now(); let context = this; if(!prevTime) prevTime = currTime; clearTimeout(timer); if(currTime - prevTime > delay){ prevTime = currTime; fn.apply(context,args); clearTimeout(timer); return; } timer = setTimeout(function(){ prevTime = Date.now(); timer = null; fn.apply(context,args); },delay); } } } export default LazyLoad; 一键 Copy的功能 import { Message } from 'ant-design-vue'; const vCopy = { // /* bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置 el: 作用的 dom 对象 value: 传给指令的值，也就是我们要 copy 的值 */ bind(el, { value }) { el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到 el.handler = () => { if (!el.$value) { // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意 Message.warning('无复制内容'); return; } // 动态创建 textarea 标签 const textarea = document.createElement('textarea'); // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = 'readonly'; textarea.style.position = 'absolute'; textarea.style.left = '-9999px'; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value; // 将 textarea 插入到 body 中 document.body.appendChild(textarea); // 选中值并复制 textarea.select(); // textarea.setSelectionRange(0, textarea.value.length); const result = document.execCommand('Copy'); if (result) { Message.success('复制成功'); } document.body.removeChild(textarea); }; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener('click', el.handler); }, // 当传进来的值更新的时候触发 componentUpdated(el, { value }) { el.$value = value; }, // 指令与元素解绑的时候，移除事件绑定 unbind(el) { el.removeEventListener('click', el.handler); }, }; export default vCopy; 关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景 参考文献 https://vue3js.cn/docs/zh https://juejin.cn/post/6844904197448531975#heading-5 https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/error.html":{"url":"笔记/web前端面试-面试官系列/vue/error.html","title":"Error","keywords":"","body":"面试官：你是怎么处理vue项目中的错误的？ 一、错误类型 任何一个框架，对于错误的处理都是一种必备的能力 在Vue 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。 主要的错误来源包括： 后端接口错误 代码中本身逻辑错误 二、如何处理 后端接口错误 通过axios的interceptor实现网络请求的response先进行一层拦截 apiClient.interceptors.response.use( response => { return response; }, error => { if (error.response.status == 401) { router.push({ name: \"Login\" }); } else { message.error(\"出错了\"); return Promise.reject(error); } } ); 代码逻辑问题 全局设置错误处理 设置全局错误处理函数 Vue.config.errorHandler = function (err, vm, info) { // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用 } errorHandler指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例 不过值得注意的是，在不同Vue 版本中，该全局 API 作用的范围会有所不同： 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了 从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 生命周期钩子 errorCaptured是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用 基本类型 (err: Error, vm: Component, info: string) => ?boolean 此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播 参考官网，错误传播规则如下： 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler 下面来看个例子 定义一个父组件cat Vue.component('cat', { template:` Cat: `, props:{ name:{ required:true, type:String } }, errorCaptured(err,vm,info) { console.log(`cat EC: ${err.toString()}\\ninfo: ${info}`); return false; } }); 定义一个子组件kitten，其中dontexist()并没有定义，存在错误 Vue.component('kitten', { template:'Kitten: { { dontexist() }}', props:{ name:{ required:true, type:String } } }); 页面中使用组件 在父组件的errorCaptured则能够捕获到信息 cat EC: TypeError: dontexist is not a function info: render 三、源码分析 异常处理源码 源码位置：/src/core/util/error.js // Vue 全局配置,也就是上面的Vue.config import config from '../config' import { warn } from './debug' // 判断环境 import { inBrowser, inWeex } from './env' // 判断是否是Promise，通过val.then === 'function' && val.catch === 'function', val ！=== null && val !== undefined import { isPromise } from 'shared/util' // 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering // 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题 import { pushTarget, popTarget } from '../observer/dep' export function handleError (err: Error, vm: any, info: string) { // Deactivate deps tracking while processing error handler to avoid possible infinite rendering. pushTarget() try { // vm指当前报错的组件实例 if (vm) { let cur = vm // 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。 // 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法 while ((cur = cur.$parent)) { const hooks = cur.$options.errorCaptured // 判断是否存在errorCaptured钩子函数 if (hooks) { // 选项合并的策略，钩子函数会被保存在一个数组中 for (let i = 0; i handleError(e, vm, info + ` (Promise/async)`)) // avoid catch triggering multiple times when nested calls // 避免嵌套调用时catch多次的触发 res._handled = true } } catch (e) { // 处理执行错误 handleError(e, vm, info) } return res } //全局错误处理 function globalHandleError (err, vm, info) { // 获取全局配置，判断是否设置处理函数，默认undefined // 已配置 if (config.errorHandler) { // try{}catch{} 住全局错误处理函数 try { // 执行设置的全局错误处理函数，handle error 想干啥就干啥💗 return config.errorHandler.call(null, err, vm, info) } catch (e) { // 如果开发者在errorHandler函数中手动抛出同样错误信息throw err // 判断err信息是否相等，避免log两次 // 如果抛出新的错误信息throw err Error('你好毒')，将会一起log输出 if (e !== err) { logError(e, null, 'config.errorHandler') } } } // 未配置常规log输出 logError(err, vm, info) } // 错误输出函数 function logError (err, vm, info) { if (process.env.NODE_ENV !== 'production') { warn(`Error in ${info}: \"${err.toString()}\"`, vm) } /* istanbul ignore else */ if ((inBrowser || inWeex) && typeof console !== 'undefined') { console.error(err) } else { throw err } } 小结 handleError在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法，在遍历调用完所有 errorCaptured 方法或 errorCaptured 方法有报错时，调用 globalHandleError 方法 globalHandleError调用全局的 errorHandler 方法，再通过logError判断环境输出错误信息 invokeWithErrorHandling更好的处理异步错误信息 logError判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误 参考文献 https://juejin.cn/post/6844904096936230925 https://segmentfault.com/a/1190000018606181 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/filter.html":{"url":"笔记/web前端面试-面试官系列/vue/filter.html","title":"Filter","keywords":"","body":"面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？ 一、是什么 过滤器（filter）是输送介质管道上不可缺少的一种装置 大白话，就是把一些不必要的东西过滤掉 过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数 Vue 允许你自定义过滤器，可被用于一些常见的文本格式化 ps: Vue3中已废弃filter 二、如何用 vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示： { { message | capitalize }} 定义filter 在组件的选项中定义本地的过滤器 filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } 定义全局过滤器： Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) new Vue({ // ... }) 注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数 过滤器可以串联： { { message | filterA | filterB }} 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript函数，因此可以接收参数： { { message | filterA('arg1', arg2) }} 这里，filterA 被定义为接收三个参数的过滤器函数。 其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数 举个例子： { { msg | msgFormat('疯狂','--')}} // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function(msg, arg, arg2) { // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg+arg2) }) 小结： 部过滤器优先于全局过滤器被调用 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右 三、应用场景 平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等 比如我们要实现将30000 => 30,000，这时候我们就需要使用过滤器 Vue.filter('toThousandFilter', function (value) { if (!value) return '' value = value.toString() return .replace(str.indexOf('.') > -1 ? /(\\d)(?=(\\d{3})+\\.)/g : /(\\d)(?=(?:\\d{3})+$)/g, '$1,') }) 四、原理分析 使用过滤器 { { message | capitalize }} 在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲 _s(_f('filterFormat')(message)) 首先分析一下_f： _f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回 // 变为 this.$options.filters['filterFormat'](message) // message为参数 关于resolveFilter import { indentity,resolveAsset } from 'core/util/index' export function resolveFilter(id){ return resolveAsset(this.$options,'filters',id,true) || identity } 内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器； resolveAsset的代码如下： export function resolveAsset(options,type,id,warnMissing){ // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 'filters',实际这个函数还可以拿到其他很多东西 if(typeof id !== 'string'){ // 判断传递的过滤器id 是不是字符串，不是则直接返回 return } const assets = options[type] // 将我们注册的所有过滤器保存在变量中 // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配 if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器 // 没有找到，代码继续执行 const camelizedId = camelize(id) // 万一你是驼峰的呢 if(hasOwn(assets,camelizedId)) return assets[camelizedId] // 没找到，继续执行 const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢 if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId] // 如果还是没找到，则检查原型链(即访问属性) const result = assets[id] || assets[camelizedId] || assets[PascalCaseId] // 如果依然没找到，则在非生产环境的控制台打印警告 if(process.env.NODE_ENV !== 'production' && warnMissing && !result){ warn('Failed to resolve ' + type.slice(0,-1) + ': ' + id, options) } // 无论是否找到，都返回查找结果 return result } 下面再来分析一下_s： _s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的text属性中，渲染到视图中 function toString(value){ return value == null ? '' : typeof value === 'object' ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距 : String(value) } 最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式 function parseFilters (filter) { let filters = filter.split('|') let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组 let i if (filters) { for(i = 0;i 小结： 在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数） 编译后通过调用resolveFilter函数找到对应过滤器并返回结果 执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图 参考文献 https://cn.vuejs.org/v2/guide/filters.html#ad https://blog.csdn.net/weixin_42724176/article/details/105546684 https://vue3js.cn 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/first_page_time.html":{"url":"笔记/web前端面试-面试官系列/vue/first_page_time.html","title":"First Page Time","keywords":"","body":"面试官：SPA首屏加载速度慢的怎么解决？ 一、什么是首屏加载 首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容 首屏加载可以说是用户体验中最重要的环节 关于计算首屏时间 利用performance.timing提供的数据： 通过DOMContentLoad或者performance来计算出首屏时间 // 方案一： document.addEventListener('DOMContentLoaded', (event) => { console.log('first contentful painting'); }); // 方案二： performance.getEntriesByName(\"first-contentful-paint\")[0].startTime // performance.getEntriesByName(\"first-contentful-paint\")[0] // 会返回一个 PerformancePaintTiming的实例，结构如下： { name: \"first-contentful-paint\", entryType: \"paint\", startTime: 507.80000002123415, duration: 0, }; 二、加载慢的原因 在页面渲染的过程，导致加载速度慢的因素可能如下： 网络延时问题 资源文件体积是否过大 资源是否重复发送请求去加载了 加载脚本的时候，渲染内容堵塞了 三、解决方案 常见的几种SPA首屏优化方式 减小入口文件积 静态资源本地缓存 UI框架按需加载 图片资源的压缩 组件重复打包 开启GZip压缩 使用SSR 减小入口文件体积 常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加 在vue-router配置路由的时候，采用动态加载路由的形式 routes:[ path: 'Blogs', name: 'ShowBlogs', component: () => import('./components/ShowBlogs.vue') ] 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件 静态资源本地缓存 后端返回资源问题： 采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头 采用Service Worker离线缓存 前端合理利用localStorage UI框架按需加载 在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库 import ElementUI from 'element-ui' Vue.use(ElementUI) 但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用 import { Button, Input, Pagination, Table, TableColumn, MessageBox } from 'element-ui'; Vue.use(Button) Vue.use(Input) Vue.use(Pagination) 组件重复打包 假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载 解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置 minChunks: 3 minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件 图片资源的压缩 图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素 对于所有的图片资源，我们可以进行适当的压缩 对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。 开启GZip压缩 拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin cnmp i compression-webpack-plugin -D 在vue.congig.js中引入并修改webpack配置 const CompressionPlugin = require('compression-webpack-plugin') configureWebpack: (config) => { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = 'production' return { plugins: [new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过10k的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 })] } } 在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用 const compression = require('compression') app.use(compression()) // 在其他中间件使用之前调用 使用SSR SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器 从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染 小结： 减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化 下图是更为全面的首屏优化的方案 大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化 参考文献 https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session https://www.chengrang.com/how-browsers-work.html https://juejin.cn/post/6844904185264095246 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/if_for.html":{"url":"笔记/web前端面试-面试官系列/vue/if_for.html","title":"If For","keywords":"","body":"面试官：v-if和v-for的优先级是什么？ 一、作用 v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名 在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化 两者在用法上 { { item.label }} 二、优先级 v-if与v-for都是vue模板系统中的指令 在vue模板编译的时候，会将指令系统转化成可执行的render函数 示例 编写一个p标签，同时使用v-if与 v-for { { item.title }} 创建vue实例，存放isShow与items数据 const app = new Vue({ el: \"#app\", data() { return { items: [ { title: \"foo\" }, { title: \"baz\" }] } }, computed: { isShow() { return this.items && this.items.length > 0 } } }) 模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数 ƒ anonymous() { with (this) { return _c('div', { attrs: { \"id\": \"app\" } }, _l((items), function (item) { return (isShow) ? _c('p', [_v(\"\\n\" + _s(item.title) + \"\\n\")]) : _e() }), 0) } } _l是vue的列表渲染函数，函数内部都会进行一次if判断 初步得到结论：v-for优先级是比v-if高 再将v-for与v-if置于不同标签 { {item.title}} 再输出下render函数 ƒ anonymous() { with(this){return _c('div',{attrs:{\"id\":\"app\"}}, [(isShow)?[_v(\"\\n\"), _l((items),function(item){return _c('p',[_v(_s(item.title))])})]:_e()],2)} } 这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染 我们再在查看下vue源码 源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js export function genElement (el: ASTElement, state: CodegenState): string { if (el.parent) { el.pre = el.pre || el.parent.pre } if (el.staticRoot && !el.staticProcessed) { return genStatic(el, state) } else if (el.once && !el.onceProcessed) { return genOnce(el, state) } else if (el.for && !el.forProcessed) { return genFor(el, state) } else if (el.if && !el.ifProcessed) { return genIf(el, state) } else if (el.tag === 'template' && !el.slotTarget && !state.pre) { return genChildren(el, state) || 'void 0' } else if (el.tag === 'slot') { return genSlot(el, state) } else { // component or element ... } 在进行if判断的时候，v-for是比v-if先进行判断 最终结论：v-for优先级比v-if高 三、注意事项 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） 如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项 computed: { items: function() { return this.list.filter(function (item) { return item.isShow }) } } 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/keepalive.html":{"url":"笔记/web前端面试-面试官系列/vue/keepalive.html","title":"Keepalive","keywords":"","body":"面试官：说说你对keep-alive的理解是什么？ 一、Keep-alive 是什么 keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们 keep-alive可以设置以下props属性： include - 字符串或正则表达式。只有名称匹配的组件会被缓存 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存 max - 数字。最多可以缓存多少组件实例 关于keep-alive的基本用法： 使用includes和exclude： 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配 设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）： 首次进入组件时：beforeRouteEnter > beforeCreate > created> mounted > activated > ... ... > beforeRouteLeave > deactivated 再次进入组件时：beforeRouteEnter >activated > ... ... > beforeRouteLeave > deactivated 二、使用场景 使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive 举个栗子: 当我们从首页–>列表页–>商详页–>再返回，这时候列表页应该是需要keep-alive 从首页–>列表页–>商详页–>返回到列表页(需要缓存)–>返回到首页(需要缓存)–>再次进入列表页(不需要缓存)，这时候可以按需来控制页面的keep-alive 在路由中设置keepAlive属性判断是否需要缓存 { path: 'list', name: 'itemList', // 列表页 component (resolve) { require(['@/pages/item/list'], resolve) }, meta: { keepAlive: true, title: '列表页' } } 使用 三、原理分析 keep-alive是vue中内置的一个组件 源码位置：src/core/components/keep-alive.js export default { name: 'keep-alive', abstract: true, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, created () { this.cache = Object.create(null) this.keys = [] }, destroyed () { for (const key in this.cache) { pruneCacheEntry(this.cache, key, this.keys) } }, mounted () { this.$watch('include', val => { pruneCache(this, name => matches(val, name)) }) this.$watch('exclude', val => { pruneCache(this, name => !matches(val, name)) }) }, render() { /* 获取默认插槽中的第一个组件节点 */ const slot = this.$slots.default const vnode = getFirstComponentChild(slot) /* 获取该组件节点的componentOptions */ const componentOptions = vnode && vnode.componentOptions if (componentOptions) { /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */ const name = getComponentName(componentOptions) const { include, exclude } = this /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */ if ( (include && (!name || !matches(include, name))) || // excluded (exclude && name && matches(exclude, name)) ) { return vnode } const { cache, keys } = this /* 获取组件的key值 */ const key = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key /* 拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */ if (cache[key]) { vnode.componentInstance = cache[key].componentInstance // make current key freshest remove(keys, key) keys.push(key) } /* 如果没有命中缓存，则将其设置进缓存 */ else { cache[key] = vnode keys.push(key) // prune oldest entry /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */ if (this.max && keys.length > parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode) } } vnode.data.keepAlive = true } return vnode || (slot && slot[0]) } } 可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数 this.cache是一个对象，用来存储需要缓存的组件，它将以如下形式存储： this.cache = { 'key1':'组件1', 'key2':'组件2', // ... } 在组件销毁的时候执行pruneCacheEntry函数 function pruneCacheEntry ( cache: VNodeCache, key: string, keys: Array, current?: VNode ) { const cached = cache[key] /* 判断当前没有处于被渲染状态的组件，将其销毁*/ if (cached && (!current || cached.tag !== current.tag)) { cached.componentInstance.$destroy() } cache[key] = null remove(keys, key) } 在mounted钩子函数中观测 include 和 exclude 的变化，如下： mounted () { this.$watch('include', val => { pruneCache(this, name => matches(val, name)) }) this.$watch('exclude', val => { pruneCache(this, name => !matches(val, name)) }) } 如果include 或exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下： function pruneCache (keepAliveInstance, filter) { const { cache, keys, _vnode } = keepAliveInstance for (const key in cache) { const cachedNode = cache[key] if (cachedNode) { const name = getComponentName(cachedNode.componentOptions) if (name && !filter(name)) { pruneCacheEntry(cache, key, keys, _vnode) } } } } 在该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用pruneCacheEntry函数将其从this.cache对象剔除即可 关于keep-alive的最强大缓存功能是在render函数中实现 首先获取组件的key值： const key = vnode.key == null? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key 拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下： /* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */ if (cache[key]) { vnode.componentInstance = cache[key].componentInstance /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */ remove(keys, key) keys.push(key) } 直接从缓存中拿 vnode 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在this.keys中最后一个 this.cache对象中没有该key值的情况，如下： /* 如果没有命中缓存，则将其设置进缓存 */ else { cache[key] = vnode keys.push(key) /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */ if (this.max && keys.length > parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode) } } 表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache中，并且把key存入this.keys中 此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值this.max，如果超过了，则把第一个缓存组件删掉 四、思考题：缓存后如何获取数据 解决方案可以有以下两种： beforeRouteEnter actived beforeRouteEnter 每次组件渲染的时候，都会执行beforeRouteEnter beforeRouteEnter(to, from, next){ next(vm=>{ console.log(vm) // 每次进入路由执行 vm.getData() // 获取数据 }) }, actived 在keep-alive缓存的组件被激活的时候，都会执行actived钩子 activated(){ this.getData() // 获取数据 }, 注意：服务器端渲染期间avtived不被调用 参考文献 https://www.cnblogs.com/dhui/p/13589401.html https://www.cnblogs.com/wangjiachen666/p/11497200.html https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/key.html":{"url":"笔记/web前端面试-面试官系列/vue/key.html","title":"Key","keywords":"","body":"面试官：你知道vue中key的原理吗？说说你对它的理解 一、Key是什么 开始之前，我们先还原两个实际工作场景 当我们在使用v-for时，需要给单元加上key ... 用+new Date()生成的时间戳作为key，手动强制触发重新渲染 那么这背后的逻辑是什么，key的作用又是什么？ 一句话来讲 key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点 场景背后的逻辑 当我们在使用v-for时，需要给单元加上key 如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。 如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed 用+new Date()生成的时间戳作为key，手动强制触发重新渲染 当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染 二、设置key与不设置key区别 举个例子： 创建一个实例，2秒后往items数组插入数据 { {item}} // 创建实例 const app = new Vue({ el: '#demo', data: { items: ['a', 'b', 'c', 'd', 'e'] }, mounted () { setTimeout(() => { this.items.splice(2, 0, 'f') // }, 2000); }, }); 在不使用key的情况，vue会进行这样的操作： 分析下整体流程： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作 比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作 比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作 循环结束，将E插入到DOM中 一共发生了3次更新，1次插入操作 在使用key的情况：vue会进行这样的操作： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，不相同类型的节点 比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作 循环结束，将F插入到C之前 一共发生了0次更新，1次插入操作 通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率 设置key值一定能提高diff效率吗？ 其实不然，文档中也明确表示 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升 三、原理分析 源码位置：core/vdom/patch.js 这里判断是否为同一个key，首先判断的是key值是否相等如果没有设置key，那么key为undefined，这时候undefined是恒等于undefined function sameVnode (a, b) { return ( a.key === b.key && ( ( a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error) ) ) ) } updateChildren方法中会对新旧vnode进行diff，然后将比对出的结果用来更新真实的DOM function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) { ... while (oldStartIdx 参考文献 https://juejin.cn/post/6844903826693029895 https://juejin.cn/post/6844903985397104648 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/lifecycle.html":{"url":"笔记/web前端面试-面试官系列/vue/lifecycle.html","title":"Lifecycle","keywords":"","body":"面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？ 一、生命周期是什么 生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos()) 二、生命周期有哪些 Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期 生命周期 描述 beforeCreate 组件实例被创建之初 created 组件实例已经完全创建 beforeMount 组件挂载之前 mounted 组件挂载到实例上去之后 beforeUpdate 组件数据发生变化，更新之前 updated 组件数据更新之后 beforeDestroy 组件实例销毁之前 destroyed 组件实例销毁之后 activated keep-alive 缓存的组件激活时 deactivated keep-alive 缓存的组件停用时调用 errorCaptured 捕获一个来自子孙组件的错误时被调用 三、生命周期整体流程 Vue生命周期流程图 具体分析 beforeCreate -> created 初始化vue实例，进行数据观测 created 完成数据观测，属性与方法的运算，watch、event事件回调的配置 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算 此时vm.$el 并没有被创建 created -> beforeMount 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译 优先级：render > template > outerHTML vm.el获取到的是挂载DOM的 beforeMount 在此阶段可获取到vm.el 此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上 beforeMount -> mounted 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM mounted vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM beforeUpdate 更新的数据必须是被渲染在模板上的（el、template、render之一） 此时view层还未更新 若在beforeUpdate中再次修改数据，不会再次触发更新方法 updated 完成view层的更新 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated） beforeDestroy 实例被销毁前调用，此时实例属性与方法仍可访问 destroyed 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器 并不能清除DOM，仅仅销毁实例 使用场景分析 生命周期 描述 beforeCreate 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 created 组件初始化完毕，各种数据可以使用，常用于异步数据获取 beforeMount 未执行渲染、更新，dom未创建 mounted 初始化结束，dom已创建，可用于获取访问数据和dom元素 beforeUpdate 更新前，可用于获取更新前各种状态 updated 更新后，所有状态已是最新 beforeDestroy 销毁前，可用于一些定时器或订阅的取消 destroyed 组件已销毁，作用同上 四、题外话：数据请求在created和mouted的区别 created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成mounted是在页面dom节点渲染完毕之后就立刻执行的触发时机上created是比mounted要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中 参考文献 https://juejin.cn/post/6844903811094413320 https://baike.baidu.com/ http://cn.vuejs.org/ 面试官VUE系列总进度：4／33 面试官：说说你对vue的理解\\? 面试官：说说你对SPA（单页应用）的理解\\? 面试官：说说你对双向绑定的理解\\? 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/mixin.html":{"url":"笔记/web前端面试-面试官系列/vue/mixin.html","title":"Mixin","keywords":"","body":"面试官：说说你对vue的mixin的理解，有什么应用场景？ 一、mixin是什么 Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类 Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂 Vue中的mixin 先来看一下官方定义 mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。 本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等 我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来 在Vue中我们可以局部混入跟全局混入 局部混入 定义一个mixin对象，有组件options的data、methods属性 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log('hello from mixin!') } } } 组件通过mixins属性调用mixin对象 Vue.component('componentA',{ mixins: [myMixin] }) 该组件在使用的时候，混合了mixin里面的方法，在自动执行create生命钩子，执行hello方法 全局混入 通过Vue.mixin()进行全局的混入 Vue.mixin({ created: function () { console.log(\"全局混入\") } }) 使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件） PS：全局混入常用于插件的编写 注意事项： 当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项 但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子 二、使用场景 在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立 这时，可以通过Vue的mixin功能将相同或者相似的代码提出来 举个例子 定义一个modal弹窗组件，内部通过isShowing来控制显示 const Modal = { template: '#modal', data() { return { isShowing: false } }, methods: { toggleShow() { this.isShowing = !this.isShowing; } } } 定义一个tooltip提示框，内部通过isShowing来控制显示 const Tooltip = { template: '#tooltip', data() { return { isShowing: false } }, methods: { toggleShow() { this.isShowing = !this.isShowing; } } } 通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了 首先抽出共同代码，编写一个mixin const toggle = { data() { return { isShowing: false } }, methods: { toggleShow() { this.isShowing = !this.isShowing; } } } 两个组件在使用上，只需要引入mixin const Modal = { template: '#modal', mixins: [toggle] }; const Tooltip = { template: '#tooltip', mixins: [toggle] } 通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用 三、源码分析 首先从Vue.mixin入手 源码位置：/src/core/global-api/mixin.js export function initMixin (Vue: GlobalAPI) { Vue.mixin = function (mixin: Object) { this.options = mergeOptions(this.options, mixin) return this } } 主要是调用merOptions方法 源码位置：/src/core/util/options.js export function mergeOptions ( parent: Object, child: Object, vm?: Component ): Object { if (child.mixins) { // 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并 for (let i = 0, l = child.mixins.length; i 从上面的源码，我们得到以下几点： 优先递归处理 mixins 先遍历合并parent 中的key，调用mergeField方法进行合并，然后保存在变量options 再遍历 child，合并补上 parent 中没有的key，调用mergeField方法进行合并，保存在变量options 通过 mergeField 函数进行了合并 下面是关于Vue的几种类型的合并策略 替换型 合并型 队列型 叠加型 替换型 替换型合并有props、methods、inject、computed strats.props = strats.methods = strats.inject = strats.computed = function ( parentVal: ?Object, childVal: ?Object, vm?: Component, key: string ): ?Object { if (!parentVal) return childVal // 如果parentVal没有值，直接返回childVal const ret = Object.create(null) // 创建一个第三方对象 ret extend(ret, parentVal) // extend方法实际是把parentVal的属性复制到ret中 if (childVal) extend(ret, childVal) // 把childVal的属性复制到ret中 return ret } strats.provide = mergeDataOrFn 同名的props、methods、inject、computed会被后来者代替 合并型 和并型合并有：data strats.data = function(parentVal, childVal, vm) { return mergeDataOrFn( parentVal, childVal, vm ) }; function mergeDataOrFn(parentVal, childVal, vm) { return function mergedInstanceDataFn() { var childData = childVal.call(vm, vm) // 执行data挂的函数得到对象 var parentData = parentVal.call(vm, vm) if (childData) { return mergeData(childData, parentData) // 将2个对象进行合并 } else { return parentData // 如果没有childData 直接返回parentData } } } function mergeData(to, from) { if (!from) return to var key, toVal, fromVal; var keys = Object.keys(from); for (var i = 0; i mergeData函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并： 当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set方法其实就是一些合并重新赋值的方法） 当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性 队列性 队列性合并有：全部生命周期和watch function mergeHook ( parentVal: ?Array, childVal: ?Function | ?Array ): ?Array { return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal } LIFECYCLE_HOOKS.forEach(hook => { strats[hook] = mergeHook }) // watch strats.watch = function ( parentVal, childVal, vm, key ) { // work around Firefox's Object.prototype.watch... if (parentVal === nativeWatch) { parentVal = undefined; } if (childVal === nativeWatch) { childVal = undefined; } /* istanbul ignore if */ if (!childVal) { return Object.create(parentVal || null) } { assertObjectType(key, childVal, vm); } if (!parentVal) { return childVal } var ret = {}; extend(ret, parentVal); for (var key$1 in childVal) { var parent = ret[key$1]; var child = childVal[key$1]; if (parent && !Array.isArray(parent)) { parent = [parent]; } ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; } return ret }; 生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行 叠加型 叠加型合并有：component、directives、filters strats.components= strats.directives= strats.filters = function mergeAssets( parentVal, childVal, vm, key ) { var res = Object.create(parentVal || null); if (childVal) { for (var key in childVal) { res[key] = childVal[key]; } } return res } 叠加型主要是通过原型链进行层层的叠加 小结： 替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数 合并型策略是data, 通过set方法进行合并和重新赋值 队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行 叠加型有component、directives、filters，通过原型链进行层层的叠加 参考文献 https://zhuanlan.zhihu.com/p/31018570 https://juejin.cn/post/6844904015495446536#heading-1 https://juejin.cn/post/6844903846775357453 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/modifier.html":{"url":"笔记/web前端面试-面试官系列/vue/modifier.html","title":"Modifier","keywords":"","body":"面试官：Vue常用的修饰符有哪些有什么应用场景 一、修饰符是什么 在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号 在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理 vue中修饰符分为以下五种： 表单修饰符 事件修饰符 鼠标按键修饰符 键值修饰符 v-bind修饰符 二、修饰符的作用 表单修饰符 在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model 关于表单的修饰符有如下： lazy trim number lazy 在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步 { {value}} trim 自动过滤用户输入的首空格字符，而中间的空格不会过滤 number 自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值 事件修饰符 事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符： stop prevent self once capture passive native stop 阻止了事件冒泡，相当于调用了event.stopPropagation方法 ok //只输出1 prevent 阻止了事件的默认行为，相当于调用了event.preventDefault方法 self 只当在 event.target 是当前元素自身时触发处理函数 ... 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击 once 绑定了事件以后只能触发一次，第二次就不会触发 ok capture 使事件触发从包含这个元素的顶层开始往下触发 obj1 obj2 obj3 obj4 // 输出结构: 1 2 4 3 passive 在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符 ... 不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。 passive 会告诉浏览器你不想阻止事件的默认行为 native 让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件 使用.native修饰符来操作普通HTML标签是会令事件失效的 鼠标按钮修饰符 鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下： left 左键点击 right 右键点击 middle 中键点击 ok ok ok 键盘修饰符 键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下： keyCode存在很多，但vue为我们提供了别名，分为以下两种： 普通键（enter、tab、delete、space、esc、up...） 系统修饰键（ctrl、alt、meta、shift...） // 只有按键为keyCode的时候才触发 还可以通过以下方式自定义一些全局的键盘码别名 Vue.config.keyCodes.f2 = 113 v-bind修饰符 v-bind修饰符主要是为属性进行操作，用来分别有如下： async prop camel async 能对props进行一个双向绑定 //父组件 //子组件 this.$emit('update:myMessage',params); 以上这种方法相当于以下的简写 //父亲组件 func(e){ this.bar = e; } //子组件js func2(){ this.$emit('update:myMessage',params); } 使用async需要注意以下两点： 使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的 props 设置自定义标签属性，避免暴露数据，防止污染HTML结构 camel 将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox 三、应用场景 根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景： .stop：阻止事件冒泡 .native：绑定原生事件 .once：事件只执行一次 .self ：将事件绑定在自身身上，相当于阻止事件冒泡 .prevent：阻止默认事件 .caption：用于事件捕获 .once：只触发一次 .keyCode：监听特定键盘按下 .right：右键 参考文献 https://segmentfault.com/a/1190000016786254 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/new_vue.html":{"url":"笔记/web前端面试-面试官系列/vue/new_vue.html","title":"New Vue","keywords":"","body":"面试官：Vue实例挂载的过程 一、思考 我们都听过知其然知其所以然这句话 那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？ 过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等 一、分析 首先找到vue的构造函数 源码位置：src\\core\\instance\\index.js function Vue (options) { if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options) } options是用户传递过来的配置项，如data、methods等常用的方法 vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法 initMixin(Vue); // 定义 _init stateMixin(Vue); // 定义 $set $get $delete $watch 等 eventsMixin(Vue); // 定义事件 $on $once $off $emit lifecycleMixin(Vue);// 定义 _update $forceUpdate $destroy renderMixin(Vue); // 定义 _render 返回虚拟dom 首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法 源码位置：src\\core\\instance\\init.js Vue.prototype._init = function (options?: Object) { const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && config.performance && mark) { startTag = `vue-perf-start:${vm._uid}` endTag = `vue-perf-end:${vm._uid}` mark(startTag) } // a flag to avoid this being observed vm._isVue = true // merge options // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法 if (options && options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { // 合并vue属性 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { // 初始化proxy拦截器 initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm // 初始化组件生命周期标志位 initLifecycle(vm) // 初始化组件事件侦听 initEvents(vm) // 初始化渲染方法 initRender(vm) callHook(vm, 'beforeCreate') // 初始化依赖注入内容，在初始化data、props之前 initInjections(vm) // resolve injections before data/props // 初始化props/data/method/watch/methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && config.performance && mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue ${vm._name} init`, startTag, endTag) } // 挂载元素 if (vm.$options.el) { vm.$mount(vm.$options.el) } } 仔细阅读上面的代码，我们得到以下结论： 在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到 到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素 挂载方法是调用vm.$mount方法 initState方法是完成props/data/method/watch/methods的初始化 源码位置：src\\core\\instance\\state.js export function initState (vm: Component) { // 初始化组件的watcher列表 vm._watchers = [] const opts = vm.$options // 初始化props if (opts.props) initProps(vm, opts.props) // 初始化methods方法 if (opts.methods) initMethods(vm, opts.methods) if (opts.data) { // 初始化data initData(vm) } else { observe(vm._data = {}, true /* asRootData */) } if (opts.computed) initComputed(vm, opts.computed) if (opts.watch && opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } } 我们和这里主要看初始化data的方法为initData，它与initState在同一文件上 function initData (vm: Component) { let data = vm.$options.data // 获取到组件上的data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' && warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { // 属性名不能与方法名重复 if (methods && hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } // 属性名不能与state名称重复 if (props && hasOwn(props, key)) { process.env.NODE_ENV !== 'production' && warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { // 验证key值的合法性 // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据 proxy(vm, `_data`, key) } } // observe data // 响应式监听data是数据的变化 observe(data, true /* asRootData */) } 仔细阅读上面的代码，我们可以得到以下结论： 初始化顺序：props、methods、data data定义的时候可选择函数形式或者对象形式（组件只能为函数形式） 关于数据响应式在这就不展开详细说明 上文提到挂载方法是调用vm.$mount方法 源码位置： Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { // 获取或查询元素 el = el && query(el) /* istanbul ignore if */ // vue 不允许直接挂载到body或页面文档上 if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' && warn( `Do not mount Vue to or - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template // 存在template模板，解析vue模板文件 if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { // 通过选择器获取元素内容 template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && config.performance && mark) { mark('compile') } /** * 1.将temmplate解析ast tree * 2.将ast tree转换成render语法字符串 * 3.生成render方法 */ const { render, staticRenderFns } = compileToFunctions(template, { outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && config.performance && mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating) } 阅读上面代码，我们能得到以下结论： 不要将根元素放到body或者html上 可以在对象中定义template/render或者直接使用template、el表示元素选择器 最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数 对template的解析步骤大致分为以下几步： 将html文档片段解析成ast描述符 将ast描述符解析成字符串 生成render函数 生成render函数，挂载到vm上后，会再次调用mount方法 源码位置：src\\platforms\\web\\runtime\\index.js // public mount method Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el && inBrowser ? query(el) : undefined // 渲染组件 return mountComponent(this, el, hydrating) } 调用mountComponent渲染组件 export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el // 如果没有获取解析的render函数，则会抛出警告 // render是解析模板文件生成的 if (!vm.$options.render) { vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') { /* istanbul ignore if */ if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) { warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) } else { // 没有获取到vue的模板文件 warn( 'Failed to mount component: template or render function not defined.', vm ) } } } // 执行beforeMount钩子 callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' && config.performance && mark) { updateComponent = () => { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { // 定义更新函数 updateComponent = () => { // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined // 监听当前组件状态，当有数据变化时，更新组件 new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted && !vm._isDestroyed) { // 数据更新引发的组件更新 callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm } 阅读上面代码，我们得到以下结论： 会触发boforeCreate钩子 定义updateComponent渲染页面视图的方法 监听组件数据，一旦发生变化，触发beforeUpdate生命钩子 updateComponent方法主要执行在vue初始化时声明的render，update方法 render的作用主要是生成vnode 源码位置：src\\core\\instance\\render.js // 定义vue 原型上的render方法 Vue.prototype._render = function (): VNode { const vm: Component = this // render函数来自于组件的option const { render, _parentVnode } = vm.$options if (_parentVnode) { vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) } // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try { // There's no need to maintain a stack because all render fns are called // separately from one another. Nested component's render fns are called // when parent component is patched. currentRenderingInstance = vm // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode vnode = render.call(vm._renderProxy, vm.$createElement) } catch (e) { handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) { try { vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) } catch (e) { handleError(e, vm, `renderError`) vnode = vm._vnode } } else { vnode = vm._vnode } } finally { currentRenderingInstance = null } // if the returned array contains only a single node, allow it if (Array.isArray(vnode) && vnode.length === 1) { vnode = vnode[0] } // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) { if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) { warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) } vnode = createEmptyVNode() } // set parent vnode.parent = _parentVnode return vnode } _update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中 源码位置：src\\core\\instance\\lifecycle.js Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode // 设置当前激活的作用域 const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) { // initial render // 执行具体的挂载逻辑 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } restoreActiveInstance() // update __vue__ reference if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. } 三、结论 new Vue的时候调用会调用_init方法 定义 $set、$get 、$delete、$watch 等方法 定义 $on、$off、$emit、$off等事件 定义 _update、$forceUpdate、$destroy生命周期 调用$mount进行页面的挂载 挂载的时候主要是通过mountComponent方法 定义updateComponent更新函数 执行render生成虚拟DOM _update将虚拟DOM生成真实DOM结构，并且渲染到页面中 参考文献 https://www.cnblogs.com/gerry2019/p/12001661.html https://github.com/vuejs/vue/tree/dev/src/core/instance https://vue3js.cn 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/nexttick.html":{"url":"笔记/web前端面试-面试官系列/vue/nexttick.html","title":"Nexttick","keywords":"","body":"面试官：Vue中的$nextTick有什么作用？ 一、NextTick是什么 官方对其的定义 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 什么意思呢？ 我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新 举例一下 Html结构 { { message }} 构建一个vue实例 const vm = new Vue({ el: '#app', data: { message: '原始值' } }) 修改message this.message = '修改后的值1' this.message = '修改后的值2' this.message = '修改后的值3' 这时候想获取页面最新的DOM节点，却发现获取到的是旧值 console.log(vm.$el.textContent) // 原始值 这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中 如果我们一直修改相同数据，异步操作队列还会进行去重 等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新 为什么要有nexttick 举个例子 { {num}} for(let i=0; i 如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略 二、使用场景 如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick() 第一个参数为：回调函数（可以获取最近的DOM结构） 第二个参数为：执行函数上下文 // 修改数据 vm.message = '修改后的值' // DOM 还没有更新 console.log(vm.$el.textContent) // 原始的值 Vue.nextTick(function () { // DOM 更新了 console.log(vm.$el.textContent) // 修改后的值 }) 组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上 this.message = '修改后的值' console.log(this.$el.textContent) // => '原始的值' this.$nextTick(function () { console.log(this.$el.textContent) // => '修改后的值' }) $nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情 this.message = '修改后的值' console.log(this.$el.textContent) // => '原始的值' await this.$nextTick() console.log(this.$el.textContent) // => '修改后的值' 三、实现原理 源码位置：/src/core/util/next-tick.js callbacks也就是异步操作队列 callbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次 export function nextTick(cb?: Function, ctx?: Object) { let _resolve; // cb 回调函数会经统一处理压入 callbacks 数组 callbacks.push(() => { if (cb) { // 给 cb 回调函数执行加上了 try-catch 错误处理 try { cb.call(ctx); } catch (e) { handleError(e, ctx, 'nextTick'); } } else if (_resolve) { _resolve(ctx); } }); // 执行异步延迟函数 timerFunc if (!pending) { pending = true; timerFunc(); } // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用 if (!cb && typeof Promise !== 'undefined') { return new Promise(resolve => { _resolve = resolve; }); } } timerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有： Promise.then、MutationObserver、setImmediate、setTimeout 通过上面任意一种方法，进行降级操作 export let isUsingMicroTask = false if (typeof Promise !== 'undefined' && isNative(Promise)) { //判断1：是否原生支持Promise const p = Promise.resolve() timerFunc = () => { p.then(flushCallbacks) if (isIOS) setTimeout(noop) } isUsingMicroTask = true } else if (!isIE && typeof MutationObserver !== 'undefined' && ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]' )) { //判断2：是否原生支持MutationObserver let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } isUsingMicroTask = true } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) { //判断3：是否原生支持setImmediate timerFunc = () => { setImmediate(flushCallbacks) } } else { //判断4：上面都不行，直接用setTimeout timerFunc = () => { setTimeout(flushCallbacks, 0) } } 无论是微任务还是宏任务，都会放到flushCallbacks使用 这里将callbacks里面的函数复制一份，同时callbacks置空 依次执行callbacks里面的函数 function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i 小结： 把回调函数放入callbacks等待执行 将执行函数放到微任务或者宏任务中 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调 参考文献 https://juejin.cn/post/6844904147804749832 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/observable.html":{"url":"笔记/web前端面试-面试官系列/vue/observable.html","title":"Observable","keywords":"","body":"面试官：Vue.observable你有了解过吗？说说看 一、Observable 是什么 Observable 翻译过来我们可以理解成可观察的 我们先来看一下其在Vue中的定义 Vue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器 Vue.observable({ count : 1}) 其作用等同于 new vue({ count : 1}) 在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象 在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的 二、使用场景 在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择 创建一个js文件 // 引入vue import Vue from 'vue // 创建state对象，使用observable让state对象可响应 export let state = Vue.observable({ name: '张三', 'age': 38 }) // 创建对应的方法 export let mutations = { changeName(name) { state.name = name }, setAge(age) { state.age = age } } 在.vue文件中直接使用即可 姓名：{ { name }} 年龄：{ { age }} 改变姓名 改变年龄 import { state, mutations } from '@/store export default { // 在计算属性中拿到值 computed: { name() { return state.name }, age() { return state.age } }, // 调用mutations里面的方法，更新数据 methods: { changeName: mutations.changeName, setAge: mutations.setAge } } 三、原理分析 源码位置：src\\core\\observer\\index.js export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void // 判断是否存在__ob__响应式属性 if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue ) { // 实例化Observer响应式对象 ob = new Observer(value) } if (asRootData && ob) { ob.vmCount++ } return ob } Observer类 export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { // 实例化对象是一个对象，进入walk方法 this.walk(value) } } walk函数 walk (obj: Object) { const keys = Object.keys(obj) // 遍历key，通过defineReactive创建响应式对象 for (let i = 0; i defineReactive方法 export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property && property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property && property.get const setter = property && property.set if ((!getter || setter) && arguments.length === 2) { val = obj[key] } let childOb = !shallow && observe(val) // 接下来调用Object.defineProperty()给对象定义响应式属性 Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal && value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' && customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter && !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow && observe(newVal) // 对观察者watchers进行通知,state就成了全局响应式对象 dep.notify() } }) } 参考文献 https://blog.csdn.net/qq_32682301/article/details/105419673 https://wbbyouzi.com/archives/343 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/permission.html":{"url":"笔记/web前端面试-面试官系列/vue/permission.html","title":"Permission","keywords":"","body":"面试官：vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ 一、是什么 权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源 而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发 页面加载触发 页面上的按钮点击触发 总的来说，所有的请求发起都触发自前端路由或视图 所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是： 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截 二、如何做 前端权限控制可以分为四个方面： 接口权限 按钮权限 菜单权限 路由权限 接口权限 接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录 登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token axios.interceptors.request.use(config => { config.headers['token'] = cookie.get('token') return config }) axios.interceptors.response.use(res=>{},{response}=>{ if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误 router.push('/login') } }) 路由权限控制 方案一 初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验 const routerMap = [ { path: '/permission', component: Layout, redirect: '/permission/index', alwaysShow: true, // will always show the root menu meta: { title: 'permission', icon: 'lock', roles: ['admin', 'editor'] // you can set roles in root nav }, children: [{ path: 'page', component: () => import('@/views/permission/page'), name: 'pagePermission', meta: { title: 'pagePermission', roles: ['admin'] // or you can only set roles in sub nav } }, { path: 'directive', component: () => import('@/views/permission/directive'), name: 'directivePermission', meta: { title: 'directivePermission' // if do not set roles, means: this page does not require permission } }] }] 这种方式存在以下四种缺点： 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。 全局路由守卫里，每次路由跳转都要做权限判断。 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识 方案二 初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制 登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由 import router from './router' import store from './store' import { Message } from 'element-ui' import NProgress from 'nprogress' // progress bar import 'nprogress/nprogress.css'// progress bar style import { getToken } from '@/utils/auth' // getToken from cookie NProgress.configure({ showSpinner: false })// NProgress Configuration // permission judge function function hasPermission(roles, permissionRoles) { if (roles.indexOf('admin') >= 0) return true // admin permission passed directly if (!permissionRoles) return true return roles.some(role => permissionRoles.indexOf(role) >= 0) } const whiteList = ['/login', '/authredirect']// no redirect whitelist router.beforeEach((to, from, next) => { NProgress.start() // start progress bar if (getToken()) { // determine if there has token /* has token*/ if (to.path === '/login') { next({ path: '/' }) NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it } else { if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetUserInfo').then(res => { // 拉取user_info const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop'] store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record }) }).catch((err) => { store.dispatch('FedLogOut').then(() => { Message.error(err || 'Verification failed, please login again') next({ path: '/' }) }) }) } else { // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓ if (hasPermission(store.getters.roles, to.meta.roles)) { next()// } else { next({ path: '/401', replace: true, query: { noGoBack: true }}) } // 可删 ↑ } } } else { /* has no token*/ if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next('/login') // 否则全部重定向到登录页 NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it } } }) router.afterEach(() => { NProgress.done() // finish progress bar }) 按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限 这种方式也存在了以下的缺点： 全局路由守卫里，每次路由跳转都要做判断 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识 菜单权限 菜单权限可以理解成将页面与理由进行解耦 方案一 菜单与路由分离，菜单由后端返回 前端定义路由信息 { name: \"login\", path: \"/login\", component: () => import(\"@/pages/Login.vue\") } name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验 全局路由守卫里做判断 function hasPermission(router, accessMenu) { if (whiteList.indexOf(router.path) !== -1) { return true; } let menu = Util.getMenuByName(router.name, accessMenu); if (menu.name) { return true; } return false; } Router.beforeEach(async (to, from, next) => { if (getToken()) { let userInfo = store.state.user.userInfo; if (!userInfo.name) { try { await store.dispatch(\"GetUserInfo\") await store.dispatch('updateAccessMenu') if (to.path === '/login') { next({ name: 'home_index' }) } else { //Util.toDefaultPage([...routers], to.name, router, next); next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由 } } catch (e) { if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next('/login') } } } else { if (to.path === '/login') { next({ name: 'home_index' }) } else { if (hasPermission(to, store.getters.accessMenu)) { Util.toDefaultPage(store.getters.accessMenu,to, routes, next); } else { next({ path: '/403',replace:true }) } } } } else { if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next('/login') } } let menu = Util.getMenuByName(to.name, store.getters.accessMenu); Util.title(menu.title); }); Router.afterEach((to) => { window.scrollTo(0, 0); }); 每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的 如果根据路由name找不到对应的菜单，就表示用户有没权限访问 如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载 这种方式的缺点： 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用 全局路由守卫里，每次路由跳转都要做判断 方案二 菜单和路由都由后端返回 前端统一定义路由组件 const Home = () => import(\"../pages/Home.vue\"); const UserInfo = () => import(\"../pages/UserInfo.vue\"); export default { home: Home, userInfo: UserInfo }; 后端路由组件返回以下格式 [ { name: \"home\", path: \"/\", component: \"home\" }, { name: \"home\", path: \"/userinfo\", component: \"userInfo\" } ] 在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件 如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理 这种方法也会存在缺点： 全局路由守卫里，每次路由跳转都要做判断 前后端的配合要求更高 按钮权限 方案一 按钮权限也可以用v-if判断 但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断 这种方式就不展开举例了 方案二 通过自定义指令进行按钮权限的判断 首先配置路由 { path: '/permission', component: Layout, name: '权限测试', meta: { btnPermissions: ['admin', 'supper', 'normal'] }, //页面需要的权限 children: [{ path: 'supper', component: _import('system/supper'), name: '权限测试页', meta: { btnPermissions: ['admin', 'supper'] } //页面需要的权限 }, { path: 'normal', component: _import('system/normal'), name: '权限测试页', meta: { btnPermissions: ['admin'] } //页面需要的权限 }] } 自定义权限鉴定指令 import Vue from 'vue' /**权限指令**/ const has = Vue.directive('has', { bind: function (el, binding, vnode) { // 获取页面按钮权限 let btnPermissionsArr = []; if(binding.value){ // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。 btnPermissionsArr = Array.of(binding.value); }else{ // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。 btnPermissionsArr = vnode.context.$route.meta.btnPermissions; } if (!Vue.prototype.$_has(btnPermissionsArr)) { el.parentNode.removeChild(el); } } }); // 权限检查方法 Vue.prototype.$_has = function (value) { let isExist = false; // 获取用户按钮权限 let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\"); if (btnPermissionsStr == undefined || btnPermissionsStr == null) { return false; } if (value.indexOf(btnPermissionsStr) > -1) { isExist = true; } return isExist; }; export {has} 在使用的按钮中只需要引用v-has指令 编辑 小结 关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离 权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断 参考文献 https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw https://segmentfault.com/a/1190000020887109 https://juejin.cn/post/6844903648057622536#heading-6 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/show_if.html":{"url":"笔记/web前端面试-面试官系列/vue/show_if.html","title":"Show If","keywords":"","body":"面试官：v-show和v-if有什么区别？使用场景分别是什么？ 一、v-show与v-if的共同点 我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 在用法上也是相同的 当表达式为true的时候，都会占据页面的位置 当表达式都为false时，都不会占据页面位置 二、v-show与v-if的区别 控制手段不同 编译过程不同 编译条件不同 控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换 编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染 v-show 由false变为true的时候不会触发组件的生命周期 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 三、v-show与v-if原理分析 具体解析流程这里不展开讲，大致流程如下 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-show原理 不管初始条件是什么，元素总是会被渲染 我们看一下在vue中是如何实现的 代码很好理解，有transition就执行transition，没有就直接设置display属性 // https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts export const vShow: ObjectDirective = { beforeMount(el, { value }, { transition }) { el._vod = el.style.display === 'none' ? '' : el.style.display if (transition && value) { transition.beforeEnter(el) } else { setDisplay(el, value) } }, mounted(el, { value }, { transition }) { if (transition && value) { transition.enter(el) } }, updated(el, { value, oldValue }, { transition }) { // ... }, beforeUnmount(el, { value }) { setDisplay(el, value) } } v-if原理 v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分 返回一个node节点，render函数通过表达式的值来决定是否生成DOM // https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts export const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) => { return processIf(node, dir, context, (ifNode, branch, isRoot) => { // ... return () => { if (isRoot) { ifNode.codegenNode = createCodegenNodeForBranch( branch, key, context ) as IfConditionalExpression } else { // attach this branch's codegen node to the v-if root. const parentCondition = getParentCondition(ifNode.codegenNode!) parentCondition.alternate = createCodegenNodeForBranch( branch, key + ifNode.branches.length - 1, context ) } } }) } ) 四、v-show与v-if的使用场景 v-if 与 v-show 都能控制dom元素在页面的显示 v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好 参考文献 https://www.jianshu.com/p/7af8554d8f08 https://juejin.cn/post/6897948855904501768 https://vue3js/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/slot.html":{"url":"笔记/web前端面试-面试官系列/vue/slot.html","title":"Slot","keywords":"","body":"面试官：说说你对slot的理解？slot使用场景有哪些？ 一、slot是什么 在HTML中 slot 元素 ，作为 Web Components 技术套件的一部分，是Web组件内的一个占位符 该占位符可以在后期使用自己的标记语言填充 举个栗子 Slot template 1 2 template不会展示到页面中，需要用先获取它的引用，然后添加到DOM中， customElements.define('element-details', class extends HTMLElement { constructor() { super(); const template = document .getElementById('element-details-template') .content; const shadowRoot = this.attachShadow({mode: 'open'}) .appendChild(template.cloneNode(true)); } }) 在Vue中的概念也是如此 Slot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口 可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容） 放张图感受一下 二、使用场景 通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理 如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情 通过slot插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用 比如布局组件、表格列、下拉选、弹框显示内容等 三、分类 slot可以分来以下三种： 默认插槽 具名插槽 作用域插槽 默认插槽 子组件用标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面 父组件在使用的时候，直接在子组件的标签内写入内容即可 子组件Child.vue 插槽后备的内容 父组件 默认插槽 具名插槽 子组件用name属性来表示插槽的名字，不传为默认插槽 父组件中在使用时在默认插槽的基础上加上slot属性，值为子组件插槽name属性值 子组件Child.vue 插槽后备的内容 插槽后备的内容 父组件 具名插槽 内容... 作用域插槽 子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上 父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用 子组件Child.vue 没传footer插槽 父组件 来⾃⼦组件数据：{ {slotProps.testProps}} 来⾃⼦组件数据：{ {slotProps.testProps}} 小结： v-slot属性只能在上使用，但在只有默认插槽时可以在组件标签上使用 默认插槽名为default，可以省略default直接写v-slot 缩写为#时不能不写参数，写成#default 可以通过解构获取v-slot={user}，还可以重命名v-slot=\"{user: newName}\"和定义默认值v-slot=\"{user = '默认值'}\" 四、原理分析 slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过template -> render function -> VNode -> DOM 过程，这里看看slot如何实现： 编写一个buttonCounter组件，使用匿名插槽 Vue.component('button-counter', { template: ' 我是默认内容' }) 使用该组件 new Vue({ el: '#app', template: '我是slot传入内容', components:{buttonCounter} }) 获取buttonCounter组件渲染函数 (function anonymous( ) { with(this){return _c('div',[_t(\"default\",[_v(\"我是默认内容\")])],2)} }) _v表示穿件普通文本节点，_t表示渲染插槽的函数 渲染插槽函数renderSlot（做了简化） function renderSlot ( name, fallback, props, bindObject ) { // 得到渲染插槽内容的函数 var scopedSlotFn = this.$scopedSlots[name]; var nodes; // 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回 // 否则使用默认值 nodes = scopedSlotFn(props) || fallback; return nodes; } name属性表示定义插槽的名字，默认值为default，fallback表示子组件中的slot节点的默认值 关于this.$scopredSlots是什么，我们可以先看看vm.slot function initRender (vm) { ... vm.$slots = resolveSlots(options._renderChildren, renderContext); ... } resolveSlots函数会对children节点做归类和过滤处理，返回slots function resolveSlots ( children, context ) { if (!children || !children.length) { return {} } var slots = {}; for (var i = 0, l = children.length; i _render渲染函数通过normalizeScopedSlots得到vm.$scopedSlots vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ); 作用域插槽中父组件能够得到子组件的值是因为在renderSlot的时候执行会传入props，也就是上述_t第三个参数，父组件则能够得到子组件传递过来的值 参考文献 https://juejin.cn/post/6844903817746628615#heading-4 https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots https://vue3js.cn/docs/zh https://segmentfault.com/a/1190000019492734?utm_source=tag-newest 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/spa.html":{"url":"笔记/web前端面试-面试官系列/vue/spa.html","title":"Spa","keywords":"","body":"面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 一、什么是SPA SPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图 我们熟知的JS框架如react,vue,angular,ember都属于SPA 二、SPA和MPA的区别 上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图 单页应用与多页应用的区别 单页面应用（SPA） 多页面应用（MPA） 组成 一个主页面和多个页面片段 多个主页面 刷新方式 局部刷新 整页刷新 url模式 哈希模式 历史模式 SEO搜索引擎优化 难实现，可使用SSR方式改善 容易实现 数据传递 容易 通过url、cookie、localStorage等传递 页面切换 速度快，用户体验良好 切换加载资源，速度慢，用户体验差 维护成本 相对容易 相对复杂 单页应用优缺点 优点： 具有桌面应用的即时性、网站的可移植性和可访问性 用户体验好、快，内容的改变不需要重新加载整个页面 良好的前后端分离，分工更明确 缺点： 不利于搜索引擎的抓取 首次渲染速度相对较慢 三、实现一个SPA 原理 监听地址栏中hash变化驱动界面变化 用pushsate记录浏览器的历史，驱动界面发送变化 实现 hash 模式 核心通过监听url中的hash来进行路由跳转 // 定义 Router class Router { constructor () { this.routes = {}; // 存放路由path及callback this.currentUrl = ''; // 监听路由change调用相对应的路由回调 window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback){ this.routes[path] = callback; } push(path) { this.routes[path] && this.routes[path]() } } // 使用 router window.miniRouter = new Router(); miniRouter.route('/', () => console.log('page1')) miniRouter.route('/page2', () => console.log('page2')) miniRouter.push('/') // page1 miniRouter.push('/page2') // page2 history模式 history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api history.pushState 浏览器历史纪录添加记录 history.replaceState修改浏览器历史纪录中当前纪录 history.popState 当 history 发生变化时触发 // 定义 Router class Router { constructor () { this.routes = {}; this.listerPopState() } init(path) { history.replaceState({path: path}, null, path); this.routes[path] && this.routes[path](); } route(path, callback){ this.routes[path] = callback; } push(path) { history.pushState({path: path}, null, path); this.routes[path] && this.routes[path](); } listerPopState () { window.addEventListener('popstate' , e => { const path = e.state && e.state.path; this.routers[path] && this.routers[path]() }) } } // 使用 Router window.miniRouter = new Router(); miniRouter.route('/', ()=> console.log('page1')) miniRouter.route('/page2', ()=> console.log('page2')) // 跳转 miniRouter.push('/page2') // page2 四、题外话：如何给SPA做SEO 下面给出基于Vue的SPA如何实现SEO的三种方式 SSR服务端渲染 将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js 静态化 目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果 使用Phantomjs针对爬虫处理 原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图 参考文献 https://segmentfault.com/a/1190000019623624 https://juejin.cn/post/6844903512107663368 https://www.cnblogs.com/constantince/p/5586851.html 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/ssr.html":{"url":"笔记/web前端面试-面试官系列/vue/ssr.html","title":"Ssr","keywords":"","body":"面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？ 一、是什么 Server-Side Rendering 我们称其为SSR，意为服务端渲染 指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程 先来看看Web3个阶段的发展史： 传统服务端渲染SSR 单页面应用SPA 服务端渲染SSR 传统web开发 网页内容在服务端渲染完成，⼀次性传输到浏览器 打开页面查看源码，浏览器拿到的是全部的dom结构 单页应用SPA 单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染 打开页面查看源码，浏览器拿到的仅有宿主元素#app，并没有内容 服务端渲染SSR SSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行 看完前端发展，我们再看看Vue官方对SSR的解释： Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序 服务器渲染的 Vue.js 应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行 我们从上门解释得到以下结论： Vue SSR是一个在SPA上进行改良的服务端渲染 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互 Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA 二、解决了什么 SSR主要解决了以下两种问题： seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo 首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端） 但是使用SSR同样存在以下的缺点： 复杂度：整个项目的复杂度 库的支持性，代码兼容 性能问题 每个请求都是n个实例的创建，不然会污染，消耗会变得很大 缓存 node serve、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。 降级：监控cpu、内存占用过多，就spa，返回单个的壳 服务器负载变大，相对于前后端分离务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用 所以在我们选择是否使用SSR前，我们需要慎重问问自己这些问题： 需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现 首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢 三、如何实现 对于同构开发，我们依然使用webpack打包，我们要解决两个问题：服务端首屏渲染和客户端激活 这里需要生成一个服务器bundle文件用于服务端首屏渲染和一个客户端bundle文件用于客户端激活 代码结构 除了两个不同入口之外，其他结构和之前vue应用完全相同 src ├── router ├────── index.js # 路由声明 ├── store ├────── index.js # 全局状态 ├── main.js # ⽤于创建vue实例 ├── entry-client.js # 客户端⼊⼝，⽤于静态内容“激活” └── entry-server.js # 服务端⼊⼝，⽤于⾸屏内容渲染 路由配置 import Vue from \"vue\"; import Router from \"vue-router\"; Vue.use(Router); //导出⼯⼚函数 export function createRouter() { return new Router({ mode: 'history', routes: [ // 客户端没有编译器，这⾥要写成渲染函数 { path: \"/\", component: { render: h => h('div', 'index page') } }, { path: \"/detail\", component: { render: h => h('div', 'detail page') } } ] }); } 主文件main.js 跟之前不同，主文件是负责创建vue实例的工厂，每次请求均会有独立的vue实例创建 import Vue from \"vue\"; import App from \"./App.vue\"; import { createRouter } from \"./router\"; // 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例 // 上下⽂⽤于给vue实例传递参数 export function createApp(context) { const router = createRouter(); const app = new Vue({ router, context, render: h => h(App) }); return { app, router }; } 编写服务端入口src/entry-server.js 它的任务是创建Vue实例并根据传入url指定首屏 import { createApp } from \"./main\"; // 返回⼀个函数，接收请求上下⽂，返回创建的vue实例 export default context => { // 这⾥返回⼀个Promise，确保路由或组件准备就绪 return new Promise((resolve, reject) => { const { app, router } = createApp(context); // 跳转到⾸屏的地址 router.push(context.url); // 路由就绪，返回结果 router.onReady(() => { resolve(app); }, reject); }); }; 编写客户端入口entry-client.js 客户端入口只需创建vue实例并执行挂载，这⼀步称为激活 import { createApp } from \"./main\"; // 创建vue、router实例 const { app, router } = createApp(); // 路由就绪，执⾏挂载 router.onReady(() => { app.$mount(\"#app\"); }); 对webpack进行配置 安装依赖 npm install webpack-node-externals lodash.merge -D 对vue.config.js进行配置 // 两个插件分别负责打包客户端和服务端 const VueSSRServerPlugin = require(\"vue-server-renderer/server-plugin\"); const VueSSRClientPlugin = require(\"vue-server-renderer/client-plugin\"); const nodeExternals = require(\"webpack-node-externals\"); const merge = require(\"lodash.merge\"); // 根据传⼊环境变量决定⼊⼝⽂件和相应配置项 const TARGET_NODE = process.env.WEBPACK_TARGET === \"node\"; const target = TARGET_NODE ? \"server\" : \"client\"; module.exports = { css: { extract: false }, outputDir: './dist/'+target, configureWebpack: () => ({ // 将 entry 指向应⽤程序的 server / client ⽂件 entry: `./src/entry-${target}.js`, // 对 bundle renderer 提供 source map ⽀持 devtool: 'source-map', // target设置为node使webpack以Node适⽤的⽅式处理动态导⼊， // 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。 target: TARGET_NODE ? \"node\" : \"web\", // 是否模拟node全局变量 node: TARGET_NODE ? undefined : false, output: { // 此处使⽤Node⻛格导出模块 libraryTarget: TARGET_NODE ? \"commonjs2\" : undefined }, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。 externals: TARGET_NODE ? nodeExternals({ // 不要外置化webpack需要处理的依赖模块。 // 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件， // 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单 whitelist: [/\\.css$/] }) : undefined, optimization: { splitChunks: undefined }, // 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。 // 服务端默认⽂件名为 `vue-ssr-server-bundle.json` // 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。 plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()] }), chainWebpack: config => { // cli4项⽬添加 if (TARGET_NODE) { config.optimization.delete('splitChunks') } config.module .rule(\"vue\") .use(\"vue-loader\") .tap(options => { merge(options, { optimizeSSR: false }); }); } }; 对脚本进行配置，安装依赖 npm i cross-env -D 定义创建脚本package.json \"scripts\": { \"build:client\": \"vue-cli-service build\", \"build:server\": \"cross-env WEBPACK_TARGET=node vue-cli-service build\", \"build\": \"npm run build:server && npm run build:client\" } 执行打包：npm run build 最后修改宿主文件/public/index.html Document 是服务端渲染入口位置，注意不能为了好看而在前后加空格 安装vuex npm install -S vuex 创建vuex工厂函数 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export function createStore () { return new Vuex.Store({ state: { count:108 }, mutations: { add(state){ state.count += 1; } } }) } 在main.js文件中挂载store import { createStore } from './store' export function createApp (context) { // 创建实例 const store = createStore() const app = new Vue({ store, // 挂载 render: h => h(App) }) return { app, router, store } } 服务器端渲染的是应用程序的\"快照\"，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据 在store进行一步数据获取 export function createStore() { return new Vuex.Store({ mutations: { // 加⼀个初始化 init(state, count) { state.count = count; }, }, actions: { // 加⼀个异步请求count的action getCount({ commit }) { return new Promise(resolve => { setTimeout(() => { commit(\"init\", Math.random() * 100); resolve(); }, 1000); }); }, }, }); } 组件中的数据预取逻辑 export default { asyncData({ store, route }) { // 约定预取逻辑编写在预取钩⼦asyncData中 // 触发 action 后，返回 Promise 以便确定请求结果 return store.dispatch(\"getCount\"); } }; 服务端数据预取，entry-server.js import { createApp } from \"./app\"; export default context => { return new Promise((resolve, reject) => { // 拿出store和router实例 const { app, router, store } = createApp(context); router.push(context.url); router.onReady(() => { // 获取匹配的路由组件数组 const matchedComponents = router.getMatchedComponents(); // 若⽆匹配则抛出异常 if (!matchedComponents.length) { return reject({ code: 404 }); } // 对所有匹配的路由组件调⽤可能存在的`asyncData()` Promise.all( matchedComponents.map(Component => { if (Component.asyncData) { return Component.asyncData({ store, route: router.currentRoute, }); } }), ) .then(() => { // 所有预取钩⼦ resolve 后， // store 已经填充⼊渲染应⽤所需状态 // 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时， // 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML context.state = store.state; resolve(app); }) .catch(reject); }, reject); }); }; 客户端在挂载到应用程序之前，store 就应该获取到状态，entry-client.js // 导出store const { app, router, store } = createApp(); // 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML // 在客户端挂载到应⽤程序之前，store 就应该获取到状态： if (window.__INITIAL_STATE__) { store.replaceState(window.__INITIAL_STATE__); } 客户端数据预取处理，main.js Vue.mixin({ beforeMount() { const { asyncData } = this.$options; if (asyncData) { // 将获取数据操作分配给 promise // 以便在组件中，我们可以在数据准备就绪后 // 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务 this.dataPromise = asyncData({ store: this.$store, route: this.$route, }); } }, }); 修改服务器启动文件 // 获取⽂件路径 const resolve = dir => require('path').resolve(__dirname, dir) // 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由 app.use(express.static(resolve('../dist/client'), {index: false})) // 第 2 步：获得⼀个createBundleRenderer const { createBundleRenderer } = require(\"vue-server-renderer\"); // 第 3 步：服务端打包⽂件地址 const bundle = resolve(\"../dist/server/vue-ssr-server-bundle.json\"); // 第 4 步：创建渲染器 const renderer = createBundleRenderer(bundle, { runInNewContext: false, // https://ssr.vuejs.org/zh/api/#runinnewcontext template: require('fs').readFileSync(resolve(\"../public/index.html\"), \"utf8\"), // 宿主⽂件 clientManifest: require(resolve(\"../dist/client/vue-ssr-clientmanifest.json\")) // 客户端清单 }); app.get('*', async (req,res)=>{ // 设置url和title两个重要参数 const context = { title:'ssr test', url:req.url } const html = await renderer.renderToString(context); res.send(html) }) 小结 使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例 实现ssr需要实现服务端首屏渲染和客户端激活 服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取 首屏异步获取数据，在服务端预渲染的时候就应该已经完成 切换组件通过mixin混入，在beforeMount钩子完成数据获取 参考文献 https://juejin.cn/post/6896007907050487816 https://vue3js.cn/docs/zh 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/structure.html":{"url":"笔记/web前端面试-面试官系列/vue/structure.html","title":"Structure","keywords":"","body":"面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ 一、为什么要划分 使用vue构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高 在划分项目结构的时候，需要遵循一些基本的原则： 文件夹和文件夹内部文件的语义一致性 单一入口/出口 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用 公共的文件应该以绝对路径的方式从根目录引用 /src 外的文件不应该被引入 文件夹和文件夹内部文件的语义一致性 我们的目录结构都会有一个文件夹是按照路由模块来划分的，如pages文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且仅应该包含路由模块，而不应该有别的其他的非路由模块的文件夹 这样做的好处在于一眼就从 pages文件夹看出这个项目的路由有哪些 单一入口/出口 举个例子，在pages文件夹里面存在一个seller文件夹，这时候seller 文件夹应该作为一个独立的模块由外部引入，并且 seller/index.js 应该作为外部引入 seller 模块的唯一入口 // 错误用法 import sellerReducer from 'src/pages/seller/reducer' // 正确用法 import { reducer as sellerReducer } from 'src/pages/seller' 这样做的好处在于，无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离，如果后续有重构需求，你就会发现这种方式的优点 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用 使用相对路径可以保证模块内部的独立性 // 正确用法 import styles from './index.module.scss' // 错误用法 import styles from 'src/pages/seller/index.module.scss' 举个例子 假设我们现在的 seller 目录是在 src/pages/seller，如果我们后续发生了路由变更，需要加一个层级，变成 src/pages/user/seller。 如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，seller 文件夹内部不需要做任何变更。 但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 import 的路径做修改 公共的文件应该以绝对路径的方式从根目录引用 公共指的是多个路由模块共用，如一些公共的组件，我们可以放在src/components下 在使用到的页面中，采用绝对路径的形式引用 // 错误用法 import Input from '../../components/input' // 正确用法 import Input from 'src/components/input' 同样的，如果我们需要对文件夹结构进行调整。将 /src/components/input 变成 /src/components/new/input，如果使用绝对路径，只需要全局搜索替换 再加上绝对路径有全局的语义，相对路径有独立模块的语义 /src 外的文件不应该被引入 vue-cli脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个src文件夹，里面放着所有的项目需要的资源，js,css, png, svg 等等。src 外会放一些项目配置，依赖，环境等文件 这样的好处是方便划分项目代码文件和配置文件 二、目录结构 单页面目录结构 project │ .browserslistrc │ .env.production │ .eslintrc.js │ .gitignore │ babel.config.js │ package-lock.json │ package.json │ README.md │ vue.config.js │ yarn-error.log │ yarn.lock │ ├─public │ favicon.ico │ index.html │ |-- src |-- components |-- input |-- index.js |-- index.module.scss |-- pages |-- seller |-- components |-- input |-- index.js |-- index.module.scss |-- reducer.js |-- saga.js |-- index.js |-- index.module.scss |-- buyer |-- index.js |-- index.js 多页面目录结构 my-vue-test:. │ .browserslistrc │ .env.production │ .eslintrc.js │ .gitignore │ babel.config.js │ package-lock.json │ package.json │ README.md │ vue.config.js │ yarn-error.log │ yarn.lock │ ├─public │ favicon.ico │ index.html │ └─src ├─apis //接口文件根据页面或实例模块化 │ index.js │ login.js │ ├─components //全局公共组件 │ └─header │ index.less │ index.vue │ ├─config //配置（环境变量配置不同passid等） │ env.js │ index.js │ ├─contant //常量 │ index.js │ ├─images //图片 │ logo.png │ ├─pages //多页面vue项目，不同的实例 │ ├─index //主实例 │ │ │ index.js │ │ │ index.vue │ │ │ main.js │ │ │ router.js │ │ │ store.js │ │ │ │ │ ├─components //业务组件 │ │ └─pages //此实例中的各个路由 │ │ ├─amenu │ │ │ index.vue │ │ │ │ │ └─bmenu │ │ index.vue │ │ │ └─login //另一个实例 │ index.js │ index.vue │ main.js │ ├─scripts //包含各种常用配置，工具函数 │ │ map.js │ │ │ └─utils │ helper.js │ ├─store //vuex仓库 │ │ index.js │ │ │ ├─index │ │ actions.js │ │ getters.js │ │ index.js │ │ mutation-types.js │ │ mutations.js │ │ state.js │ │ │ └─user │ actions.js │ getters.js │ index.js │ mutation-types.js │ mutations.js │ state.js │ └─styles //样式统一配置 │ components.less │ ├─animation │ index.less │ slide.less │ ├─base │ index.less │ style.less │ var.less │ widget.less │ └─common index.less reset.less style.less transition.less 小结 项目的目录结构很重要，因为目录结构能体现很多东西，怎么规划目录结构可能每个人有自己的理解，但是按照一定的规范去进行目录的设计，能让项目整个架构看起来更为简洁，更加易用 参考文献 https://juejin.cn/post/6844904129186234381#heading-0 https://zhuanlan.zhihu.com/p/89693668 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/vnode.html":{"url":"笔记/web前端面试-面试官系列/vue/vnode.html","title":"Vnode","keywords":"","body":"面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路 一、什么是虚拟DOM 虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex） 实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上 在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别 创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应 在vue中同样使用到了虚拟DOM技术 定义真实DOM 节点内容 { { foo }} 实例化vue const app = new Vue({ el:\"#app\", data:{ foo:\"foo\" } }) 观察render的render，我们能得到虚拟DOM (function anonymous( ) { with(this){return _c('div',{attrs:{\"id\":\"app\"}},[_c('p',{staticClass:\"p\"}, [_v(\"节点内容\")]),_v(\" \"),_c('h3',[_v(_s(foo))])])}}) 通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能 二、为什么需要虚拟DOM DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的 真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： 由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验 举个例子： 你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程 当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程 而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI 三、如何实现虚拟DOM 首先可以看看vue中VNode的结构 源码位置：src/core/vdom/vnode.js export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor ( tag?: string, data?: VNodeData, children?: ?Array, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) { /*当前节点的标签名*/ this.tag = tag /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data /*当前节点的子节点，是一个数组*/ this.children = children /*当前节点的文本*/ this.text = text /*当前虚拟节点对应的真实dom节点*/ this.elm = elm /*当前节点的名字空间*/ this.ns = undefined /*编译作用域*/ this.context = context /*函数化组件作用域*/ this.functionalContext = undefined /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data && data.key /*组件的option选项*/ this.componentOptions = componentOptions /*当前节点对应的组件的实例*/ this.componentInstance = undefined /*当前节点的父节点*/ this.parent = undefined /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false /*静态节点标志*/ this.isStatic = false /*是否作为跟节点插入*/ this.isRootInsert = true /*是否为注释节点*/ this.isComment = false /*是否为克隆节点*/ this.isCloned = false /*是否有v-once指令*/ this.isOnce = false } // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next https://github.com/answershuto/learnVue*/ get child (): Component | void { return this.componentInstance } } 这里对VNode进行稍微的说明： 所有对象的 context 选项都指向了 Vue 实例 elm 属性则指向了其相对应的真实 DOM 节点 vue是通过createElement生成VNode 源码位置：src/core/vdom/create-element.js export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean ): VNode | Array { if (Array.isArray(data) || isPrimitive(data)) { normalizationType = children children = data data = undefined } if (isTrue(alwaysNormalize)) { normalizationType = ALWAYS_NORMALIZE } return _createElement(context, tag, data, children, normalizationType) } 上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断 export function _createElement( context: Component, tag?: string | Class | Function | Object, data?: VNodeData, children?: any, normalizationType?: number ): VNode | Array { if (isDef(data) && isDef((data: any).__ob__)) { process.env.NODE_ENV !== 'production' && warn( `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context` ) return createEmptyVNode() } // object syntax in v-bind if (isDef(data) && isDef(data.is)) { tag = data.is } if (!tag) { // in case of component :is set to falsy value return createEmptyVNode() } ... // support single function children as default scoped slot if (Array.isArray(children) && typeof children[0] === 'function' ) { data = data || {} data.scopedSlots = { default: children[0] } children.length = 0 } if (normalizationType === ALWAYS_NORMALIZE) { children = normalizeChildren(children) } else if ( === SIMPLE_NORMALIZE) { children = simpleNormalizeChildren(children) } // 创建VNode ... } 可以看到_createElement接收5个参数： context 表示 VNode 的上下文环境，是 Component 类型 tag 表示标签，它可以是一个字符串，也可以是一个 Component data 表示 VNode 的数据，它是一个 VNodeData 类型 children 表示当前 VNode的子节点，它是任意类型的 normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的 根据normalizationType 的类型，children会有不同的定义 if (normalizationType === ALWAYS_NORMALIZE) { children = normalizeChildren(children) } else if ( === SIMPLE_NORMALIZE) { children = simpleNormalizeChildren(children) } simpleNormalizeChildren方法调用场景是 render 函数是编译生成的 normalizeChildren方法调用场景分为下面两种： render 函数是用户手写的 编译 slot、v-for 的时候会产生嵌套数组 无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了 规范化children的源码位置在：src/core/vdom/helpers/normalzie-children.js 在规范化children后，就去创建VNode let vnode, ns // 对tag进行判断 if (typeof tag === 'string') { let Ctor ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // 如果是内置的节点，则直接创建一个普通VNode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // component // 如果是component类型，则会通过createComponent创建VNode节点 vnode = createComponent(Ctor, data, context, children, tag) } else { vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } createComponent同样是创建VNode 源码位置：src/core/vdom/create-component.js export function createComponent ( Ctor: Class | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array, tag?: string ): VNode | Array | void { if (isUndef(Ctor)) { return } // 构建子类构造函数 const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor) } // if at this stage it's not a constructor or an async component factory, // reject. if (typeof Ctor !== 'function') { if (process.env.NODE_ENV !== 'production') { warn(`Invalid Component definition: ${String(Ctor)}`, context) } return } // async component let asyncFactory if (isUndef(Ctor.cid)) { asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) { return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } } data = data || {} // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) // transform component v-model data into props & events if (isDef(data.model)) { transformModel(Ctor.options, data) } // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) { return createFunctionalComponent(Ctor, propsData, data, context, children) } // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier // so it gets processed during parent component patch. data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) { const slot = data.slot data = {} if (slot) { data.slot = slot } } // 安装组件钩子函数，把钩子函数合并到data.hook中 installComponentHooks(data) //实例化一个VNode返回。组件的VNode是没有children的 const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory ) if (__WEEX__ && isRecyclableComponent(vnode)) { return renderRecyclableComponentTemplate(vnode) } return vnode } 稍微提下createComponent生成VNode的三个关键流程： 构造子类构造函数Ctor installComponentHooks安装组件钩子函数 实例化 vnode 小结 createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构 参考文献 https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96 https://juejin.cn/post/6876711874050818061 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-14 17:32:59 "},"笔记/web前端面试-面试官系列/vue/vue.html":{"url":"笔记/web前端面试-面试官系列/vue/vue.html","title":"Vue","keywords":"","body":"面试官：有使用过vue吗？说说你对vue的理解 一、从历史说起 Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解 石器时代 文明时代 工业革命时代 百花齐放时代 石器时代 石器时代指的就是我们的静态网页，可以欣赏一下1997的Apple官网 最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互，如当时的Google（1998年） 文明时代 ASP，JSP大家应该都不会太陌生，最早出现于 2005 年左右，先后出现了微软的 ASP 和 Java Server Pages [JSP] 等技术,取代了 CGI ，增强了 WEB 与服务端的交互的安全性，类似于下面这样，其实就是Java + HTML ` pageEncoding=\"utf-8\"%> JSP demo ` JSP有一个很大的缺点，就是不太灵活，因为JSP是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回渲染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣在这种情况下，同年：Ajax火了(小细节，这里为什么说火了，因为 Ajax 技术并不是 2005 年出现的，他的雏形是 1999 年)，现在看来很常见的技术手段，在当时可是珍贵无比 工业革命时代 到这里大家就更熟悉了，移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度，我们可以称之其为工业时代 百花齐放时代 这里没有文字，放一张图感受一下 PS：这里为什么要说这么多Web的历史，我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？我们接着往下看 二、vue是什么 Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89\\%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互PS: Vue作者尤雨溪是在为AngularJS工作之后开发出了这一框架。他声称自己的思路是提取Angular中为自己所喜欢的部分，构建出一款相当轻量的框架最早发布于2014年2月 三、Vue核心特性 数据驱动（MVVM) MVVM表示的是 Model-View-ViewModel Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 这时候需要一张直观的关系图，如下 组件化 1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 指令系统 解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 常用的指令 条件渲染指令 v-if 列表渲染指令v-for 属性绑定指令v-bind 事件绑定指令v-on 双向数据绑定指令v-model 没有指令之前我们是怎么做的？是不是先要获取到DOM然后在....干点啥 四、Vue跟传统开发的区别 没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下 用jquery来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..) 用vue来实现，我们知道vue基本不操作dom节点， 双向绑定使dom节点跟视图绑定后，通过修改变量的值控制dom节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图 总结就是： Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM 五、Vue和React对比 这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同 相同点 都有组件化思想 都支持服务器端渲染 都有Virtual DOM（虚拟dom） 数据驱动视图 都有支持native的方案：Vue的weex、React的React native 都有自己的构建工具：Vue的vue-cli、React的Create React App 区别 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数 diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM 参考文献 https://segmentfault.com/a/1190000016269636 https://zh.wikipedia.org/zh-cn/Vue.js https://zhuanlan.zhihu.com/p/20197803 https://zhuanlan.zhihu.com/p/38296857 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/vue/vue3_vue2.html":{"url":"笔记/web前端面试-面试官系列/vue/vue3_vue2.html","title":"Vue3 Vue2","keywords":"","body":"面试官：vue3有了解过吗？能说说跟vue2的区别吗？ 一、Vue3介绍 关于vue3的重构背景，尤大是这样说的： 「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了 在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」 简要就是： 利用新的语言特性(es6) 解决架构问题 哪些变化 从上图中，我们可以概览Vue3的新特性，如下： 速度更快 体积减少 更易维护 更接近原生 更易使用 速度更快 vue3相比vue2 重写了虚拟Dom实现 编译模板的优化 更高效的组件初始化 undate性能提高1.3~2倍 SSR速度提高了2~3倍 体积更小 通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的 能够tree-shaking，有两大好处： 对开发人员，能够对vue实现更多其他的功能，而不必担忧整体体积过大 对使用者，打包出来的包体积变小了 vue可以开发出更多其他的功能，而不必担忧vue打包出来的整体体积过多 更易维护 compositon Api 可与现有的Options API一起使用 灵活的逻辑组合与复用 Vue3模块可以和其他框架搭配使用 更好的Typescript支持 VUE3是基于typescipt编写的，可以享受到自动的类型定义提示 编译器重写 更接近原生 可以自定义渲染 API 更易使用 响应式 Api 暴露出来 轻松识别组件重新渲染原因 二、Vue3新增特性 Vue 3 中需要关注的一些新功能包括： framents Teleport composition Api createRenderer framents 在 Vue3.x 中，组件现在支持有多个根节点 ... ... ... Teleport Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术，就有点像哆啦A梦的“任意门” 在vue2中，像 modals,toast 等这样的元素，如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位、z-index 和样式就会变得很困难 通过Teleport，我们可以在组件的逻辑位置写模板代码，然后在 Vue 应用范围之外渲染它 打开 toast 我是一个 Toast 文案 createRenderer 通过createRenderer，我们能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台 我们可以将其生成在canvas画布上 关于createRenderer，我们了解下基本使用，就不展开讲述了 import { createRenderer } from '@vue/runtime-core' const { render, createApp } = createRenderer({ patchProp, insert, remove, createElement, // ... }) export { render, createApp } export * from '@vue/runtime-core' composition Api composition Api，也就是组合式api，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理 关于compositon api的使用，这里以下图展开 简单使用: export default { setup() { const count = ref(0) const double = computed(() => count.value * 2) function increment() { count.value++ } onMounted(() => console.log('component mounted!')) return { count, double, increment } } } 三、非兼容变更 Global API 全局 Vue API 已更改为使用应用程序实例 全局和内部 API 已经被重构为可 tree-shakable 模板指令 组件上 v-model 用法已更改 和 非 v-for节点上key用法已更改 在同一元素上使用的 v-if 和 v-for 优先级已更改 v-bind=\"object\" 现在排序敏感 v-for 中的 ref 不再注册 ref 数组 组件 只能使用普通函数创建功能组件 functional 属性在单文件组件 (SFC) 异步组件现在需要 defineAsyncComponent 方法来创建 渲染函数 渲染函数API改变 $scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露 自定义指令 API 已更改为与组件生命周期一致 一些转换 class 被重命名了： v-enter -> v-enter-from v-leave -> v-leave-from 组件 watch 选项和实例方法 $watch不再支持点分隔字符串路径，请改用计算函数作为参数 在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。VUE3.x 现在使用应用程序容器的 innerHTML。 其他小改变 destroyed 生命周期选项被重命名为 unmounted beforeDestroy 生命周期选项被重命名为 beforeUnmount [prop default工厂函数不再有权访问 this 是上下文 自定义指令 API 已更改为与组件生命周期一致 data 应始终声明为函数 来自 mixin 的 data 选项现在可简单地合并 attribute 强制策略已更改 一些过渡 class 被重命名 组建 watch 选项和实例方法 $watch不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 元素，而不是渲染其内部内容。 在Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。 移除 API keyCode 支持作为 v-on 的修饰符 $on，$off和$once 实例方法 过滤filter 内联模板 attribute $destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。 参考文献 https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4 https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/HMR.html":{"url":"笔记/web前端面试-面试官系列/webpack/HMR.html","title":"HMR","keywords":"","body":"面试官：说说webpack的热更新是如何做到的？原理是什么？ 一、是什么 HMR全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用 例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失 如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用 在webpack中配置开启热模块也非常的简单，如下代码： const webpack = require('webpack') module.exports = { // ... devServer: { // 开启 HMR 特性 hot: true // hotOnly: true } } 通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中 但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块 所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作 我们需要去指定哪些模块发生更新时进行HRM，如下代码： if(module.hot){ module.hot.accept('./util.js',()=>{ console.log(\"util.js更新了\") }) } 二、实现原理 首先来看看一张图，如下： Webpack Compile：将 JS 源代码编译成 bundle.js HMR Server：用来将热更新的文件输出给 HMR Runtime Bundle Server：静态资源文件服务器，提供文件访问路径 HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化 bundle.js：构建输出的文件 在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化 上面图中，可以分成两个阶段： 启动阶段为上图 1 - 2 - A - B 在编写未经过webpack打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle文件，传输给Bundle Server 静态资源服务器 更新阶段为上图 1 - 2 - 3 - 4 当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识 根据变化的内容生成两个补丁文件：manifest（包含了 hash 和 chundId，用来说明变化的内容）和chunk.js 模块 由于socket服务器在HMR Runtime 和 HMR Server之间建立 websocket链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，作为下一次热更细的标识 在浏览器接受到这条消息之前，浏览器已经在上一次socket 消息中已经记住了此时的hash 标识，这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件 mainfest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性 浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程，实现局部模块更新 三、总结 关于webpack热模块更新的总结如下： 通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务 express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析） socket server 是一个 websocket 的长连接，双方可以通信 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk） 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器） 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新 参考文献 https://zhuanlan.zhihu.com/p/138446061 https://github.com/Jocs/jocs.github.io/issues/15 https://juejin.cn/post/6844904134697549832 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/Loader.html":{"url":"笔记/web前端面试-面试官系列/webpack/Loader.html","title":"Loader","keywords":"","body":"面试官：说说webpack中常见的Loader？解决了什么问题？ 一、是什么 loader 用于对模块的\"源代码\"进行转换，在 import 或\"加载\"模块时预处理文件 webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示： 在webpack内部中，任何文件都是模块，不仅仅只是js文件 默认情况下，在遇到import或者require加载模块的时候，webpack只支持对js 和 json 文件打包 像css、sass、png等这些类型的文件的时候，webpack则无能为力，这时候就需要配置对应的loader进行文件内容的解析 在加载模块的时候，执行顺序如下： 当 webpack 碰到不识别的模块的时候，webpack 会在配置的中查找该文件解析规则 关于配置loader的方式有三种： 配置方式（推荐）：在 webpack.config.js文件中指定 loader 内联方式：在每个 import 语句中显式指定 loader CLI 方式：在 shell 命令中指定它们 配置方式 关于loader的配置，我们是写在module.rules属性中，属性介绍如下： rules是一个数组的形式，因此我们可以配置很多个loader 每一个loader对应一个对象的形式，对象属性test 为匹配的规则，一般情况为正则表达式 属性use针对匹配到文件类型，调用对应的 loader 进行处理 代码编写，如下形式： module.exports = { module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } }, { loader: 'sass-loader' } ] } ] } }; 二、特性 这里继续拿上述代码，来讲讲loader的特性 从上述代码可以看到，在处理css模块的时候，use属性中配置了三个loader分别处理css文件 因为loader支持链式调用，链中的每个loader会处理之前已处理过的资源，最终变为js代码。顺序为相反的顺序执行，即上述执行方式为sass-loader、css-loader、style-loader 除此之外，loader的特性还有如下： loader 可以是同步的，也可以是异步的 loader 运行在 Node.js 中，并且能够执行任何操作 除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块 插件(plugin)可以为 loader 带来更多特性 loader 能够产生额外的任意文件 可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性 三、常见的loader 在页面开发过程中，我们经常性加载除了js文件以外的内容，这时候我们就需要配置响应的loader进行加载 常见的loader如下： style-loader: 将css添加到DOM的内联样式标签style里 css-loader :允许将css文件通过require的方式引入，并返回css代码 less-loader: 处理less sass-loader: 处理sass postcss-loader: 用postcss来处理CSS autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss file-loader: 分发文件到output目录并返回相对路径 url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url html-minify-loader: 压缩HTML babel-loader :用babel来转换ES6文件到ES 下面给出一些常见的loader的使用： css-loader 分析 css 模块之间的关系，并合成⼀个 css npm install --save-dev css-loader rules: [ ..., { test: /\\.css$/, use: { loader: \"css-loader\", options: { // 启用/禁用 url() 处理 url: true, // 启用/禁用 @import 处理 import: true, // 启用/禁用 Sourcemap sourceMap: false } } } ] 如果只通过css-loader加载文件，这时候页面代码设置的样式并没有生效 原因在于，css-loader只是负责将.css文件进行一个解析，而并不会将解析后的css插入到页面中 如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader style-loader 把 css-loader 生成的内容，用 style 标签挂载到页面的 head 中 npm install --save-dev style-loader rules: [ ..., { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] } ] 同一个任务的 loader 可以同时挂载多个，处理顺序为：从右到左，从下往上 less-loader 开发中，我们也常常会使用less、sass、stylus预处理器编写css样式，使开发效率提高，这里需要使用less-loader npm install less-loader -D rules: [ ..., { test: /\\.css$/, use: [\"style-loader\", \"css-loader\",\"less-loader\"] } ] raw-loader 在 webpack中通过 import方式导入文件内容，该loader并不是内置的，所以首先要安装 npm install --save-dev raw-loader 然后在 webpack.config.js 中进行配置 module.exports = { ..., module: { rules: [ { test: /\\.(txt|md)$/, use: 'raw-loader' } ] } } file-loader 把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串) npm install --save-dev file-loader rules: [ ..., { test: /\\.(png|jpe?g|gif)$/, use: { loader: \"file-loader\", options: { // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: \"[name]_[hash].[ext]\", //打包后的存放位置 outputPath: \"./images\", // 打包后文件的 url publicPath: './images', } } } ] url-loader 可以处理理 file-loader 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，对小体积的图片比较合适，大图片不合适。 npm install --save-dev url-loader rules: [ ..., { test: /\\.(png|jpe?g|gif)$/, use: { loader: \"url-loader\", options: { // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: \"[name]_[hash].[ext]\", //打包后的存放位置 outputPath: \"./images\" // 打包后文件的 url publicPath: './images', // 小于 100 字节转成 base64 格式 limit: 100 } } } ] 参考文献 https://webpack.docschina.org/concepts/loaders/ https://segmentfault.com/a/1190000018680530 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/Loader_Plugin.html":{"url":"笔记/web前端面试-面试官系列/webpack/Loader_Plugin.html","title":"Loader Plugin","keywords":"","body":"面试官：说说Loader和Plugin的区别？编写Loader，Plugin的思路？ 一、区别 前面两节我们有提到Loader与Plugin对应的概念，先来回顾下 loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中 plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事 从整个运行时机上来看，如下图所示： 可以看到，两者在运行时机上的区别： loader 运行在打包文件之前 plugins 在整个编译周期都起作用 在Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API改变输出结果 对于loader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程 二、编写loader 在编写 loader 前，我们首先需要了解 loader 的本质 其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader设为一个箭头函数 函数接受一个参数，为 webpack 传递给 loader 的文件源内容 函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息 函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer 代码如下所示： // 导出一个函数，source为webpack传递给loader的文件源内容 module.exports = function(source) { const content = doSomeThing2JsString(source); // 如果 loader 配置了 options 对象，那么this.query将指向 options const options = this.query; // 可以用作解析其他模块路径的上下文 console.log('this.context'); /* * this.callback 参数： * error：Error | null，当 loader 出错时向外抛出一个 error * content：String | Buffer，经过 loader 编译后需要导出的内容 * sourceMap：为方便调试生成的编译后内容的 source map * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程 */ this.callback(null, content); // 异步 return content; // 同步 } 一般在编写loader的过程中，保持功能单一，避免做多种功能 如less文件转换成 css文件也不是一步到位，而是 less-loader、css-loader、style-loader几个 loader的链式调用才能完成转换 三、编写plugin 由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务 在之前也了解过，webpack编译会创建两个核心对象： compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子 compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建 如果自己要实现plugin，也需要遵循一定的规范： 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问compiler实例 传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住 实现plugin的模板如下： class MyPlugin { // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply (compiler) { // 找到合适的事件钩子，实现自己的插件功能 compiler.hooks.emit.tap('MyPlugin', compilation => { // compilation: 当前打包构建流程的上下文 console.log(compilation); // do something... }) } } 在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容 参考文献 https://webpack.docschina.org/api/loaders/ https://webpack.docschina.org/api/compiler-hooks/ https://segmentfault.com/a/1190000039877943 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/Plugin.html":{"url":"笔记/web前端面试-面试官系列/webpack/Plugin.html","title":"Plugin","keywords":"","body":"面试官：说说webpack中常见的Plugin？解决了什么问题？ 一、是什么 Plugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能 是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据 webpack中的plugin也是如此，plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期 目的在于解决loader 无法实现的其他事 配置方式 这里讲述文件的配置方式，一般情况，通过配置文件导出对象中plugins属性传入new实例对象。如下所示： const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装 const webpack = require('webpack'); // 访问内置的插件 module.exports = { ... plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin({ template: './src/index.html' }), ], }; 二、特性 其本质是一个具有apply方法javascript对象 apply 方法会被 webpack compiler调用，并且在整个编译生命周期都可以访问 compiler对象 const pluginName = 'ConsoleLogOnBuildWebpackPlugin'; class ConsoleLogOnBuildWebpackPlugin { apply(compiler) { compiler.hooks.run.tap(pluginName, (compilation) => { console.log('webpack 构建过程开始！'); }); } } module.exports = ConsoleLogOnBuildWebpackPlugin; compiler hook 的 tap方法的第一个参数，应是驼峰式命名的插件名称 关于整个编译生命周期钩子，有如下： entry-option ：初始化 option run compile： 真正开始的编译，在创建 compilation 对象之前 compilation ：生成好了 compilation 对象 make 从 entry 开始递归分析依赖，准备对每个模块进行 build after-compile： 编译 build 过程结束 emit ：在将内存中 assets 内容写到磁盘文件夹之前 after-emit ：在将内存中 assets 内容写到磁盘文件夹之后 done： 完成所有的编译过程 failed： 编译失败的时候 三、常见的Plugin 常见的plugin有如图所示： 下面介绍几个常用的插件用法： HtmlWebpackPlugin 在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的js 模块引⼊到该 html 中 npm install --save-dev html-webpack-plugin // webpack.config.js const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = { ... plugins: [ new HtmlWebpackPlugin({ title: \"My App\", filename: \"app.html\", template: \"./src/html/index.html\" }) ] }; html-webpack-plugin 在 html 模板中，可以通过 的方式获取配置的值 更多的配置可以自寻查找 clean-webpack-plugin 删除（清理）构建目录 npm install --save-dev clean-webpack-plugin const {CleanWebpackPlugin} = require('clean-webpack-plugin'); module.exports = { ... plugins: [ ..., new CleanWebpackPlugin(), ... ] } mini-css-extract-plugin 提取 CSS 到一个单独的文件中 npm install --save-dev mini-css-extract-plugin const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = { ..., module: { rules: [ { test: /\\.s[ac]ss$/, use: [ { loader: MiniCssExtractPlugin.loader }, 'css-loader', 'sass-loader' ] } ] }, plugins: [ ..., new MiniCssExtractPlugin({ filename: '[name].css' }), ... ] } DefinePlugin 允许在编译时创建配置的全局对象，是一个webpack内置的插件，不需要安装 const { DefinePlugun } = require('webpack') module.exports = { ... plugins:[ new DefinePlugin({ BASE_URL:'\"./\"' }) ] } 这时候编译template模块的时候，就能通过下述形式获取全局对象 favicon.ico>\" copy-webpack-plugin 复制文件或目录到执行区域，如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中 npm install copy-webpack-plugin -D new CopyWebpackPlugin({ parrerns:[ { from:\"public\", globOptions:{ ignore:[ '**/index.html' ] } } ] }) 复制的规则在patterns属性中设置： from：设置从哪一个源中开始复制 to：复制到的位置，可以省略，会默认复制到打包的目录下 globOptions：设置一些额外的选项，其中可以编写需要忽略的文件 参考文献 https://webpack.docschina.org/concepts/plugins/ https://baike.baidu.com/item/Plugin https://segmentfault.com/a/1190000018695134 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/Rollup_Parcel_snowpack_Vite.html":{"url":"笔记/web前端面试-面试官系列/webpack/Rollup_Parcel_snowpack_Vite.html","title":"Rollup Parcel Snowpack Vite","keywords":"","body":"面试官：与webpack类似的工具还有哪些？区别？ 一、模块化工具 模块化是一种处理复杂系统分解为更好的可管理模块的方式 可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(bundle) 在前端领域中，并非只有webpack这一款优秀的模块打包工具，还有其他类似的工具，例如Rollup、Parcel、snowpack，以及最近风头无两的Vite 通过这些模块打包工具，能够提高我们的开发效率，减少开发成本 这里没有提及gulp、grunt是因为它们只是定义为构建工具，不能类比 Rollup Rollup 是一款 ES Modules 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多 现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等 举个例子： // ./src/messages.js export default { hi: 'Hey Guys, I am zce~' } // ./src/logger.js export const log = msg => { console.log('---------- INFO ----------') console.log(msg) console.log('--------------------------') } export const error = msg => { console.error('---------- ERROR ----------') console.error(msg) console.error('---------------------------') } // ./src/index.js import { log } from './logger' import messages from './messages' log(messages.hi) 然后通过rollup进行打包 $ npx rollup ./src/index.js --file ./dist/bundle.js 打包结果如下图 可以看到，代码非常简洁，完成不像webpack那样存在大量引导代码和模块函数 并且error方法由于没有被使用，输出的结果中并无error方法，可以看到，rollup默认开始Tree-shaking 优化输出结果 因此，可以看到Rollup的优点： 代码效率更简洁、效率更高 默认支持 Tree-shaking 但缺点也十分明显，加载其他类型的资源文件或者支持导入 CommonJS 模块，又或是编译 ES 新特性，这些额外的需求 Rollup需要使用插件去完成 综合来看，rollup并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用CommonJs方式导出成员，并且rollup不支持HMR，使开发效率降低 但是在用于打包JavaScript 库时，rollup比 webpack 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略 Parcel Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序 Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。如下所示： Parcel Tutorials main.js文件通过ES Moudle方法导入其他模块成员 // ./src/main.js import { log } from './logger' log('hello parcel') // ./src/logger.js export const log = msg => { console.log('---------- INFO ----------') console.log(msg) } 运行之后，使用命令打包 npx parcel src/index.html 执行命令后，Parcel不仅打包了应用，同时也启动了一个开发服务器，跟webpack Dev Server一样 跟webpack类似，也支持模块热替换，但用法更简单 同时，Parcel有个十分好用的功能：支持自动安装依赖，像webpack开发阶段突然使用安装某个第三方依赖，必然会终止dev server然后安装再启动。而Parcel则免了这繁琐的工作流程 同时，Parcel能够零配置加载其他类型的资源文件，无须像webpack那样配置对应的loader 打包命令如下： npx parcel src/index.html 由于打包过程是多进程同时工作，构建速度会比Webpack 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中 可以感受到，Parcel给开发者一种很大的自由度，只管去实现业务代码，其他事情用Parcel解决 Snowpack Snowpack，是一种闪电般快速的前端构建工具，专为现代Web设计，较复杂的打包工具（如Webpack或Parcel）的替代方案，利用JavaScript的本机模块系统，避免不必要的工作并保持流畅的开发体验 开发阶段，每次保存单个文件时，Webpack和Parcel都需要重新构建和重新打包应用程序的整个bundle。而Snowpack为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，Snowpack会重新构建该单个文件 下图给出webpack与snowpack打包区别： 在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新 Vite vite ，是一种新型前端构建工具，能够显著提升前端开发体验 它主要由两部分组成： 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源 其作用类似webpack+ webpack-dev-server，其特点如下： 快速的冷启动 即时的模块热更新 真正的按需编译 vite会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快 利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间 原理图如下所示： 在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高 webpack 相比上述的模块化工具，webpack大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载 与其他构建工具相比，有如下优势： 智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容 万物模块：对 js、css、图片等资源文件都支持打包 开箱即用：HRM、Tree-shaking等功能 代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间 插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性 易于调试：支持 SourceUrls 和 SourceMaps 快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快 生态环境好：社区更丰富，出现的问题更容易解决 参考文献 https://zhuanlan.zhihu.com/p/95684686 https://cn.vitejs.dev/guide/ https://segmentfault.com/a/1190000039370642 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/build_process.html":{"url":"笔记/web前端面试-面试官系列/webpack/build_process.html","title":"Build Process","keywords":"","body":"面试官：说说webpack的构建流程? 一、运行流程 webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好 从启动到结束会依次执行以下三大步骤： 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统 初始化流程 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 配置文件默认下为webpack.config.js，也或者通过命令的形式指定配置文件，主要作用是用于激活webpack的加载项和插件 关于文件配置内容分析，如下注释： var path = require('path'); var node_modules = path.resolve(__dirname, 'node_modules'); var pathToReact = path.resolve(node_modules, 'react/dist/react.min.js'); module.exports = { // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。 entry: './path/to/my/entry/file.js'， // 文件路径指向(可加快打包过程)。 resolve: { alias: { 'react': pathToReact } }, // 生成文件，是模块构建的终点，包括输出文件与输出路径。 output: { path: path.resolve(__dirname, 'build'), filename: '[name].js' }, // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。 module: { loaders: [ { test: /\\.js$/, loader: 'babel', query: { presets: ['es2015', 'react'] } } ], noParse: [pathToReact] }, // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。 plugins: [ new webpack.HotModuleReplacementPlugin() ] }; webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的 plugins 完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack声明周期，不执行具体的任务，只是进行一些调度工作 class Compiler extends Tapable { constructor(context) { super(); this.hooks = { beforeCompile: new AsyncSeriesHook([\"params\"]), compile: new SyncHook([\"params\"]), afterCompile: new AsyncSeriesHook([\"compilation\"]), make: new AsyncParallelHook([\"compilation\"]), entryOption: new SyncBailHook([\"context\", \"entry\"]) // 定义了很多不同类型的钩子 }; // ... } } function webpack(options) { var compiler = new Compiler(); ...// 检查options,若watch字段为true,则开启watch线程 return compiler; } ... Compiler 对象继承自 Tapable，初始化时定义了很多钩子函数 编译构建流程 根据配置中的 entry 找出所有的入口文件 module.exports = { entry: './src/file.js' } 初始化完成后会调用Compiler的run来真正启动webpack编译构建流程，主要流程如下： compile 开始编译 make 从入口点分析模块及其依赖的模块，创建这些模块对象 build-module 构建模块 seal 封装构建结果 emit 把各个chunk输出到结果文件 compile 编译 执行了run方法后，首先会触发compile，主要是构建一个Compilation对象 该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象 make 编译模块 当完成了上述的compilation对象后，就开始从Entry入口文件开始读取，主要执行_addModuleChain()函数，如下： _addModuleChain(context, dependency, onModule, callback) { ... // 根据依赖查找对应的工厂函数 const Dep = /** @type {DepConstructor} */ (dependency.constructor); const moduleFactory = this.dependencyFactories.get(Dep); // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象 moduleFactory.create({ dependencies: [dependency] ... }, (err, module) => { ... const afterBuild = () => { this.processModuleDependencies(module, err => { if (err) return callback(err); callback(null, module); }); }; this.buildModule(module, false, null, null, err => { ... afterBuild(); }) }) } 过程如下： _addModuleChain中接收参数dependency传入的入口依赖，使用对应的工厂函数NormalModuleFactory.create方法生成一个空的module对象 回调中会把此module存入compilation.modules对象和dependencies.module对象中，由于是入口文件，也会存入compilation.entries中 随后执行buildModule进入真正的构建模块module内容的过程 build module 完成模块编译 这里主要调用配置的loaders，将我们的模块转成标准的JS模块 在用Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack后面对代码的分析 从配置的入口模块开始，分析其 AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系 输出流程 seal 输出资源 seal方法主要是要生成chunks，对chunks进行一系列的优化操作，并生成要输出的代码 webpack 中的 chunk ，可以理解为配置在 entry 中的模块，或者是动态引入的模块 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表 emit 输出完成 在确定好输出内容后，根据配置确定输出的路径和文件名 output: { path: path.resolve(__dirname, 'build'), filename: '[name].js' } 在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会 从而webpack整个打包过程则结束了 小结 参考文献 https://github.com/Cosen95/blog/issues/48 https://developer.aliyun.com/article/61047 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/improve_build.html":{"url":"笔记/web前端面试-面试官系列/webpack/improve_build.html","title":"Improve Build","keywords":"","body":"面试官：如何提高webpack的构建速度？ 一、背景 随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 webpack 的构建时间也会越来越久 构建时间与我们日常开发效率密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率 所以，优化webpack 构建速度是十分重要的环节 二、如何优化 常见的提升构建速度的手段有如下： 优化 loader 配置 合理使用 resolve.extensions 优化 resolve.modules 优化 resolve.alias 使用 DLLPlugin 插件 使用 cache-loader terser 启动多线程 合理使用 sourceMap 优化loader配置 在使用loader时，可以通过配置include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader 如采用 ES6 的项目为例，在配置 babel-loader时，可以这样： module.exports = { module: { rules: [ { // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 use: ['babel-loader?cacheDirectory'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), }, ] }, }; 合理使用 resolve.extensions 在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码 通过resolve.extensions是解析到文件时自动添加拓展名，默认情况如下： module.exports = { ... extensions:[\".warm\",\".mjs\",\".js\",\".json\"] } 当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找 当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度 优化 resolve.modules resolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块。默认值为['node_modules']，所以默认会从node_modules中查找文件 当安装的第三方模块都放在项目根目录下的 ./node_modules目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下： module.exports = { resolve: { // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')] }, }; 优化 resolve.alias alias给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是./../../的形式 通过配置alias以减少查找过程 module.exports = { ... resolve:{ alias:{ \"@\":path.resolve(__dirname,'./src') } } } 使用 DLLPlugin 插件 DLL全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中 使用步骤分成两部分： 打包一个 DLL 库 引入 DLL 库 打包一个 DLL 库 webpack内置了一个DllPlugin可以帮助我们打包一个DLL的库文件 module.exports = { ... plugins:[ new webpack.DllPlugin({ name:'dll_[name]', path:path.resolve(__dirname,\"./dll/[name].mainfest.json\") }) ] } 引入 DLL 库 使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库 然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中 module.exports = { ... new webpack.DllReferencePlugin({ context:path.resolve(__dirname,\"./dll/dll_react.js\"), mainfest:path.resolve(__dirname,\"./dll/react.mainfest.json\") }), new AddAssetHtmlPlugin({ outputPath:\"./auto\", filepath:path.resolve(__dirname,\"./dll/dll_react.js\") }) } 使用 cache-loader 在一些性能开销较大的 loader之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度 保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此loader module.exports = { module: { rules: [ { test: /\\.ext$/, use: ['cache-loader', ...loaders], include: path.resolve('src'), }, ], }, }; terser 启动多线程 使用多进程并行运行来提高构建速度 module.exports = { optimization: { minimizer: [ new TerserPlugin({ parallel: true, }), ], }, }; 合理使用 sourceMap 打包生成 sourceMap 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示： 三、总结 可以看到，优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手 参考文献 https://github.com/ly2011/blog/issues/44 https://xie.infoq.cn/article/541418eb82a674741a0ad8865 https://zhuanlan.zhihu.com/p/139498741 https://vue3js.cn/interview 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/performance.html":{"url":"笔记/web前端面试-面试官系列/webpack/performance.html","title":"Performance","keywords":"","body":"面试官：说说如何借助webpack来优化前端性能？ 一、背景 随着前端的项目逐渐扩大，必然会带来的一个问题就是性能 尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃 一般项目在完成后，会通过webpack进行打包，利用webpack对前端项目性能优化是一个十分重要的环节 二、如何优化 通过webpack优化前端的手段有： JS代码压缩 CSS代码压缩 Html文件代码压缩 文件大小压缩 图片压缩 Tree Shaking 代码分离 内联 chunk JS代码压缩 terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小 在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下： const TerserPlugin = require('terser-webpack-plugin') module.exports = { ... optimization: { minimize: true, minimizer: [ new TerserPlugin({ parallel: true // 电脑cpu核数-1 }) ] } } 属性介绍如下： extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换 keep_classnames：保留类的名称 keep_fnames：保留函数的名称 CSS代码压缩 CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等 CSS的压缩我们可以使用另外一个插件：css-minimizer-webpack-plugin npm install css-minimizer-webpack-plugin -D 配置方法如下： const CssMinimizerPlugin = require('css-minimizer-webpack-plugin') module.exports = { // ... optimization: { minimize: true, minimizer: [ new CssMinimizerPlugin({ parallel: true }) ] } } Html文件代码压缩 使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化 module.exports = { ... plugin:[ new HtmlwebpackPlugin({ ... minify:{ minifyCSS:false, // 是否压缩css collapseWhitespace:false, // 是否折叠空格 removeComments:true // 是否移除注释 } }) ] } 设置了minify，实际会使用另一个插件html-minifier-terser 文件大小压缩 对文件的大小进行压缩，减少http传输过程中宽带的损耗 npm install compression-webpack-plugin -D new ComepressionPlugin({ test:/\\.(css|js)$/, // 哪些文件需要压缩 threshold:500, // 设置文件多大开始压缩 minRatio:0.7, // 至少压缩的比例 algorithm:\"gzip\", // 采用的压缩算法 }) 图片压缩 一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要 配置方法如下： module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: { name: '[name]_[hash].[ext]', outputPath: 'images/', } }, { loader: 'image-webpack-loader', options: { // 压缩 jpeg 的配置 mozjpeg: { progressive: true, quality: 65 }, // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭 optipng: { enabled: false, }, // 使用 imagemin-pngquant 压缩 png pngquant: { quality: '65-90', speed: 4 }, // 压缩 gif 的配置 gifsicle: { interlaced: false, }, // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 webp: { quality: 75 } } } ] }, ] } Tree Shaking Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系） 在webpack实现Trss shaking有两种不同的方案： usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用 两种不同的配置方案， 有不同的效果 usedExports 配置方法也很简单，只需要将usedExports设为true module.exports = { ... optimization:{ usedExports } } 使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码 如下面sum函数没被用到，webpack打包会添加注释，terser在优化时，则将该函数去掉 sideEffects sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性 如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports 如果有些文件需要保留，可以设置为数组的形式 \"sideEffecis\":[ \"./src/util/format.js\", \"*.css\" // 所有的css文件 ] 上述都是关于javascript的tree shaking，css同样也能够实现tree shaking css tree shaking css进行tree shaking优化可以安装PurgeCss插件 npm install purgecss-plugin-webpack -D const PurgeCssPlugin = require('purgecss-webpack-plugin') module.exports = { ... plugins:[ new PurgeCssPlugin({ path:glob.sync(`${path.resolve('./src')}/**/*`), {nodir:true}// src里面的所有文件 satelist:function(){ return { standard:[\"html\"] } } }) ] } paths：表示要检测哪些目录下的内容需要被分析，配合使用glob 默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性 代码分离 将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度 代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能 这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可 默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all module.exports = { ... optimization:{ splitChunks:{ chunks:\"all\" } } } splitChunks主要属性有如下： Chunks，对同步代码还是异步代码进行处理 minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 maxSize： 将大于maxSize的包，拆分为不小于minSize的包 minChunks：被引入的次数，默认是1 内联chunk 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的 const InlineChunkHtmlPlugin = require('react-dev-utils/InlineChunkHtmlPlugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { ... plugin:[ new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\\.js/] } 三、总结 关于webpack对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化 参考文献 https://zhuanlan.zhihu.com/p/139498741 https://vue3js.cn/interview/ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/proxy.html":{"url":"笔记/web前端面试-面试官系列/webpack/proxy.html","title":"Proxy","keywords":"","body":"面试官：说说webpack proxy工作原理？为什么能解决跨域? 一、是什么 webpack proxy，即webpack提供的代理服务 基本行为就是接收客户端发送的请求后转发给其他服务器 其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制） 想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server webpack-dev-server webpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起 目的是为了提高开发者日常的开发效率，只适用在开发阶段 关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下： // ./webpack.config.js const path = require('path') module.exports = { // ... devServer: { contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000, proxy: { '/api': { target: 'https://api.github.com' } } // ... } } devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下： target：表示的是代理到的目标地址 pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false changeOrigin：它表示是否更新代理后请求的 headers 中host地址 二、工作原理 proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 举个例子： 在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中 const express = require('express'); const proxy = require('http-proxy-middleware'); const app = express(); app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true})); app.listen(3000); // http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar 三、跨域 在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost的一个端口上，而后端服务又是运行在另外一个地址上 所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题 通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地 在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据 注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制 参考文献 https://webpack.docschina.org/configuration/dev-server/#devserverproxy 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"笔记/web前端面试-面试官系列/webpack/webpack.html":{"url":"笔记/web前端面试-面试官系列/webpack/webpack.html","title":"Webpack","keywords":"","body":"面试官：说说你对webpack的理解？解决了什么问题？ 一、背景 Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源 模块化 最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的JS 文件中 约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后调用模块化的成员 但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题 项目一旦变大，上述问题会尤其明显 随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中 window.moduleA = { method1: function () { console.log('moduleA#method1') } } 这种方式也并没有解决第一种方式的依赖等问题 再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下 // module-a.js (function ($) { var name = 'module-a' function method1 () { console.log(name + '#method1') $('body').animate({ margin: '200px' }) } window.moduleA = { method1: method1 } })(jQuery) 上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过script标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦 理想的解决方式是，在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载进来 除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是CommonJS、ES Modules 二、问题 从后端渲染的JSP、PHP，到前端原生JavaScript，再到jQuery开发，再到目前的三大框架Vue、React、Angular 开发方式，也从javascript到后面的es5、es6、7、8、9、10，再到typescript，包括编写CSS的预处理器less、scss等 现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题： 需要通过模块化的方式来开发 使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码 监听文件的变化来并且反映到浏览器上，提高开发的效率 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题 开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化 而webpack恰巧可以解决以上问题 三、是什么 webpack 是一个用于现代JavaScript应用程序的静态模块打包工具 静态模块 这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进bundle.js的资源） 当 webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle webpack的能力： 编译代码能力，提高效率，解决浏览器兼容问题 模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题 万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 参考文献 https://webpack.docschina.org/concepts/ https://zhuanlan.zhihu.com/p/267875652 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2021-11-24 23:14:13 "},"随笔/idea/windows用mklink转移c盘文件.html":{"url":"随笔/idea/windows用mklink转移c盘文件.html","title":"Windows用Mklink转移C盘文件","keywords":"","body":"符号链接是在文件系统上实现的链接，对操作系统上大多数软件来说是透明的，也就是说，当软件访问符号链接时，其实际上是在访问该符号链接所指向的文件(夹) 注意：软链接的创建需要管理员权限，确保cmd是管理员模式。对于文件夹的软链接创建，一定要加上\"/D\"。通过相对路径创建的软链接在移动后无法使用，绝对路径创建的移动后不影响使用。符号链接可以直接右键删除，或通过rmdir命令删除，不会影响原文件，但del命令则会把目标文件删除。 创建的符号链接显示的类型是文件夹，实际上相当于是指向D盘真实的resource路径的快捷方式，符号链接本身不占空间。 路径映射的过程对迅雷来说是透明的，迅雷对这个符号链接的操作实际上是对resource文件夹的操作，因此迅雷可以正常运行。 另外，符号链接和目录联接是有快捷方式的那个箭头的，只不过我修改了注册表所以这里不显示。 符号链接与Linux下的软链接很相似，因此网上很多资料都会把ntfs的符号链接叫做软链接。 用Disk Space Fan 4对C盘进行扫描，发现Adobe的数据文件占用了1G多的空间，而这些数据根本用不着放固态浪费空间，于是可以把这个文件夹剪切到D盘合适路径下，这个路径由自己决定，放哪都可以。 因为这个文件夹放在“C:ProgramData”，为了方便管理我在D盘也新建了ProgramData文件夹，然后把Adobe这个文件夹剪切过来。 期间需要对文件夹的权限做下处理，因为部分软件对文件夹设了权限，只有赋予了权限才能移动、编辑文件夹。 需要注意的是，在移动文件时要先把软件相关的进程和服务关闭。 文件传输结束后输入命令： mklink /d \"C:\\ProgramData\\Adobe\" \"D:\\ProgramData\\Adobe\" 以上例子只是方便理解，实际操作不太推荐使用剪切，而应该把文件夹复制过去，没问题了再把原来文件删除，避免数据丢失，数据无价，谨慎操作。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/书单.html":{"url":"随笔/idea/书单.html","title":"书单","keywords":"","body":"书单 • 毛泽东选集 • 沉默的大多数 • 非暴力沟通 • 第五项修炼 系统性思考 • 月亮与六便士 • 人间词话 • 呼啸山庄 • 红龙 • 全球通史 • 乌合之众 • 堂吉诃德 • 福尔摩斯探案集 • 娱乐至死 • 小六壬 • 百年孤独 • 月亮与六便士 • 逻辑学 • 哲学 • 胡萝卜须 • 傲慢与偏见 • 战争论 • 沉默的大多数 • 资本论 • （君主论 潜规则 血酬定律 爱的博弈 洞穴奇案 ） • 上帝掷骰子吗 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/你在高中做过最疯狂的事情是什么？ - 知乎.html":{"url":"随笔/idea/你在高中做过最疯狂的事情是什么？ - 知乎.html","title":"你在高中做过最疯狂的事情是什么？   知乎","keywords":"","body":"好多年前的事了啊，高三时我有一个女朋友，其实当时我不怎么喜欢她，虽然她又白又瘦挺好看的，但她性格太闷了，整天很少说话，和我这种活蹦乱跳的实在不怎么合适，我没忍心拒绝她是觉得她孤苦伶仃怪可怜的，她家在几百公里外一个小城市，在本地考不上像样的高中，就走关系来我们这个县重点高中借读。 一个性格特别内向整天沉默寡言的女生，好不容易鼓起勇气对一个没说过多少话的男生敞开心扉表达心意，我真怕拒绝了她之后会让她的性格变得更糟，翻来覆去的看她那封用垮得不堪入目的字体写出来的情书，我想了足足一天，决定当她的男朋友。 首先要面对的问题是我学习成绩还不错，正常发挥可以考个985，而她是个绝对的学渣，大专都考不上，如果班主任知道了一定会拆散我们。所以我先去找了班主任，说明了我的用意，表示一定不会耽误学习，只是想让她在这个远离家人的环境里感受到温暖，能活得积极一些。班主任当时只是个二十六七岁的小姑娘，但本身也是特别善良、很注重学生心理健康的好老师，考虑了一会就同意了我的想法，但嘱咐我一定不能太明目张胆被校领导抓现行，毕竟我们这个学校的校风还是很严的。我当然马上答应了，其实我只怕班主任，根本不怕那些校领导（小县城关系好找，几个校长都和我家熟得很）。 然后我就给她回了纸条，说愿意和她在一起。之后整个高三我一直都很照顾她，经常传纸条哄她开心，水果和零食都会给她带一份，白天给她讲题，吃完晚饭和她压操场，放学后送她回宿舍，每月一天的假期里我还带她去爬过山、划过船，平安夜那天还逃晚自习带她去教堂，她肉眼可见的开始变得开朗，整天苦着脸一言不发的时候越来越少了，但我跟她的亲密程度只限于独处的时候拉过几次手。 1月份是她的17岁生日（我们两个都比同学小1岁，我只比她大1个月），我绞尽脑汁要给她过一个今生最难忘的生日，当时我家条件还不错，零花钱比较充足，两三个月省吃俭用攒了不少钱，在她生日一周前我拟定好了全盘计划，又请同宿舍的几个哥们帮忙，分成几个组各司其职，前一天统一开始行动。 其实我不是很能藏得住事的人，她过生日那天我艰难的憋住整个白天没说生日快乐也没把礼物给她，她可能觉得我忘了吧，一整天都闷闷不乐，在食堂吃晚饭时我一直盯着她，等她吃完我把她叫住，顶着寒风领她到操场说给她看点好东西，操场上黑了咕隆的，她正纳闷的时候，我一直盯着的手表到了6点整，操场外的马路上准时升起了几团焰火，持续了得有三四分钟吧，很多刚从食堂出来的老师和学生都停下来观赏，我看着她因为过度惊喜而喜笑颜开的脸，连自己都感觉心里暖暖的，亲手把送她的项链帮她戴好，然后笑嘻嘻的说了生日快乐，她感动得又笑又哭，一下紧紧抱住了我，我第一次感觉好像真有点喜欢上她了，情不自禁的亲了一下她的额头，但还是忍住没吻她，因为从一开始我就觉得把她的初吻留给她“真正的”男朋友比较好。 我们前后脚回到班里，同学们嗷嗷的起哄，像我这么厚的脸皮都很不好意思，更别说她了，小白脸蛋羞得通红通红的，我看着她脸上根本藏不住的开心和幸福，想着我为她做了这么多真是值了，又隐约有一些担忧，毕业后该怎么说分手才不会太伤人呢。 这就是我高中时期做过的最疯狂的事了，在高考前的几个月里，她对我越来越好，班级篮球足球比赛时她比很多女生喊得都大声为我加油，再也不会像之前一样总是默默坐在角落，不止给我准备饮料，我的球衣只穿一次哪怕没怎么出汗，她都会喜滋滋的抢过去拿回宿舍洗干净，她说她能为我做的不多，帮我洗衣服是让她觉得非常开心的事情。 可高考还是很快就来了，她要提前半个月回老家，虽然她的成绩略有提高，但我们都清楚我们不可能考到同一个城市，这三年来她父母也非常想念她，坚决让她回老家读个专科，所以对我们来说，这是真正的分别。我们没有计划过高考结束之后会怎样，我猜她心里也明白我真实的想法，而我却发现自己根本没有说分手的勇气，于是我们只是平静的道别，那天送她到火车站，当火车开走时，火车带走的不仅是她，好像也带走了我的大部分青春。 我考到了省内一个城市的985大学，距离她300公里，当时还没有微信和qq，我整个夏天只给她打过两个电话，没有约她出来玩过。 上大学之后的事再写就跑题了，打住。 ----------------第一次更新-----超长预警，没有一两个小时的时间看不完，超级墨迹------- 后来想想我们高中也挺有意思，升学率很高，对打架的处分特别严，但因为谈恋爱被处分的只有一对儿在学校里特别过分的，从校领导到老师都是你们别太招摇我们就当没看见的态度。我们班50多人，快毕业时大家都知道的就有8对儿，暗恋的情况更多，以至于毕业后每次聚会都能挖出不少新鲜的陈年八卦。但因为有前车之鉴，可能也都不好意思，情侣们都不会在学校里有超过普通同学关系的亲密行为，而且我们互相之间也从来也不会沟通处对象时的尺度问题，以至于当时的我以为其他情侣也跟我们一样，顶多在没人的地方拉拉小手而已。 除了我事先跟班主任请示过，班里其他的情侣都以为班主任不知情，结果多年之后聚会时班主任能一对对儿的点名，她说差不多都知道，但看我们没怎么耽误学习，又怕硬拆开反倒容易引起抵触情绪，就睁一只眼闭一只眼了。说到班主任，其实她才是我高中时期的“女神”，在省城读完师范大学又回我们这个小县城，据说她老公是她高中同学，我们一直怀疑她就是为了她老公才回来的。当时我还不明白班主任有哪些地方吸引我，后来我才想明白是大城市年轻人身上的那种“洋气”，我们常年穿着校服，早上能按时爬起来上早操就不错了，哪懂什么穿衣打扮。。很多同学是下面的乡镇考上来的，有的脸上还带着高原红，相比之下我女朋友身上也有那种吸引我“洋气”，但她是公认的难接触，高二重新分班后第一个学期我坐她前桌，连我这种全班最能跟女生扯淡的跟她说话都得小心翼翼，整个高二我可能是跟她说话最多的男生了，加一起估计都到不了一百句。所以在一起之前我对她是没多少想法的，但如果是一个长相普通又这种性格的女生给我写情书，我可能只会考虑怎么委婉拒绝，所以我只是个不怕死的颜控而已，并没有评论里说的那么善良。 从一个10万人口，最高楼只有6层的小县城，来到了当时的1.5线城市读大学，我的思想不受到冲击是不可能的，上大学之前一直都是“别人家的孩子”，从小家长惯着、老师哄着，校长不是叫大伯就是叫二舅，从小到大没挨过欺负，连在学校食堂都是走后门进去自己给自己打饭菜，来到大学之后突然一下变得啥也不是，我本来就是压线来的，同学里大把比我聪明的，而且大部分都是大城市来的，人家穿T恤牛仔裤旅游鞋，我穿衬衫（不系裤子里）+水趟趟的西裤+皱巴巴的皮鞋，不止穿衣打扮土，连口音都有点土，在繁华的城市中心，我看着满街性感时尚女郎的大白腿彻底的震惊了，嘴角不自觉的流下了自卑的泪水。 不仅仅是自卑，发生在我身边的一些事更是把我稚嫩的三观震得稀碎，上大学前我觉得你看我一眼笑了，我看你一眼脸红了是最甜蜜的事，接吻那可是了不得的大事，结果宿舍一哥们和一个学姐只见了几次面就“那个”了，之后没多久就如无其事的分手，我看俩人谁也没伤心难过什么的，更过分的是这个学姐又来约我，我还以为让我帮她说好话，结果人家摆明了是来泡我的，我可去你妹的吧，完全接受不了，在那之后好长一段时间我都对这种温柔学姐敬而远之，而班里的女生就有点惨不忍睹了，当时我坚定的认为长得好看的都早恋了所以很少有学习好的，师兄们传下来的“XX女生一回头、吓倒一排教学楼”那些段子我学得贼溜。 于是我把自己封闭起来开始反省，之前积累的世界观、爱情观是不是幼稚的？甚至是错误的？不好意思请教老司机，就泡在图书馆里寻找答案，挑了一堆世界名著，QTMD根本看不进去，只有一些类似《永不瞑目》、《尘埃落定》这种现代小说还能读得津津有味，成宿成宿的看，什么社团活动和社交根本不参加，女生们给我起了个外号叫冷冰冰，感觉自己接收到的新东西太多了，每天忙着消化，以至于很多时候我都快忘了在300公里之外我还有一个女朋友。 有一个到现在我都没法想明白的问题，我们大学建校50年，结果宿舍12人一间，连电话都没有，我女朋友读的专科建校没多久，6人一间还有电话，这是为什么？当时还买不起手机，只能用电话卡排队打电话，我最讨厌排队了，开学3个月只给家里和女朋友打过3次电话。 偶尔想到女朋友的时候当然也会伴随着反省，我喜不喜欢她？好像不怎么喜欢，因为我不怎么想她。她哪里好？长的挺好看，手特别特别好看，对我嘛，跟其他情侣中的女生相比也没什么特别的，其他的好像没了。她喜不喜欢我？可能也不那么喜欢，因为每次打电话她语气都很平淡，没说过想我之类的，也没问过我想不想她，她高中时为啥给我写情书？可能我看起来最阳光最外向，能哄她开心吧？到后来我甚至怀疑高三时期我们那种相处算不算谈恋爱？与其说是男朋友，好像我更恰当的身份是“学习或者兴趣小组组长”？ 最后一次给她打电话时她问我要了地址，说要给我邮点东西，我马上想到她是不是要把我送给她的项链还给我，再附上一份分手信？如果真是这样我难过吗，好像还真不难过，现在的她对于我来说仿佛有种“过去的包袱”那个感觉，也许甩掉了我才可以轻装前进。 12月份是我的18岁生日，我收到了她的生日礼物，一条和她的字一样垮的围脖，一边紧致一边疏松，无论如何都摆不成一条直线那种，一张很香的粉色纸上写着她的垮字，说她亲手织了一个多月，改了好多次，虽然还是丑，但确实尽力了，落款还画了个❤。这和我预想的差得有点多，让我感觉到了久违的温暖，在那几天里还真有点想她了。 平安夜那天我排了好长时间的队给她打了个电话，她问我喜欢那条围脖吗？我说喜欢（其实我嫌累赘从来不带围脖手套之类的，正好我一直觉得枕头有点矮，就把围脖垫在枕头下面了，就当是白天不戴晚上戴了），她问我没约女生出去吗？我说哪有女生搭理我，我都快半个月没和女生说话了，她说不信，然后终于问我想她了吗？我停了一下没说话，她说我就知道你不想我，我说哪能呢，刚才旁边吵没听清你说什么。 快放寒假时轮到她的18岁生日，生活费早就被我挥霍光了，只能把刚开学时为了安慰自己的自卑心理买的那堆无用的东西翻了出来，望远镜和文曲星她好像没啥用，实际上我买来之后也没怎么用过，有个爱华随身听她应该用得上，我买来之后装B听了几天后街男孩就扔柜子里了，好好擦擦跟新的没啥区别，打包邮给她了。 寒假回家，双脚刚踏上家乡的地面，在大学时感觉离我那么遥远的家乡回忆突然在脑海里奔涌起来，几个月没见的父母和小伙伴们，我迫不及待的想见他们，这半年来经历过的失落沮丧和叛逆的情绪好像一瞬间都烟消云散了。 约了高中时最好的几个哥们撸串，班长提出年后把班里同学聚一聚，再一打听，高中时有对象的几个大部分都因为异地黄了，我说你们真是垃圾，找的都是什么对象？他们说你和女朋友咋样了？我说挺好的啊，他们说过几天咱同学聚会你把她叫来？我说没问题啊。当天我给她打电话说了聚会的事，她说你希望我去吗？我说来呗我接你，她说好。 火车站等她的时候说一点不紧张是假的，一晃半年多没见，我有点自责自己这男朋友是怎么当的，她下车时盯着我愣了好一会儿，再次见面没有我想象中的那么陌生，她好像一点没变，还是那个生人勿进的模样，但我总觉得自己已经不是半年前的自己了，毕竟我现在拥有的是咖啡色的谢霆锋同款发型。 所谓的聚会就是找个大点的饭馆大家聚在一起边喝酒边吹牛X，几个最能装的还旁若无人的点起烟来抽，其实我倒没什么，大学宿舍里也有抽烟的，可我女朋友有点受不了，我上去抢过他们的烟说别TM抽了，他们几个说人家女生都没说啥，你小子管的可真多，我说我媳妇呛得慌，他们几个看了我女朋友一眼连忙说卧槽惹不起惹不起。回到座位之后女朋友笑的很开心，在饭桌下又握了一下我的手，我收到鼓励，突然感觉有个女朋友好像也挺好的，虽然老也不见面，但她可能是这世界上唯一一个愿意主动摸我手的女生了。 女朋友的同桌问她哪天回去，我以为她会说当天就回，没想到女朋友说再待一两天。晚上吃完饭散伙，有几个不争气的玩意还喝多了，吵吵了半天你送我，我送他的，我酒量很垃圾，但胜在脸皮厚就是不喝，所以感觉还算良好。出门之后领着女朋友去广场看花灯，一路上都在想着她晚上住哪，人多的时候拉了她的手，她也没有拒绝的意思，这是我们第一次在大庭广众之下拉手，有一种终于长大成人不怕被老师看见的感觉了。 看完花灯我说晚上到我家去住吧？她说你跟你爸妈说咱俩的事了吗？我说没啊，她说那怎么去啊，也太突然了吧，我说那只能带你去小旅馆了。然后找了个小超市给家里打电话，跟我妈说在同学家住，假期几天和同学一起玩、夜不归宿的事我高中时没少干，所以我妈也没多说什么。最后找了个民宿，就是那种个人家里开的只出租一间房的，进屋一看，这小屋也太小了吧，只有一张床一个凳子一个衣架，连个电视都没有，不过也逛累了，实在懒得下楼再找就交了钱，她脱了羽绒服就说要去洗漱，留我一人坐在凳子上陷入了沉思。 其实这半年来我被宿舍里的老司机们言传身教学会了不少，反正是匿名不怕各位笑话，上大学之前我连打飞机都不会，老司机们第一次带我去录像厅看HP的时候我恶心的第二天都吃不下饭，那些个内容对我这种萌新来说过于劲爆了，到现在我还抗拒一切串成串的肉枣类食物（手动狗头），但我的承认教育终归还是在18岁前完成了，如果说半年前的我单独和她相处时拉拉手还是出于“好像应该这样”而不是“我想这样”，半年后的我实不相瞒，已经满脑袋都在想着要不要趁机GHS了。 她洗漱完回来看我一直霸占着凳子，就只能坐在床上，那天她穿的是紧身的白色毛衣，如果说半年前的我看女生只关注脸和高矮胖瘦的话，半年后的我对年轻女性身材的认知已经有了翻天覆地的提高，哇，以前从来没注意到，她的腰怎么那么细？多说也就1尺9，吼吼，这个胸，妥妥的A+，比我的大点但也有限。 她见我一直不怀好意的盯着她，就瓮声瓮气（她说话一向这样，语速也慢悠悠的，所以她静静坐在那里时还有点高冷少女的范儿，一张嘴说话就马上破功）的说我累了，要睡觉了。在这个关键时刻，我觉得我应该有所行动，于是站起来向她走过去，脑子里两个小人展开了激烈的搏斗，邪恶小人说自己女朋友你怕什么，摸两把她又不见得不乐意，正义小人说摸完了你能负责到底吗？走到她面前时我感觉她屏住了呼吸，但我脑子里的两个小人还没分出输赢，所以我又转身走了回去，第二圈转回来的时候邪恶小人稍占上风，我摸了一把她的脸蛋，问她怎么这么热，感冒了吗？她低下头不说话，拉住我的手把我拽到她旁边也坐在了床上，之后顺势搂住了我的脖子，一年前她过生日的时候抱过我一次，但那次我们都穿着厚棉服，这次可不一样，虽然只是A+的胸，但杀伤力对于我这个18岁小男生来说还是过于强大了，我脑子里的正义小人高喊着别慌稳住，于是我跟她说，我要去洗漱。 回到房间时她已经侧躺在被窝里，背后给我留了一半的床，我观察了下，地板上只有两件羽绒服和她的一件牛仔裤，根据分析她没脱毛衣毛裤，我感觉放松了不少，蹑手蹑脚的来到床边，慢慢掀开被子钻了进去。然后就开始和她闲扯，什么高中哪个同学怎么怎么了，我们大学宿舍里有个南方兄弟洗澡时穿一身内衣之类的，她有一声没一声的答复我，可能真的好久没和女生这么说话了，我滔滔不绝的瞎扯了半个多小时，后来困得舌头都不利索了，于是我也不吱声了。 我说关灯睡觉了，她说嗯，我有点不甘心的闭上了眼睛，她突然小声的说了句有点冷，你抱抱我呗。我擦那一瞬间我感觉邪恶小人小宇宙爆发一拳KO了正义小人，右手嗖的一下伸了过去摸上了她的腰，不由感叹小女生的腰胯比例真是惊人，再往前伸摸到了小肚子，呵呵，弱鸡一个，软乎乎的一点腹肌都没有，跟我差远了。还没等我继续探索，她就向后靠了过来，这么一挪位置，我的手就停在了A+的边缘，黑暗里两颗心怦怦乱跳，我的鼻子里全是她头发和身上的香味，但我在紧张之余并没有放弃思考，这样她都没拿开我的手，看来应该不会抗拒我下一步的行动，于是我勉力控制着发抖的手摸到了A+上，哇塞这个手感，啊我死了。她的呼吸愈加沉重了起来，而我只沉迷于那个柔软无比的手感，隔着毛衣在她上半身打了几遍太极之后，困意剧烈上涌，我心满意足的睡着了。 早上起来脑袋还有点晕乎乎的，昨晚我连外裤都没脱，半夜热得把被子都蹬到她那边去了，我看着躺在旁边的她，闻了闻她的头发，又看了看自己的右手，想到昨晚睡前那一幕，差点笑出声来。 吃完早饭就退房走人了，总不能大白天的都趴在被窝里对吧，手挽着手领着她在街上闲逛，我问她几点的车，她说还是下午1点多，我说那还有几个小时，干什么去？她说咱俩去教堂逛逛吧，我说不是平安夜那里都不开门的，我带你去打游戏吧？她说嗯？我说我初中时打游戏可厉害了，就这家，那时总在这里玩的初中生几乎没有不认识我的。 进了游戏厅，我以为游戏币还是像初中一样1块钱4个，就说来10块钱的吧，结果老板给了我80个，几年没怎么来，便宜了这么多。其实我最擅长的是街霸，不过和她对打好像没什么意思，就带她去玩三国，我说初中时游戏币很贵，这个三国我从来没通关过，你来陪我玩吧，她说我不会啊，我说你就边往前走边两个一起按就行。但她还是死的稀里哗啦的，我从来没有过这么菜B的队友，只顾着看她，连自己都没发挥好，好几次差点挂了，她按到第4关就说累了按不动了，我说那你就坐我旁边看着吧，然后...我就一直玩到了12点，最后用币子堆死了吕布和曹操，又打通关了两次街霸，还剩了一堆没用完，我就叫住几个身边路过的小学生，把游戏币分给他们了。 还是那个车站，还是那班火车，再次送她走的时候，心里好像多出了一点不舍，和她拥抱告别后我走出了火车站，突然觉得刚才她在身边没玩爽，想了想直奔初中最铁的小伙伴家里，我们两个一拍即合，再次杀奔游戏厅，把里面所有的游戏都干通关了一遍，晚上又约了几个初中同学在他家打了大半夜的扑克。 早上我邋里邋遢的回到家里，我妈笑嘻嘻的问我这两天干嘛去了？我说找XXX和XXX去玩了啊，我妈说还骗我，昨天上班时同事跟我说了，前天晚上你带着一个可好看可好看的小姑娘在他家开的小超市打电话说妈我晚上不回去了，那小姑娘是你对象啊？啥时候处的？我说就高中时候呗，我妈问是高中同学吗？啥时候领回家给他们看看，我说过阵再说吧，现在就领回家也太早了吧，我妈说你俩都住一块了还不往家领？我说你怎么这么封建，住一块就得那样吗？然后就回房间补觉了，隐隐约约听到我妈跟我爸说，你儿子会拱白菜了。 睡醒之后想着昨天只顾着玩，还没问女朋友到家没，就给她家打了个电话，她说挺顺利的，我说嗯，那你想我没？她笑了出来，然后小声的说：想了。 -------------第二次更新--------------- 放下电话，我妈凑过来要看照片，我把毕业照翻了出来找了半天没有她，才想起高考前几天照毕业照的时候她已经回老家了。我妈说她不是咱这的啊？我说是L市的。我妈又问她在哪上学，我说她们市的职业技术学院，我妈说大专？我有点不乐意说大专怎么了？我妈琢磨了一会，问你们想没想过你毕业之后是她找你还是你找她？我愣了一下，好像还真没想过这个问题，我妈说你们年纪还小，但要处就好好处，将来你们总要面对这个问题的，最好先有个初步打算，要不俩人感情越来越深，最后走不到一起那得多难受。 晚上打麻将时越想越觉得我妈说的好像挺有道理，聚会前我觉得离分手不远所以没考虑那么长远，可聚会之后好像又分不成了，就开始琢磨要不要听我妈的话好好拱那颗白菜，我把正义小人单独叫出来，说我好像真喜欢上她了，正义小人说什么叫好像？我说有点拿不准是不是难得有女生跟我这么亲密所以现在才这么想她，正义小人说那你想想如果别的女生也跟你这样呢？我把这几年认识的好看女生差不多都YY了一遍，肯定的对正义小人说好像都没什么意思，我只想和她切磋武功。 想到切磋武功，在脑子里翻滚了好几次的画面又自动播放起来，这小女生怎么那么软乎那么嫩还那么香呢？跟臭烘烘的半大小伙子是不一样，一颗牌在手里扒拉了半天也没打出去，坐在下家的我爸实在等不及我的长考，问我你瞅着一颗牌傻笑半天干啥呢？在那做麻将呢？被打断了思路的我意犹未尽的靠在了椅背上，说哎呀，有点想我大姑父了。 我妈听完愣了一下，反应过来说你可真能扯，前几天过年时不还见过吗？你就说你想对象得了。我爸有点懵，问我妈啥意思，我妈说你儿子处那个小对象也是L市的，他想去看人家。我爸说那就去呗，爸给你拿路费，我说不用，男子汉得自力更生，看我好好打赢你们几百。他俩的水平一向很臭，又可能故意放了点水，不到12点我就揣着一沓钱回房睡觉了。 有点兴奋，睡了五六个小时就说啥也睡不着了，我爬起来把同学录翻出来背下了她家地址，早早来到火车站，结果发现直达的还真只有中午1点那一趟，在候车室里有点坐不住，来回晃悠了好久终于等到检票，车上人还挺多的，我只能找了个人少的地方站着，车上算不上暖和，鼻子里充斥着烟和方便面的味道，她3年多来独自经历的旅程一直是这样的吗？ 想到大冷天的，一个不到90斤的小姑娘在这样的环境里来回站了六七个小时，就为了和那个一直预谋在跟她分手的男朋友见一面，感觉自己的心好像被突然揪了一下，继续下去的话，这种自己坐车的事对我和她来说恐怕都是常事，我们能坚持4年吗？我们的未来又会在哪里呢？出发前挺好的心情变得有点沉重起来，只想见面时好好的抱一抱她。 下车直奔她家附近找了个公用电话，问她干嘛呢？她说在看电视，怎么了？我说来L市看大姑，顺便看看你，你下来找我吧。打完电话我边在马路边等她，边打量着周围的环境，这就是她上高中之前每天生活的地方吗？没过一会就看到她一路小跑着过来，本来今天就冷，她的哈气更明显了。我问她跑什么？她说怕你等时间长了冷呀，我说确实有点冷，她说往前走走吧，那有一片商业区，可以找个暖和地方待会。 刚拐过路口，我就发现了一个规模不小的电玩城，刚说了个哎，她就打断我说前面前面，不远就有个咖啡厅，我说我没想进去玩，就是想和你说这个电玩城看起来很高级啊，我们大学附近好像都没有这么大的，她看了我一眼没搭理我。咖啡厅里面暖洋洋的，装修风格还挺温馨，长这么大第一次在咖啡厅点咖啡，不会点就随便指了个，她晚饭吃过了，我就又点了糕点当晚饭，然后问她在家看啥电视呢？她有点不好意思说，我说咱俩这么好你有啥不能说的？她扭扭捏捏的说《将爱情进行到底》，我说啊挺好看的，我喜欢“跑”，她说文慧好看，我说那倒是。 她把羽绒服脱了下来，于是我又看到了那件白色紧身毛衣，要不是旁边有人真想活动活动筋骨打打太极啥的，感觉鼻子有点痒痒，怕万一鼻血流出来显得我太色就先把手指放到了鼻子下边，跟她说我爸妈知道咱俩的事了，她说你主动说的啊？我说没有，那晚咱俩给我家打电话说我不回家住的时候，超市那个女的是我爸妈同事的媳妇，认识我的。她一下子慌了，说完了，那咋办啊？我说啥咋办？她说你爸妈会不会觉得我很......那个.....嗯......随便？我说不能，我说了咱俩啥也没干，就是你晚上来不及回家我陪陪你。 然后我又问她跟她爸妈说了吗？她说还没，我说怕啥的，就我这么帅的发型不至于给你丢脸吧？她说还是等过一阵稳定点了再说吧，又岔开话问我在这待几天，我说明天就要回去喽，大后天表哥结婚让我当伴郎，哪有冬天结婚的，是不是有毛病？她说你可不能看到人家伴娘好看就惦记啊，我说放心啦，再好看能好看到哪去，还能有你好看？ 开心的事说完了，该聊点闹心的事了。我说来时在火车上我数过了，咱俩快8个月没见，中间我一共只打过8个电话，从没过来看过你，你会不会觉得我很那个......那个觉得你不太重要？她低下头看着杯里的咖啡，说你们学校学习应该很紧张吧，而且刚开学肯定事情比较多，抽不出时间也正常。我很想和她说对不起不是这样的，但又觉得说出来会让她难过，只能说其实后来也没那么忙，就是我们学校打电话太不方便了，开学回去我就买个汉显的BP机，你想我了就给我留言，或者让我给你回电话，我一定尽快回。她一下抬起了头，咧开嘴笑着说真的啊？我说来拉钩儿。 从咖啡厅出来都七点多了，天气更冷了，我把手放到她羽绒服兜里攥着她的手，俩人一路小跑送她回家，进了楼道感觉暖和不少，我说我走啦，她说嗯，把她抱在怀里说我觉得应该亲亲你，但嘴好像冻的快没知觉了，她笑着说那就缓一会儿，我正专心致志的闻她头发香味时，她突然问：你，真的喜欢我吗？ 这个问题问得好，我准备好好调动一下华丽的词汇来表达我的诚意，先想想上次说喜欢她是什么时候？好像一次都没说过...我擦处了1年半我连喜欢都没说过，这什么狗屁男朋友？还不如人家一个小姑娘主动呢，等等，好像不对，她也没说过喜欢我啊，情书里先扯了半天我在足球场上多么多么英明神武魅力无限，然后来了一句对我有特殊的感觉，要不是我阅读理解能力不错，搞不好还以为是让我转交给罗纳尔多的呢，想到这个罗纳尔多......世界杯决赛时他到底怎么了？ 然后我就感觉到她好像哭了，赶紧召唤出邪恶小人和正义小人两兄弟，说我要征求一下你们的意见，立刻马上给我答案，两个小人难得的迅速达成了一致意见，于是我把她从怀里推开，亲了亲她还带着泪花的眼睛，说白菜（化名，大家都懂的），我喜欢你，之前可能有觉得你可怜的地方，但现在是真的只有喜欢，非你不可的那种。 她抬起头，哽咽着说半年不见你怎么突然变得这么会说好听的了，是不是没少勾搭小姑娘？我说天地良心，这半年我连小姑娘的手都没碰过，话刚出口就想起迎新晚会的时候好像没好意思拒绝一个邀请我跳舞的女生，不由得有点心虚，赶紧说别哭啦，回家让你爸妈看出来还以为我把你怎么样了呢，她擦了擦眼泪平复了一下心情，说你记住这句话啊，到什么时候也别忘了，我听这话感觉有点不对，又不知从哪安慰起，只能继续抱住了她。想到我带给她的种种委屈，愈发的心疼她，越抱越紧恨不得把她塞进我心里，她一声不吭也只是紧紧搂住我的腰，感觉抱了好一阵，她挣脱出来问我，你缓好了吗？还没等我回答她就吻了上来，我还没来得及体会是什么感觉，她就缩回去了，说我也喜欢你，然后就小跑着上楼了。 这个初吻结束得也太快了，还没反应过来就完事了，和预想的不太一样呢，不应该是那种咔咔的一顿亲吗？出门一看时间，都快8点了啊，再不去大姑家就太不礼貌了，但那个电玩城......算了下次来再说吧，反正以后机会多得是。 回去当伴郎，我还以为有好几个，结果一打听，原来就我自己。二姨觉得我这个发型不咋地，我妈也表示一直看我这个跟长毛鞑子似的头发不顺眼，于是我进化成杀马特始祖的机会就这么被残酷镇压了，摸着我的毛寸，我表面不敢BB，心想都盯着我干什么，结婚的又不是我，同时也打听到了冬天婚礼的原因，表嫂怀上了。 还是很顺利的，除了去接新娘时稍微使用了点暴力，其他的力气活也就是在台上讲几句话，跟来宾挥挥手什么的，但有一说一，那个小伴娘长得还真可以，也不知道表哥表嫂两口子咋想的，我妈说台下的不少亲戚朋友都在议论这婚礼哪都挺好，就是伴郎伴娘比新浪新娘好看得有点多。我妈问我对象和小伴娘哪个好看？我说切，你就这么不相信你儿子的眼光啊？我妈说你又不往家领，又不给我拿照片，我不着急吗？我说对啊，总觉得去了趟L市忘了什么事呢，忘朝女朋友要照片了。 第一次在台上近距离感受婚礼，表哥表嫂在主持人的带动下抒发情感又哭又笑的，我觉得不至于哭成这样吧，俩人相亲没几天就好上了有啥可哭的？可看着看着又觉得有点发自内心的羡慕，如果穿上礼服站在中间的是我和女朋友，这个滋味好像真挺不错的，表嫂这身婚纱穿在女朋友身上应该特别漂亮吧，脑子里两个小人开始疯狂搭建相关画面，不过我还是想不出来有什么可哭的，到时候是不是得全靠拼演技了？事后我们这边的亲戚都说我在台上表现得特别自然，一看那表情就知道跟表哥表嫂感情很好，恐怕只有我自己才知道我眼睛里看着新郎新娘，可心思全在几百公里外一个小姑娘身上了。 我觉得我完了，几天之前在我心里只能占一个小角落的她，已经急速膨胀到我心里快放不下别的了，摸两把、亲几下的威力有这么大吗？我甚至感觉现在看什么都是重影的，她的一颦一笑就像印在我的视网膜和眼皮上，睁开眼睛脑子里面全是她，闭上眼睛脑子里面还是她。我这个人虽然口号经常喊得挺响，但其实没什么雄心壮志，小时候的梦想是当科学家，中学时的梦想是考清北，其实这些都是我爸妈的梦想，但现在我好像终于有了属于自己的梦想，这辈子一定要娶她当老婆，好好看看她穿婚纱时有多好看。 开学之后感觉自己的发情期好像过去了，我可能有至少两套处理系统，一套处理老家的，一套处理大学的，两者很少产生关联和交叉，当然这学期和上学期不一样的地方在于现在明确的认知了白菜得好好拱，她咋就那么可爱呢，憨憨的样子想起来就美滋滋，但真的没前些天那么想了，先买个BP机，晚几天再去看她，不过电话可真得勤着打几个了。 网络上终于出了点新玩意，仿佛一夜之间学校里的机房由游戏机打字机变成了网聊中心，校外的电脑房也开始改名叫网吧，学校也搭建了自己的校内网，里面还有一个“文字江湖”，就是可以在里面打工赚钱嗑药练功然后互相PK的，一时风靡全校。有天我发现了一个画风跟我们学校女生完全不符的女生也在玩文字江湖，我在背后偷偷看了她的ID：花间一壶酒。我跟宿舍哥几个说，别说小弟有好事没告诉你们，江湖里的花间一壶酒是个大美女，据我目测身高都快赶上我了，他们几个摩拳擦掌准备大干一场，在里面搭讪人家爱理不理之后本着得不到就毁灭的心理开始疯狂PK花姐吸引人家注意。一个兄弟发现来狠的不行开始疯狂用银子砸，终于和花姐建立起了不错的友谊。然而还是没有我和她关系好，能扯淡的人无论在现实还是网路里都能如鱼得水，不过我对她兴趣不大，毕竟我可是有女朋友的人，远没有几个室友那么饥渴。 第一次从学校出发去看女朋友，路线就比较难受了，需要坐7个小时的车，不过想到能好好稀罕稀罕她就感觉一点都不辛苦了，我又来了，我的白菜，准备好被拱了吗？ ----------------第三次更新-------------------------- 相比上次，这次天气暖和多了，但她还是一路小跑下来找我，让我低头摸了摸我的新发型，说还是这种干净利索的比较适合你。晚饭点还没到，就先到她宿舍见坐了会，这还是我第一次来女生宿舍，没有想象中那么整洁，但还是能明显感觉出和男生宿舍不一样。她的几个本地室友都回家了，宿舍里只有另外两个女生，白菜给我们互相介绍之后就让我坐她床上。四姐正洗衣服，只有大姐陪我们聊天，她比我们大几岁，看得出和白菜感情不错。大姐一边和我们聊一边催四姐。 四姐匆匆忙忙挂好了衣服，穿好外衣拿包就走，大姐和她一起出门说我们去自习，熄灯前才会回来，你们不用着急。我说大姐我请你们吃饭吧？大姐说你们好不容易见一面，我们就不当电灯泡了，等下次我们人全的吧。快出门时大姐又折了回来和我说，本来我想好好说说你的，不过感觉你这小伙儿还不错，我和你说可有不少男生惦记白菜呢，你离的远也不能常来，但至少多给白菜打打电话吧？刚开学时白菜说她在XX有个男朋友我们都不信，哪有一个多月才打一个电话的男朋友？白菜轻拍了下大姐的胳膊，大姐摸了摸白菜的头，我说是是是，大姐我知道错了，以后一定改。 她们走了之后白菜说，我们大姐就是这脾气，你别太往心里去，我说确实该说。白菜说你坐了那么久的车累了吧，好好躺我床上眯一会，晚饭时我叫你。我嘴里说着不累，脑袋却躺在了枕头上，其实我真的不累，但刚坐下时就闻到一股白菜的香味，严重怀疑是枕头上散发出来的，躺好之后细细一品果然是，一歪头就看到了静静躺在旁边的爱华，问她音质怎么样？她说挺好的啊，每晚睡觉前都会听一会。 我把耳机戴好按下了播放键，耳朵里传来谢雨欣的声音，《谁》这首歌当时在我们校内网也超级火，播放量仅次于林志炫那两首，我闭上眼睛想象着她每晚睡觉前这里的心情。这是我第一次把自己想象成白菜的角度来思考一些问题（这句总感觉怪怪的...），想到大姐对我说的话，整个大一上学期我给白菜打过的电话一只手都数得过来，那时的白菜每晚躺在这里看着上铺的床板，一定会觉得我们离分手只差说出那两个字了吧？ 我放下耳机坐了起来观察白菜的小床，抚摸着浅蓝色的床单和雪白的墙壁，心里突然暖暖的，在距离平时生活的地方300公里之外，我居然还有这么一个温馨的小家，世界上所有男生里只有我才能惬意的躺在这香香的小床上用她的随身听来听歌，看着坐在床尾一脸温柔看着我的小床主人，鼻子突然就酸了，过去抱住了她。 我说白菜我想你了，她轻轻的嗯，我的眼泪顺着脸颊滴到她肩膀上，没一会她也小声抽泣起来，我轻轻的吻住了她，嘴里满是我们泪水的味道。其实邪恶小人已经提前帮我拟定了几份作战方案，但我发现根本用不上，现在的我面对她好像没有一丝杂念，我不想伸舌头不想打太极，任何一种单纯为了满足欲望的行为我觉得都是对面前这颗白菜的亵渎，我只想一下又一下的轻轻吻她的眼睛、吻她的脸、吻她的嘴，在那一刻我清晰无比的感觉到我是真的喜欢上她了，即使她不让我碰我也喜欢她，我只想让她开心，不忍心让她难过。 想到之前自己对她的伤害，心痛得厉害，刚刚止住的眼泪又不可阻挡的顺脸而下，她摸着我的脸温柔的说你怎么啦？我哭着说对不起，真的对不起，以前我对你太差了。她说没有啊，我觉得你对我挺好的。我握住她的手，说我以后一定好好对你，她笑着点了点头。我一边擦着眼泪，一边突然咧嘴笑了出来，她一愣问我怎么跟小孩儿一样又哭又笑的？我说我想到好玩的事，她问什么？我说如果现在大姐她们回来会不会觉得我被你打哭了？白菜也笑了出来说让你不给我打电话，家法伺候。 和她脸对脸侧躺挤在这张小床上，我抚摸着明显凹下去一大块的一尺九，和她开玩笑说今晚咱俩都挤你的小床上吗？放不下咱俩吧，我一翻身你还不得掉下去，除非...她问除非什么？我说除非摞起来。她说摞起来？然后反应过来说你满脑子都想什么呢？我说想想都不行啊？她说想想可以，但不能来真格的。我说放心吧，你想跟我来真格的我都不敢呢。她纳闷的问为什么？我说不告诉你。她撒娇说你告诉告诉我呗，我去，她竟然还会撒娇，看来我之前真是小看她了，我说感觉进度有点快吧，我有点消化不了，她说快吗？我反问道不快吗？她一副若有所思的样子，我很想再问问她，但又想不出该问什么。 她本想带我去校外烤肉店吃晚饭，在我的强烈要求下改成了食堂，吃完她挽着我的胳膊带我逛她的学校，说平时她就在这个楼里上课，在那个楼里自习，我羡慕的说你们这个校区真是新，比我们好太多了，我经常去上课的教学楼一到下午时楼道里就黑得跟防空洞似的，早知道考到这里好了，还能离你近点。她悠悠的说高考时你考虑过我吗？我一时语塞不知该怎么回答，她看着我笑了出来，说你别犯傻了，一开始我就知道高考之后肯定不会在一个地方的。我说那你还给我写情书，她笑着说情难自禁嘛。 找了个喝饮料的地方坐着，我问她平时周末是不是都回家，她说是，不过和家里说这两天在学校有事就不回去了，但是她爸妈有时会在宿舍锁门后打电话查岗，所以为了安全起见晚上还是得在宿舍住。我说也只能这样了，要不五一你去看我吧，我带你好好玩玩，她说爸妈不会让她自己出门太久的，我说这可真是个麻烦事，看来除了寒暑假你说高中同学聚会，以后只能我来看你了，要不你和你爸妈直说你交男朋友了吧？她说现在还不行，爸妈觉得她年纪还小，而且从小就心眼实在怕被男生骗。我心中一动，问她就不怕被我骗吗？她笑着说不会的，菩萨会保佑她，我有点纳闷，哪个菩萨还管处对象的事？ 她送我到学校宾馆办好入住，之后我送她回宿舍，她说早上7点半我找你去食堂吃饭，我说不用，我来接你，她说你认得路吗？我说你也太小看我了吧？虽然是周末，但宿舍门口还是人来人往的，不太好意思亲热，就说了明早见。她挽着我的胳膊不舍得放开，说要不我现在给家里打个电话，然后再跑出来？我说还是别了，让你同学们知道你夜不归宿在宾馆陪男朋友，你家还是本地的，万一我要是挂了，你还咋嫁人？她说你胡说什么呢？你死了我也不活了。我一阵感动真想亲上去，勉强压制住这股念头，说我走啦，你好好睡觉。 其实我还真不怎么困，琢磨着还能干点什么，迎面走来一个脸色发黑的眼镜哥，我灵机一动说哥们儿，网吧怎么走？他说兄弟你真是问对人了，跟我走就行。我俩边走边聊，聊到游戏后一见如故，到网吧连坐鏖战三角洲到后半夜两三点，我说哥们儿明天还有事我先撤了，他给我留了宿舍电话，说下次来找女朋友时还可以找他，直接在他宿舍住就行，宾馆死贵死贵的有那钱开个包夜多好。 第二天我准时到宿舍门口，离老远就看她坐在长椅上，眼睛直勾勾的盯着地面也不知道在想什么，我绕到她背后本来想吓唬她，又觉得舍不得，轻声叫了她的名字，她回头一看是我，直接笑出一朵花来，蹦蹦跳跳过来挽住了我的胳膊，我说怎么这么开心？她说昨晚大姐和四姐都夸你了，我问夸我什么了？她说大姐原来以为你是个很会耍心机欺骗女生感情的人，结果发现你和我一样就是傻不拉几的小孩子，她们还说咱俩倒是挺般配的。我说这是夸人吗？她说哎呀，反正她俩对你印象都挺好的。吃过早饭后陪她去市中心逛了会街，中午第一次带她去吃了KFC，然后恋恋不舍的告别。 五一和六一都是我来看她，单独相处时我来回来去都是那几招，也没有过夜的机会，直接略过。不过五一的时候我成功把她拐到她家附近那个电玩城了，还好里面有些适合女生玩的，一二百块最后换了个半大玩具熊出来，虽然亏了点，但她开心就好。我们也开始努力适应这种异地恋爱，几乎每天我都会给她打个电话，聊聊各自的生活和遇到的好玩事，几个月时间感情增进了很多，我发现之前我对她真的并不怎么了解，但现在的我已经基本能够摸清她的喜怒哀乐，其实她也只是个普通小女生，之前那种难以接触的印象，现在看来只是她在陌生环境下一种自我保护的手段而已。 暑假到了，我迫不及待的宣布召开学习小组的老同学聚会，地点在我家县城，组员当然只有我们两个。我妈看到白菜的照片之后坚决表示要看真人，我说再过一两年我争取给你领回来，但现在确实还有点早，最后我妈说你去接她的时候我离老远看看总行了吧？我说除非你开一个我无法拒绝的条件，我妈说500够不？我握了握她的手，说成交。 接到白菜之后先领她到火车站附近的小吃店吃午饭，她背对着门正低头专心吃饭的时候，我妈走进来了，我在心里狂呼卧槽，刚才在火车站前还没看够吗？还非要走到跟前看？我妈假装找人，绕到我后面看了白菜几眼正脸之后出门走了，我的心砰砰跳还得装作若无其事并坚持目不斜视，心想这点钱挣的可真不容易，心脏病都快犯了，万万没想到的是过了几分钟我妈又进来晃了一圈，不一会BP机收到了我妈的留言：妈同意，给妈好好追！ 我没憋住直接笑了出来，白菜一愣，满脸的莫名其妙问我笑啥呢？我说嗯...看你吃饭的样子好看，然后我假装喝汤，想到我妈那个留言，差点没忍住喷了出来，白菜反应过来了说肯定不是这事，你骗我。我说真的没骗你，特别可爱。她歪着脑袋问：可爱吗？我摸了摸她的头，说可爱死了。 大热天的实在没地方去，只能带她去喝冷饮，灵机一动说咱俩去看班主任吧？高中只放半个月暑假，所以学生都还在校，我和白菜混进高中找到班主任，汇报了近期的学习和感情，班主任表示你们这些半大孩子真是一年一个样，这才多久没见，感觉成熟了很多。我说老师你也长大了不少，这肚子得有五六个月了吧？ 晚上班主任请客在学校食堂吃了晚饭，我说老师你去忙吧，我们在学校里走走。虽然早就不是这里的学生了，但是怕给班主任惹麻烦，所以还是跟以前一样保持2人间距压操场，白菜说虽然离开了一年，但感觉就像刚放完暑假回来开学似的，我说可咱都成大哥哥大姐姐了，你看这帮踢球的小孩应该是高一的，我都没见过。白菜问你还踢球吗？我说很少了。 我看场上踢球，白菜低头走路，走着走着开口问我，收到情书时是什么感觉？我说就挺突然的，我一直以为你有点讨厌我呢。她问我什么时候讨厌你了？我说高二刚开学没多久，你不是坐我后桌吗？有天自习课我回头和你们两个女生说话，好像是讨论咱班女生都谁好看，你同桌说你好看，然后问我，我说还凑合吧，就把你惹毛了，然后你就凶我让我转回去，那几天我一回头说话你就让我转回去，我长那么大还是第一次被女生那么讨厌。白菜噗嗤笑了出来说谁让你说我的？我说就开个玩笑，其实我心里是觉得你好看的，那阵我们宿舍给咱班所有女生打分，我给你的分最高。她说那你也不能说我长得像老太太啊？那时我才十五六，最水灵的时候，哪里像老太太了？我说我是那么说的吗？那还确实有点过分哈，不过不至于生那么大气吧？白菜悠悠的说，别人说我不搭理他，你说就不行。 我琢磨过味来，说你不会是高二刚开学就对我有意思了吧？她说不告诉你，不过可以告诉你点别的，我问什么？她说其实...开学那天分座位，我们本来是第6排，找到高一时的同学说看不清黑板才换到你后面的。我说那就是开学第一天，一见钟情？她只回答了两个字：秘密，然后继续问我收到情书之后为什么同意了？我说还不是冲着你好看呗，咱班刚开学两三天吧，我把所有女生观察了一遍得出了结论，如果咱班女生有谁能让我主动追的话，那就只有你一个，其他的我基本看不上。白菜说你眼光还挺高呢？我说也不一定是眼光问题，可能我就好你这一口，我们宿舍也有几个觉得XX好看呢，但我觉得你比她好看多了。 白菜说我现在有种在高中校园里谈恋爱的感觉，我说高中时没有吗？她说很少，大部分时候都觉得其实你不喜欢我，我说还行吧？我也没少陪你啊。她说感觉不一样，你看现在咱俩也没拉手，但感觉心很近，那时表面上看起来很好，但心离得还远，我们不太可能像现在这样想到什么就说什么。我说你说的好像有点道理，其实心里想的是你说的也太对了，不说一年前，就是和半年前寒假时相比，我也感觉是完全两码事。 兜里有闲钱就是气派，这次不去小旅馆了，直接在县招待所开了个标间，其实我主要是怕她热，县招待所的空调还是很靠谱的。办完手续上楼，随着房间号越来越接近，邪恶小人表示他上次准备的那几个战斗预案还可以继续用，并撸胳膊挽袖子的跃跃欲试，我一脚把他踩在脚下说这次不用你，我自己来。 关门之后二话不说直接把她按在墙上，双手捧起小脸蛋就是劈头盖脸的一顿猛亲，她也紧紧搂住我的脖子不甘示弱的回吻。隔着连衣裙搂住小蛮腰，后背全是骨头手感差评，刚要试探着能不能往下探索一下新领域，手就被准确的攥住了，感受了一下阻力，好像并没有那么坚不可摧，鼓足勇气继续攻城略地，收兵北上时也没忘记和老朋友A+姐妹打了下招呼。 洗漱完后我发现白菜穿着连衣裙还盖着毛巾被，突然有点后悔不该来空调这么好用的地方了，我爬上床躺在枕头上翘着二郎腿琢磨下一步该怎么破局，左思右想之后凑过去问，你穿这个睡觉得劲儿吗？压的全是褶子你明天怎么穿？她说那怎么办？我说你把连衣裙脱了吧，我保证不上手。她说真的？我说男子汉大丈夫一言既出驷马难追。 她说那好吧，然后钻到被里一顿鼓捣，我问需要帮忙吗？她连忙在被子里说不用不用，鼓捣了好半天从被子底下把连衣裙递了出来说帮我叠一下，然后重新躺回枕头上露出了脑袋，叹了口气说，哎呀，果然舒服多了。 我坐起来叠她的白色连衣裙，上面印着漂亮的碎花纹，还有一点蕾丝边，对比着自己身上的灰色T恤和黑色大裤衩子，突然想到了一个从没深究过的问题，忍不住问白菜，是谁规定的女生的衣服就得是这种既精致又秀气的，男生就得穿得跟麻袋似的？她一下愣住了，琢磨了半天说可能女性以柔美为美，男性以健美为美吧？我说既健美又柔美不行吗？我要是穿一身蕾丝边的球衣去踢球会怎么样？她咯咯的笑了出来，说你要不怕被精神病院抓起来就穿呗。 我见奸计已经得逞，就凑了过去把下巴放在她肩膀上，她说你一脸贱笑想干什么？不是说好不上手的吗？我说我没上手啊，只是想借个地方趴一会儿。 为什么每个男人都对胸前四两如此迷恋？可能这里是最接近女孩儿心灵的地方吧，在这里没有勾心斗角、尔虞我诈，给予男人的感觉只有温热和柔软，此刻的我就毫无隔阂的在这里感受着白菜的心跳重重的敲击着我的耳膜，我说我听见你内心的声音了，她轻轻抚摸着我的头发，无限温柔的说你早就在里面了。 我说白菜，你到底喜欢我哪里？她说不知道，如果说之前是喜欢你的一些优点，但现在的感觉是即使你没有那些优点，我也可以安心的让你趴在我这里。我又问自己，我喜欢她哪里？如果她不好看了呢？我还会喜欢她吗？假设她现在毁容了，我能马上就抛弃她而去吗？肯定不能，相反我会比谁都心痛，所以最终的结论是，即使我们两个都只剩下灵魂，但可能仍然还是互相喜欢，而这种感觉，真的是无可替代的吗？ ------第四次更新--- 第二天把她送走，回家时我妈难得的表示了热情洋溢的欢迎，拽着我在沙发上坐下说可以啊儿子，怎么追上的？跟妈讲讲。我说她追的我，我勉为其难答应了。我妈说你能要点脸不？我说人格魅力懂不懂？你还好意思说，昨天你还非得跑跟前看，这给我吓的。我妈嘿嘿一笑说，越看越喜欢，忍不住就到跟前看看。然后又一脸坏笑的问我，昨晚干啥去了？我说哎呀真没干啥，我俩没到那步呢，就难得见面一起聊聊天。我妈问拉手没？我说那肯定啊，我妈问亲嘴儿了吗？我说去去去，你怎么什么都问呢？我妈还不甘心，问我真是人家追你的？我说对啊，她沉思了几秒然后抬头问我，你是不是给人家下药了？ 我发现只要一回到老家，大学那些事就都忘到后脑勺去了，自动开启全力拱白菜模式。没过几天，又想我大姑和姑父了，白菜说来接我，出站之后刚想给她一个热烈的拥抱，发现她旁边还站着一个小姑娘，白菜说这是她初中最好的同学叫甘蓝，又跟甘蓝介绍了我，甘蓝说怪不得把我们白菜迷成这样，真人比照片更帅哈，我不好意思的挠挠头又随口谦虚了下，心想终于有个识货的了，感觉前几天刚被我妈摧残完的幼小心灵受到了些许安慰，对甘蓝的好感度大幅上升。 晚上我请她俩吃饭，原来甘蓝和我在一个城市上学，不过她在开发区，甘蓝说你们的事白菜差不多都跟我说了，以后白菜想去看你的时候会和爸妈说是去找我，我帮你们打掩护。我连声道谢，真恨不得马上跟她拜把子。趁着甘蓝去洗手间，白菜说甘蓝知道你要来，非要跟我来看看你。我说我发现你们这儿的人审美都不错，不像我妈。白菜问你妈怎么了？我说她说我...嗯...总说我越长越难看，白菜捏着我的下巴左右端详了下，说我觉得还行呀，然后蜻蜓点水的在我脸上亲了一下。 甘蓝先走的时候我也想去送，被她俩拦住，两个小姑娘在门口笑着说悄悄话，偶尔还往我这边看一眼，曾经我以为白菜不会有什么关系特别好的朋友，现在看来还真不是这样。 送走甘蓝后白菜说我们这也没什么玩的地方，带你去逛逛街吧，我问白菜后来你俩都说啥了？白菜说女生之间的小秘密不告诉你。出门并肩走到路上，怕遇到认识她的熟人也不敢拉手。我在心里暗骂自己真是块贱骨头，前几天早上醒来时看着近在咫尺还在熟睡的她，吹弹可破的皮肤眉目如画，被子下美妙的曲线若隐若现，别说亲她摸她了，我连大气都不敢喘，就怕惊醒这么美好的画面。可现在街头上车水马龙，我却感觉按捺不住自己的咸猪手了，必须尽快找个黑了咕隆的地点方便行事，计上心来转头问白菜，咱俩看电影去呀？ 在情侣座看了一个能够充分暴露年龄的电影，中间当然没少动手动脚，送她回家后我在离她家稍远的地方找了个小旅馆，冲完凉后对着镜子观察了下自己的颜值，我算得上帅吗？帅个屁吧，其实我完全认同我妈的观点，前几年觉得自己长得还行，最近两年一直肉眼可见的越来越完蛋。 第二天她爸妈上班，约好上午去她家看看，进门之后她把我领到她的房间后去厨房拿水果，我站在房间中央，感觉到这里所有的一切都跟我那么的亲切，一个个七嘴八舌的跟我诉说着白菜的过去，她曾经坐在桌子前用她的垮字啃着作业，曾经在窗台上用双手拄着下巴看着街上的人来人往，曾经在衣柜前翻来翻去想今天要穿哪件衣服，曾经躺着床上幻想她之后要找的男朋友是什么样子，我说好了好了我都知道了，我会好好了解白菜过去的一切的，你们放心吧，以后我一定会尽力照顾好她的。 我说白菜，把影集找出来给我看看呗，她为难了一下，说你看完不许笑话我啊，我说那更要看看了。翻着影集，我就像在陪伴着一个小姑娘慢慢长大，小时候的她是那么的单纯可爱，眼神里没有一点阴郁，我抚摸着照片就像抚摸着儿时的她的脸，突然好想穿越到她小时候给她买一大堆好吃的，摸着她的头告诉她我就是她未来的男朋友。 翻到一张在海边的照片我问她这是几岁？她说六七岁吧，我说我这么大的时候也去过X城，说不定咱俩还遇到过呢。照片里的她只穿着小裤衩咧着嘴傻笑，门牙还缺了好几颗，我感叹着生命的神奇，一个黑瘦黑瘦其貌不扬的小丫头，十年之后就变成了娇滴滴的白嫩大姑娘，想到几天前早上起床时的香艳场面，我指着照片深情的对白菜说，你露点了，白菜捂住照片说你怎么那么烦人呢？ 之后七八天我一直留在L市，白天和她一起逛街看电影，晚上我瞒着她去网吧或那个电玩城玩到后半夜再回小旅馆睡觉。后来我们不再出门，每天白天就躲在房间里腻歪，经过几次试探性攻防，我已彻底摸清她能接受的亲密程度底线，心中有数之后也不知哪来的那么大瘾，每天我坐在床上或沙发上，她躺在我怀里，我不停的低头吻她，就这么亲来亲去能亲上几个小时，我走的前一天吃晚饭时我说咱喝点粥啥的吧，我舌头疼，你不疼吗？白菜红着脸说昨天就开始疼了。 回去的火车上我坐在靠窗的座位一直看着窗外，想来想去最后还是没去大姑家，小时候寒暑假经常来大姑家玩，跟大姑和姑父那么亲，他们把我当成第二个儿子，在我长大之后却连频繁的拜访都觉得别扭，双方都心照不宣的觉得一年见一次是最舒服的相处方式。而这个18岁前跟我关系一般的女孩，现在我却一刻都不想和她分开，这就是长大之后必须要经历的变化吧。从小到大和那么多人经历了那么多次分别，可能前一天还在一起打打闹闹的小伙伴，一起考完最后一次试后就再也不会相见，却从没有一次觉得自己这么难过，脑子里不断回想这几天和她的相处，想到最后一天吃完晚饭我们坐在河边的长椅上，她靠着我的肩膀说真想和你每天都在一起时，泪水终于还是淌了下来。 大二开学了，学校宿舍晚上管得太严，关系比较好的哥几个商定开学后出去租房子住，从那开始我们疯狂去网吧打游戏和找网友聊天，看多了《第一次的亲密接触》，江湖里出现了至少几十号轻舞飞扬123之类的名字，还有一大堆的痞子这、痞子那的，反正都是附近大学的学生，聊得差不多了就开始见面。我只见过一个黑壮学妹就决定以后再也不见网友了，学妹在网上说北京的一个老板总想包养她，但还有个很帅的研究生学长也在追求她，她很苦恼。我问她是哪个学校的，越聊越近最后发现她就在隔壁机房，既然这么近就见一面吧，见识一下魅力，看她第一眼就觉得那老板和研究生学长的口味还真挺重。我这不算翻车，这个年纪的女孩儿都会有颗爱幻想的少女心对吧？请她喝了杯冷饮聊了会天就说了再见。我们老八才叫惨，和一个女生聊的可好了，结果见面时来了一个男的，上来就要搂老八，把老八吓的屁滚尿流抱头鼠窜。 受到启发，于是我也开始以各种性别各种身份开始跟人瞎聊，反正网上谁也不认识谁对吧，我以女生名义要来男生A电话再去撩男生B，等男生B朝我要电话时我再把男生A的电话给他，说父母拿我当儿子养所以名字比较阳刚，至于他们打电话打出什么火花没有，我就不知道了。十一白菜和父母出去旅游，我整整一周都在网上冲浪，ICQ和江湖里的人越来越少就改用新流行起来的OICQ，到了网吧先注册一个新号-查找在线女网友-一顿胡吹乱侃-安全下线，等下次再来时上次的OICQ号码是多少早就忘了，于是重复上一套流程。 我这个人脸皮还可以，但在喜欢的人面前总是放不开，室友们谈女朋友没几天就我爱你，你爱我的，我是真学不来，真正喜欢上白菜大半年，当面相处时只有情绪到位了才会勉强挤出一句喜欢，每天打电话时顶多也就是小声说句我想你了，快挂电话时晚安、早点睡觉这些我们两个能翻来覆去说好几遍，但谁也不舍得先放下电话。有时我觉得白菜肯定想听我说些好听的情话，但我背后想的挺好，练习的时候也算流畅，但当面说出来就吞吞吐吐的，反倒破坏气氛。几个月前开始给她发邮件，她很少去网络中心，经常过好多天才会看到并回复我几个字，我觉得这样不行，一个能够充分发挥我优势的作战方案逐渐在脑海中清晰了起来。 我说白菜，你注册个OICQ吧，咱俩聊天，她说她打字太慢了，我说慢慢来嘛，我最开始的时候也是一指禅。我新注册了一个OICQ号，这次把号码用纸条记下，以后就固定用这个，白菜在她舍友的帮助下也注册完并加我好友，我还有点担心别弄错了加了别人，一看她的网名是“XX（我的小名）的女朋友”，我问白菜你的网名要不要这么直接啊？她过了差不多半分钟才回复我：嘿嘿！我本来就是嘛。 我和白菜每隔一两天就会在网上聊一会，很快发现这个小企鹅果然是异地谈恋爱的神器，平时不太好意思开口说的话用键盘敲起来就毫无压力。哪次特别舍不得你，接吻的感觉好吗，哪次想对你干嘛但没敢动手，哪次一起吃的饭特别难吃，你小时候有一阵咋那么黑之类的张口就来，白菜开始频繁的使用“哈哈哈哈”这种当面时从不会出现的神态，“想我没啊”“想啊”“有多想啊”“想死你了”“想亲你”“啵”之类的也是顺手捏来。每打完一句话后会想象对方在电脑前的表情，说一句情话之后会焦急等待对方的回应，经常同一排的男生都在哐哐干游戏，只有我跟个小傻子一样对着聊天对话框捂着嘴笑，而同一时间身在300公里外的她，应该也是和我一样的表情吧。 我们宿舍老四（江湖里用银子把花间一壶酒砸成朋友那位）和我关系最好，大一时我俩整天都形影不离的混在一起，很少和女生交流，同学们都坚定的认为我俩在搞基，第一个学期里我那一个多月打一次电话的所谓女朋友明显是做贼心虚掩人耳目，弄得现实中认识的女生们很快对我俩失去了兴趣，其实我倒没什么损失，因为我有颗白菜在手，他可就惨了，于是脱单的希望就只能在网上寻觅，我俩经常结伴去上网，我和白菜聊，她和花姐聊，不过在和花姐见面之后他觉得自己受到了羞辱，因为他只有1米7，而花姐穿高跟鞋去赴约至少能有1米85，老四回来之后表示花姐太不地道，要跟她一刀两断之后第二天就求花姐介绍个身高合适的舍友给他。 白菜打字速度一直都不算快，过了和她聊天的新鲜期后，我开始在回信息的间隔刷chinaren校友录和在163上看新闻，有时也同时和其他高中同学聊。花姐（oicq网名candy）给老四介绍的舍友叫fine，和老四一见如故每天没完没了的聊，老四等fine下线了才会陪我打红警2和帝国2，所以白菜不在线的时候我就很无聊，单机玩累了就聊OICQ等老四。fine和candy也是同时出动，所以理论上只要老四和fine在聊，我就能和candy聊，聊着聊着发现这学姐还挺有意思。 她说她男朋友是高中同学现在国外留学，我说我女朋友也是高中同学现在她老家L市上学，她说她1米57体重80，我心想跟我来这套是吧？就说自己1米88（其实我连1米8都没有，实际只比她高一点，但气势上一定要压倒她）体重二百五六，到底是二百五还是二百六要取决于我吃没吃饭，你体格太弱了，我女朋友虽然只有1米45但体重有130斤，一身的腱子肉是她们学校的铅球铁饼双料冠军，以后嫁到我家干庄稼活肯定是一把好手。 瞎扯了几天之后我觉得也可以聊点正经事，某天我说学姐我要请教你点问题，作为异地女朋友的角度，都希望男朋友说点什么？做点什么？Candy每天开始叭叭叭的给我一顿授课解惑，心理上要关心，有点小病一定要嘘寒问暖，千万不能让别的男生钻了空子；行动上要让女朋友放心，要让她时刻感觉到你很需要她；见面时尽量浪漫，要多送点小礼物或花之类的，其实不需要买多贵的主要是给女生惊喜；在一起时要多畅享毕业后的美好前景之类的，觉得有道理的我都拿小本本记了下来。还别说，有个女师傅指点确实进步很快，我总能在网上或电话里把白菜哄得开开心心的。 12月去看她的时候白菜看着我手里的花，吃着我选的烛光晚餐十分受用，眼中充满了柔情迷得我神魂颠倒的，晚上非要到学校宾馆和我切磋一下武功，好说歹说才在关门前把她送回宿舍，差点耽误了我和眼镜哥约会的好事。 开学这几个月我经常熬夜聊天玩游戏，一来二去学会了抽烟，只是当着白菜的面不敢抽，一路小跑到网吧买了两盒烟，找到眼镜哥分给他一盒，之前和他约过几次已经很熟了。眼镜哥问怎么晚了？我说跟女朋友墨迹了一会，眼镜哥说我记得你女朋友是XX系的对吧，我说怎么了，他说不会是白菜吧？我说你怎么知道？他说经常听身边人说谁谁谁在追XX系的白菜，但都被拒了，听说她男朋友是XXXX大学的，我一想你不就是那个学校的吗？没想到还真是你，兄弟你挺牛啊。我没搭理他，感觉脑门开始冒虚汗。 一边玩游戏一边琢磨这事，越想越觉得不对劲，我在大学里基本不和女生来往，就天真的以为白菜这边也是这样，我们两个都只有彼此可以依赖，可认真一想怎么可能呢？第一次来的时候大姐就提醒过我，我没往心里去，自以为在网上和电话里聊的不错，可哪及得上这帮别有用心的近水楼台先得月？ 漫不经心的玩到12点多实在玩不下去了，和眼镜哥说坐车累了先回去休息，其实哪有睡觉的心情，一圈接一圈的围着宾馆走。我能送花，人家更能送了，而且每天都能当面送，我和白菜真正谈恋爱的时间有差不多一年，热恋期可能已经过了，现在连聊天也没了新鲜感，越来越有种当成公事敷衍的感觉。如果这时出现条件比我好得多的小伙儿能给白菜更新鲜的激情和每天的陪伴，我这墙脚早晚都会被人挖塌，如果只剩半年倒还能坚持一下，可距离我毕业还剩两年半呢。 也不知道走了多少圈，实在走不动了，回宾馆洗了把脸，目不转睛的盯着镜子里黑眼圈越来越明显也越来越消瘦的自己，开始了新一轮的胡思乱想。上次照这么长时间镜子应该是在初三吧，那时的我在一年之内长了20厘米身高和40斤体重，从小比同龄人瘦小的我第一次参加运动会就拿了好成绩，自恋到每天都要花很多时间照镜子来观察崭新的自己，握拳感受着身体里蕴藏着的澎湃动力，以为这世界上没什么事能难倒我。几年之后的我依然很年轻，却突然对眼前最在意的事没有了多少信心，我还能够一直握紧她的手不放开吗？ 第二天我收到了这辈子最贵重的生日礼物，白菜送给我一部3310，我说你买这么贵的东西干什么？她说这一年多你买电话卡也花了不少钱，早就决定攒钱送你手机，这样就能随时听到你的声音了。我心里一阵感动，想到昨晚的事又一阵难过，没准这是她送给我的最后一件生日礼物了，我也可能只剩下一次能送她礼物的机会，实在不能欠女生这么大的人情，也要给她买个贵的，算了算自己的生活费怎么都不够，盘算好回去就找老娘拉赞助。 每次回学校的火车都是晚上到，却从没有一次觉得这么精疲力尽。我问candy，我每隔三四周就要在火车上来回14个小时，而真正相聚的时间还没有在路上的时间长，当我每次见她之后都会带着满腔的思念回到学校，然后又每天都在感受着这种思念逐渐褪去，付出了就真的能得到回报吗？Candy说你付出了就有希望，不付出就没有任何希望，异地最难的地方就在于激情冷静下来之后的坚持，你们那么多年的感情能说放弃就放弃吗？多年过后想到今天你会不会很后悔没再坚持一下？ 网吧晚上的网管是个黄毛，因为老在一起玩游戏早就混熟了，那阵他特别喜欢听《分飞》，经常成宿成宿的放，我听着那些歌词十分闹心，有一天实在受不了说你TMD能不能换一首？他问你想听什么？我说大半夜的怪困的来点欢快的，黄毛换了首《踏浪》，我感觉好多了。 稀里糊涂混到期末，白菜生日那天是周六，商量好我去看她。直达的车要晚上才能到L市，所以我每次去的时候都是各种换乘只为了下午就能到，那天辗转到L市后我觉得自己快要散架了，我已记不清连续多少晚后半夜睡觉了，不是在玩游戏就是在复习准备四级和期末考试。有生以来除了生病的时候，第一次感觉到自己这么疲惫。一见面白菜就问我最近怎么状态这么差？我说可能考试复习累到了，白菜心疼的说复习也要注意身体啊，我说我没事，寒假在家好好歇一歇就行了，把精心挑选的Moto掌中宝送给了她，亲了她的额头说了生日快乐。 晚上请白菜和她全体室友吃饭，之后白菜坚决要陪我一起住，说她有点放心不下，我说不是说好的吗？每次我来你都不用出来陪我，别让你同学背后嚼舌根，白菜根本不听，赖在房间不走，我又不能用强，眼睁睁看着宿舍关门时间过了。 白菜坚持让我先洗漱，说如果累了就先休息吧，不用等她。这个时间还远没到我最近生物钟习惯的睡觉时间，我只觉得头有点晕，但没什么困意。这是我们第三次一起过夜，想着前两次的柔情蜜意我心头一阵温暖，即使我们将来没能走到最后，那些也将是我生命中最美好的记忆了吧。 白菜为了庆祝生日有生以来第一次烫头，洗漱完出来用吹风机吹她的大波浪，她穿了一身粉红色的秋衣，紧紧包裹着她纤细苗条的身材。尽管曾经上下其手，但她身体从上到下的每一处曼妙曲线还是让我惊叹造物主的神奇，我痴痴的盯着她看，心想美丽温柔的姑娘是上天送给男生最美好的礼物了吧？怎么会有男生舍得去伤害女生？她一边侧过头吹头发，一边满脸关心的看着我，我抬头看着她的脸，恍惚之间觉得现在的她对我来说竟然有些陌生。 她一直都有一双可以完美表述心情的眼睛，让人一眼就能读懂她的喜怒哀乐，高中时期的她眼神里总是带着点忧伤和迷茫，但那时的她虽然身上很瘦，脸上还是肉嘟嘟的，身边的每个人都只会觉得她是个心情从来都不怎么样的少女，轻易不要去触霉头。而当她开始褪去婴儿肥，眼神也变得平和后，奇妙的事情发生了，现在的她竟然有了一种我无法形容出来的气质，让我发自内心的感到自卑。 我爬起来说我还没帮你吹过头发呢，你坐好吧，我帮你吹。白菜温顺的把吹风机递给了我，然后坐在床边，我专心的帮她吹着头发，想到我的手每天都抓着无数抠脚大汉用过的鼠标，觉得自己根本不配触摸她的身体。 帮她吹完头发我已经视线模糊，怕被发现就躲进被窝背对着她偷偷擦眼泪，白菜整理好后也掀开被子钻进来，温柔的从后面抱住了我，我感受着她身上的温热，想到了我们亲密接触的那些瞬间，转身过去把脸埋在了她的A+里，双手紧紧环抱住她的一尺九，想到也许某一天她终于被身边的男生感动和我提了分手，之后那个男生代替我的位置和她这样，心就疼得跟碎了一样，眼泪又不受控制的流了出来。白菜抚摸着我的头发说你怎么啦？有什么事不能跟我说吗？ 我哭着说白菜你这么好，我觉得配不上你，我一点都不上进，每天玩游戏到后半夜，还学会了抽烟，有时候我早上起来脸都不洗就去上课，连腹肌都没剩下几块了。白菜说我不在你身边的时候，你也要好好照顾自己啊，就算是为了我，为了我们的将来。我说我们还有将来吗？这样的日子什么时候到头啊？白菜说你觉得累了吗？我说我真的觉得累了，你要是觉得我们走不到最后，就早点和我说吧，也别耽误你找个好男朋友。 白菜沉默了好一会，说你知道我什么时候开始喜欢你的吗？你知道我喜欢的是怎样的你吗？我说我问过了，你不告诉我，再说那都多少年前的事了，我们总得面对眼前的现实吧。 白菜没接我的话题，说应该有4年了吧，那时我们高一上学期，刚入冬的时候下了一场雪，早自习后她去食堂吃饭，在走廊里碰到几个男生踢球被年级组长抓个正着，她对这种事没兴趣就低头经过，听到年级组长问谁跟你一起踢的？一个男生说我自己呀，年级组长又问你自己能踢？男生说能啊，年级组长说你踢给我看看，她有点好奇这么皮的男生长啥样，一回头看见一个很秀气的小男生颠了几下球又对着墙踢了两下，然后抱着球笑嘻嘻的站着，年级组长怒了，你不说是吧？不是爱踢球吗？自己到操场上踢一天，去吧。她本以为男生该服软求饶了，没想到男生哦了一声就往外走，路过她身边时还一边笑一边满不在乎的说了个“切”。 之后的两堂课，只要老师转身往黑板上写字，她就往窗外看，第一节课时那个男生在球门前跑来跑去，第二节课就好像在球门旁边不动了，她想是不是冻坏了？下课后假装去操场欣赏雪景，那个男生已经不在那了，她好奇的走近球门想看看男生都干了什么，结果她看到了一个圆滚滚的雪人靠在球门柱上，大嘴都快咧到后脑勺去了。她说那时她独自一人来到这个完全陌生的地方，开始时一个朋友也没有，经常想念家人和同学，心情特别差也没心思学习，每天都算着离放假还有多久，而那个雪人的笑容好像就是专门来安慰她的，告诉她每天都应该活得开心一些。 从那天开始，她经常在走廊上来回溜达制造偶遇，每次见到那男生都会有点紧张，那男生每天好像一点心事都没有，总是满脸笑容的。她知道了那个男生的班级姓名，知道那个男生喜欢踢球，高一下学期春暖花开后，她就经常自己在操场上看男生他们班的比赛，虽然总是输多赢少，但那个男生每一分钟都在全力以赴，刚输比赛时跟斗败了的公鸡一样垂头丧气，没过多一会就又嘻嘻哈哈的和队友勾肩搭背。她觉得这个男生也许能带给她阳光和希望，在高二开学前的那个暑假，她和爸妈去旅游时对菩萨许愿，请求让她和那个男生能分在一个班，当开学那天她在班里真的见到那个男生的时候，高兴得真恨不得跳起来。 白菜讲到后来已经伴随着抽泣，而我早已泣不成声。白菜用双手捧起我的脸，说你现在知道你在我心里有多重要了吗？我已经坚持了整整4年，你连1年都坚持不完吗？大一上学期你一共只给我打过几个电话，那时的我不难过吗？整天在想你那么优秀，肯定有很多女生追你吧？我无数次想过你会和我说分手，可我从没想过主动放弃啊。 我说也就你觉得我优秀吧，白菜仰起头亲了我一下，说你在我心里就是最优秀的，谁也比不上你。要是觉得累你可以少来看我几次，也不用经常跟我聊天，但你一定要好好照顾自己，别让我这么担心。 我躺回自己的枕头，回想白菜刚才说的话。可能我把自己封闭得太久了，在大学里除了一个宿舍的兄弟，我一直很少和其他同学交流，尤其和女同学几乎从不说话，高中毕业才一年半，但那个每天无忧无虑的我遥远得仿佛是前世一样。这一年来我除了玩物丧志之外，把几乎所有的感情都放到白菜身上了，当我终于意识到有失去白菜的危险时才会这么的患得患失，我太害怕失去她了。 白菜过来伏在我胸前，说你想和我永远在一起吗？我说那要看你了，我应该没问题。白菜说我也没问题，不就两年半吗？熬过去我们还不到22岁，将来还有几十年的好日子要过呢。我问白菜，你爸妈舍得让你远嫁吗？白菜说我没问过，但我觉得他们应该希望我留在他们身边。我说这事儿早晚是个坎，明年带我去见见你爸妈吧，听听他们的想法。白菜说是不是要先见你爸妈呢？万一我爸妈那里没问题，结果你爸妈看不上我怎么办？我说不会的，我妈很喜欢你，再说我爸妈知道我的脾气，我平时看起来很听话，真要是倔起来他们知道根本管不住我的。白菜抬起头说你怎么知道你妈喜欢我？我说我不是把你照片给她看过了嘛。 白菜又静静趴了一会，说你好像真不喜欢我了，我问怎么了？她说你都不亲我了。一听这话我可不服了，邪恶小人瞬间浴火重生，力量变得比以前任何时候都更加强大，拉过白菜就是一顿猛亲，白菜也比之前任何一次更加热烈的回应。情到浓处时白菜在我耳边轻轻的问，你到底觉得哪里配不上我了？我说我觉得你比我好看那么一点点，白菜笑着说再好看也会老的啊，我说你能不能别对着我耳朵眼说话？怪痒痒的。白菜一点也不听话，继续在我耳边轻轻的问，你想不想和我那样？我擦这句话问得我脑瓜子嗡嗡的，按理说哪个男生能不对自己喜欢的女生有那种心思，可我始终觉得前途未卜，早早的做那个事只能满足自己，却可能伤害到她。我勉强压下沸腾的欲火，问为什么要说这个？她说把我自己给你，你就会更有信心了吧？ 脑子里的两个小人早已经打成了一锅粥，我闭上眼睛思考着白菜这么做的目的，她可能是觉得我一直得不到她所以才会对自己、对她都没有信心吧？其实还真不是这样，即使我们早就发生了那种关系，我也一样会出现最近的问题，这和我们之间的亲密程度无关，只和我自己的心态有关，那种关系的新鲜感也许能够维持一段时间，但只能治标不能治本。想清楚了之后我对白菜说，还是等我们过了你爸妈那关再说吧，现在我有更紧急的事要和你商量，白菜问什么？我说能不能借我点钱，你那几个舍友太能吃了，我买不起回去的车票了。 年后和白菜约好了时间，和爸妈说我要领白菜回家了，你们好好准备准备吧。我妈开始还不信，看我一本正经的才知道没开玩笑。接到白菜后本想直接回家，她坚持要去商场买礼物，我心想也对，和她说意思意思就行，她坚持说第一次上门不能太随意，先让我还钱，然后把所有的钱都花光。到家门口我问白菜紧张吗？她摸着胸口说紧张死了，心砰砰跳，等我缓一缓再进去，我亲了她一下说给你点鼓励，你这心理素质是不行，我一点都不紧张。她说见你爸妈你当然不紧张了，你到我家去试试？我说试试就试试，你就等着看我暑假时大展神威吧。 进门之后我妈看白菜就跟西游记里的老和尚看唐僧的袈裟似的，眼里放着精光拽着白菜嘘寒问暖，完全把我当成了透明人，趁着白菜去卫生间洗手的时候我爸欣慰的说你小子果然比我当年强多了，按照我妈脾气本该拽过我爸一顿暴打，但有白菜在家里就暂时没和我爸一般见识。我坐在对面的沙发上观赏我面前的两位妇女正在进行着的演技大比拼，我妈在拼命装着亲切随和，白菜在拼命放大温柔体贴，就连看我的眼神都比平时更深情了几分。 吃完饭我妈非要带白菜去逛街，我负责拎包，我爸负责看家。我看着前面我生命中最重要的两个女人挽着胳膊有说有笑的一起走，心想这不就是我最大的幸福吗？给我看中了一款羽绒服，买完之后我妈说小子有了，再给丫头买一件，白菜实在推辞不过，就选了一件白色的。 吃过晚饭后白菜抢着刷碗，我心想再傻的姑娘也知道第一次见面要给未来婆婆留下好印象啊，我妈哪舍得，拽着白菜的胳膊说不用你不用你，看着在一边看热闹的我说：你！刷碗去。 家务都干完之后一家四口坐在客厅聊天，我妈拿出红包塞到白菜手里说见面礼别嫌少，白菜推辞不要，我说我们这儿有这个讲究的，给你就拿着吧，白菜这才不好意思的收下。我看着电视感慨现在真是没人才了啊，长成这样也就算了，连唱歌都吐字不清的也能当歌星，他要是能红我把咱家电视吃了。 晚上白菜睡我的房间，我睡客厅沙发，我妈当着我们的面重重的关上了房门，然后咔咔的在里面反锁，我心想老娘你要不要表现的这么刻意啊？白菜耸了耸肩膀，走到沙发前亲了我一下，然后挥手说拜拜晚安。我躺在沙发上想着简单的一关就这么过了，下学期我得锻炼锻炼身体，把足球捡起来，去她家时能有个好点的气色。还没想几分钟白菜就蹑手蹑脚的出来了，走到我面前蹲下说，你妈给了我2000啊，这也太多了吧，我要不要退回去点？我说这怎么退啊？你跟我妈说自己不值那么多？白菜说那咋办啊？我说你要是嫌多可以分我一半，我帮你花，白菜说才不给你，给你你就拿着玩游戏去了，我都存起来给你娶老婆用。我说干嘛？你要随礼啊？白菜拍了一下我的脑门说随你个头啊，早点睡觉。 自从放假后我回到老家，作息时间也开始正常起来，还真有点困了，刚要睡着的时候白菜又出来了，说哎！你到我房间里来呗？我找你有点事。我说那是我的房间好吧？白菜说连你都是我的，你的房间当然也是我的房间了。我问啥事啊？她说你过来嘛，我说肯定没好事，我不去。白菜伸出一根手指头说1分钟，就1分钟，我不太情愿的从好不容易铺好的被窝里爬起来跟她进了房间，刚一进门就被白菜按在墙上索吻，我一边亲她一边感受着她身上的美好曲线，说就这事啊？白菜说我今天表现怎么样？我说挺好的啊，我爸妈还跟我夸你了呢，说你一看就是好人家的老实孩子，对你印象特别好。白菜说那就好，暑假时就看你的啦。 第二天去二姨家看姥姥，姥姥几个外孙子里只有我还没结婚了，所以她看着白菜特别高兴，虽然话都说不思索了，但还是拉着白菜的手不放。我直奔卧室的婴儿床去看刚出生几个月的小侄女，小手小脚特别可爱，我心中一动把白菜也叫了进来，19岁的我和19岁的她手拉手一起看着襁褓中的婴儿，不用说话都知道对方心里在想什么，白菜想得脸都红了，抬起头来满眼深情的问我，你想要男孩还是女孩？我说只要是你生的，男女都行。 大二下学期开学，我感觉封存在我体内1年半的射手座之魂开始熊熊燃烧起来，我开始跑步，开始主动和其他同学交流，还参加了系足球队选拔，队长觉得我身体素质不错而且有点基础，正好缺一个替补门将问我愿不愿意，我哪能接受这种屈辱，坚定的提出必须给我配一副新手套，心想原来那手套不知道多少臭老爷们用过的，我天天用那个还怎么摸白菜？ CS1.3开始席卷附近的网吧，我开始觉得这游戏跟三角洲比一点都不真实，玩过之后觉得这游戏简直TMD就是为我量身定制一样，每晚在仓库、吊桥、办公室、意大利等地图里冲杀，但我给自己设定了时间，每晚12点前必须回家睡觉。 白菜也有了手机后就很少去学校机房了，说总有男生在后面偷看她网名然后加她，烦死了，于是我们就开始用短信聊天。我和candy的聊天话题也越来越深入，有一天谈到了爱是什么，candy说爱就是把对方看得比自己还要重要，我说怎么判断自己爱不爱另外一个人？Candy说她不知道，这种东西好像没法量化。我想了一天回复candy说可不可以这样？ta被绑架，你的面前有两杯水，一杯有毒一杯无毒外观上分不出来，只要自己喝一杯，不管有毒无毒ta都会获救，否则就撕票，你愿意喝就是爱ta，不愿意喝就是不爱。Candy说她要好好想想，我拿这个标准去想白菜，这种情况我肯定喝，三杯里只有一杯无毒我也敢喝，但是再往上呢？四杯、五杯、十杯、百杯？ 四月份我去看白菜的时候，白菜说已经和甘蓝说好了，五一的时候和爸妈说去看她，实际上是来看我，真是把我高兴坏了。 望眼欲穿的五一终于到了，接到白菜之后我迫不及待的抱着她转了几个圈，带她回到我和同学租住的房子，五位老哥已经做好饭菜虚位以待，看到白菜之后纷纷用眼神和我交流说你小子果然有一套，在我们回来前同屋的老四已自觉的把床抬到其他房间，给我们省下了住旅馆的钱。自从接到白菜之后我有一种魔幻的感觉，我的两套处理系统竟然合二为一同时运作了，白菜冷不丁和这么多男生接触，开始时还有点腼腆，我说这些都是我最好的哥们，不用拘束。几位老哥每天轮流请我和白菜吃晚饭，对白菜印象都很好，说怪不得老幺在这边一个女生都看不上呢，对白菜弟妹弟妹的叫得很亲，一个个拍着胸脯说弟妹放心，我们肯定帮你管住老幺，他在这要是敢对不起你，看我们不揍死她，尤其阅女无数的老八喝多了之后口齿不清的搂着我说，老幺你可得好好对人家啊，现在还上哪找这么好还这么老实的小姑娘去？ 那几天我带白菜坐有轨和敞篷双层观光巴士、逛我们学校、去开发区看甘蓝并合影留下证据，当然还去了一堆能够暴露信息的著名景点，在广场骑双人自行车、去动物园看老虎狮子喂小动物、看海洋动物表演、逛商场（虽然啥好东西也买不起），那是我们在一起之后从来没有过的朝夕都能相处的美好时光。 可分别的日子总是要来的，我拎着她的旅行箱带着她走上火车站前那道人行天桥，置身于繁华的建筑群和大街中间，直觉告诉我这里是进行告别仪式的好地方，白菜也跟着我停了下来，我们凭栏远眺，微风吹起她的长发显得她格外的妩媚。可能是早已经习惯了告别，她的表情看起来有点云淡风轻的意味，但眼里的泪光还是出卖了她的心情，其实那何尝不也是我的心情呢。 我问白菜玩的开心吗？她说开心，我说回去之后好好的，别太想我。白菜终于还是控制不住，鼻子一皱眼泪就下来了，我看着心疼，不由自主的凑过去吻她，其实我们平时很少在外人面前举止亲密，逛动物园时我想搂她的腰，她都会拍打我的咸猪手说注意影响，但今天在离别情绪的驱使下我觉得自己根本顾不得那么多了，白菜稍微躲了一下说这么多人看着呢，我说看就看吧，反正没人认识我们，怕什么？ 可能是被我说服了，第二次白菜没有躲，我们紧紧的拥吻在一起，高楼大厦、车水马龙、路过的行人，全部都在我们的世界里变成了虚化的背景板，在此刻我根本不在乎别人怎么看我们，唯一想要的就是把她彻底融化，也不知道这次创纪录的长吻到底吻了多久，当我感觉那句话已经冲到嗓子眼的时候才把她推开，双手捧着她的脸直视她的眼睛，无比坚定的说白菜，我爱你。她刚止住没多久的泪水再次夺眶而出，轻轻搂住我的脖子在我耳边小声的说：我也爱你。 ----------------------------第五次更新------------------------ 再一次的，灵魂被完全从肉体中抽离，如同行尸走肉的我一步步挪到公交车站，我再也感受不到春暖花开的鸟语花香，感受不到繁华闹市的喧嚣拥挤，当我终于把自己放到座位上时仿佛如释重负，仅剩的一点精神力量已经很难控制得住自己的身体了。 我透过模糊的视线看着窗外，从我记事起就很少哭，小时候打针永远一声不吭，父母可以安心的把我一个人放在家里大半天，幼儿园开学时别的小朋友哭的此起彼伏，只有我安静的坐在座位上东张西望观赏他们的高音演出。曾经的我以为自己天生就能忍受疼痛、孤独和分离，可真正喜欢上白菜这一年多里，我已记不清自己哭过多少次，愧疚、感动、自卑、不舍，每种感受都能精准击中我的泪腺，这就是爱情的力量吗？我闭上眼睛来到心底的小角落，三四岁的我乖乖的坐着翻看早就滚瓜乱熟的成语词典，我问小屁孩儿，你能想到长大之后自己会变得这么多愁善感吗？小屁孩儿抬头看我，眨了眨明亮的眼睛，害羞的笑了起来。 回想到这几天和她紧紧拥抱在一起时，我们能清晰的感受到彼此的生命是那么的鲜活，心脏是那么的柔软，当有一天两个人完成精神和肉体双重层次的合二为一时，一定是世界上最美妙的事情吧？为了那一天，我愿意付出任何代价，任何...吗？ 只过了一周，我实在排解不了心中的思念跑到了L市，把白菜搂在怀里我感觉自己喝下了解药，果然心病只有心药才能医。白菜说已经和爸妈说了有男朋友会在暑假来看她，顺便见见家长。我问和你爸妈怎么说的？我们处了多久了？白菜说快1年了，我说他们听完什么反应？白菜说他们问了你在哪上学，还问你毕业之后有什么打算，我说他们希望我有什么打算？白菜说他们和我说不指望我找什么大富大贵的人家，只希望我能在本地找个普通人，离他们近一点，离得太远他们不放心。而且他们问咱俩处到什么程度？怎么现在就要见家长？ 我的心沉了下来，果然是这样，我说你怎么想的？白菜说如果我家里还有其他的兄弟姐妹，我跟你私奔都行，但现在我真的还没想好，你给我点时间。他们还问五一的时候是不是跑去见男朋友了，我承认了。我说我知道了，我们都好好想想，好好想想。 哥们我有几个，但我们表达关心的方式是“走，出去逛逛”、“走，包夜去”、“走，哥陪你喝点”，当时的我们觉得男生之间面对面的讨论感情问题是很矫情的事情，所以我早已习惯了和candy吐露心声，也只有和她才能讨论点感情方面的问题。有天candy说我们玩个游戏吧，彼此交换秘密。我说你先来，candy说其实大一的时候她男朋友就和她分手了，只是她一直假装他还在，她用我上次提出的理论来测试，发现已经不爱前男友了，她爱的只是高中时那段回忆而已。我说我小时候我爷以为他的爱鸟是自己飞走的，实际是被我绑在二踢脚上送往西天极乐世界了。candy说你这叫什么秘密？我说这世界上只有我一个人知道的事，不算秘密吗？candy说这种秘密她多得是，你应该说点感情方面的。 我说我想毕业之后去投奔女朋友，我觉得没她我活不了，但我又有些不甘心，我上了12年学才考到这里学了这个专业，在这里就业前景很好，去L市几乎没什么机会，我不知道我父母能不能接受我这个选择，而且我也有些舍不得大学的兄弟们，我这人没什么太大的事业心，但我觉得和兄弟们一起努力是件很有意思的事情，总之现在我很矛盾。 candy说她每次回家的时候都会回校园看看，回忆她和前男友在一起时的点点滴滴，或许你也需要去你们曾经去过的地方，想象一下10年后的你再回到这里会是怎样的心情，会否后悔当初的选择。 暑假我回到家没有着急找白菜来，实际我们已经两个月没有见面了，中间只打过寥寥无几的几次电话，我能了解她的心情，此刻的她应该和我一样在反复煎熬着自己。有天白菜发短信问我在吗？我给她回了电话，她说有些话她不好意思在电话里说，让我看短信吧。 白菜和我说能想象到你爸妈在你的教育上付出了多少心血，你自己从小到大又付出过多少努力，你有很好的前途，我不想扯你的后腿，但反复思考后又觉得实在舍不得从小养育自己长大的父母，她和父母聊过，感觉父母改变心意的可能性看起来不是很大，所以还是决定把选择的权利交给你，你怎么选择我都支持你，愿意接受每种结果。 我在床上躺了几天，我爸妈问我怎么了，是不是和白菜闹别扭了，我说没有，就是要去见她家长了有点紧张。其实我还是没想好，振作起精神出去走走，想到了candy和我说的话，我回到了高中校园，来到原来的班级门前，里面的小孩儿有聚精会神听课的，有偷偷在下面搞小动作的，我看着他们仿佛看到了当年的自己。 高三元旦晚会，就在这间教室里，我来到白菜身边用手指轻轻在桌子下弹了她的手背，她不甘示弱的攥住了我的手和我十指紧扣，全程我们两个都始终目不斜视看着台上的节目，当时的我心惊肉跳，第一次拉手就在老师和同学们的包围下，这种感觉实在是过于刺激，我忍不住转头看她，她还是面无表情的样子，但嘴角却微微的翘了起来。如果当年的她想到今天会是这样的结果，还会主动扣紧我的手吗？ 我爬到山顶，想到我曾站在这里向白菜指着我们学校的方向；我来到公园湖边，想到划船时白菜问为什么我们的船这么慢，我看她一眼说你太胖了；我来到教堂，想着高三平安夜那天我指着废弃花盆里脏兮兮的冰骗白菜那就是传说中的圣水，她还傻乎乎的过去摸了一把；我来到学校附近的国道，想着高三植树节那天白菜用自行车载着我出发。 最后我来到那片小山岗，当时我把自己的手挖得满手血泡，却也根本不舍得让她碰一下锹镐，现在的我看着自己早已看不出任何伤痕的掌心，时间总会冲淡一切的，对吧？根据印象大概就是这颗树了，旁边有一个小坟头，两年多的时间它已经长到一人多高，我握着树干，感觉就像握着白菜的手臂，十年后这棵树应该可以长成参天大树了吧，我把自己想象成十年后的自己，我就站在这里看着这颗树，如果我没和白菜在一起，我会是一种什么样的心情，我会后悔吗？ 绝对会的。 我拎着水果去看班主任和她的小宝宝，和姐夫打完招呼后和她坐着聊天，她问我和白菜处得怎么样了，我说老师我想请教你个问题，你当初为什么回来？真的是为了姐夫吗？老师回答我说一半是为了姐夫，一半是为了照顾父母，问我遇到了什么难题，我说出了我的困惑。 班主任低下头若有所思，说亲情、爱情、友情，对你来说哪个重要？我说应该是同样重要吧，我一样都不愿舍弃，又问她从省会回到县城是一种什么感受？她说刚回来时有些不适应，现在习惯了好很多，我问你后悔过吗？她说只是偶尔有些失落，但从不后悔。 班主任说你是我带的几届学生中最聪明的几个之一，一定会做出对自己最负责的选择，我说我隐约有了答案，但我还不能确定。她问我，如果这几样感情对你来说同样重要，那到底哪份感情最需要你呢？我想了一下笑了出来，说老师谢谢你，这题好像真的没那么难。 我拎着我爸妈精心帮我挑选的礼物来到白菜家楼下，两个月不见，白菜和我在一起后，本来胖了一点好像又消瘦回去了，白菜说一会要是我爸妈不同意，我们就一起好好求求他们吧。我说我明白的，来到她家门口我说你家这个楼的楼梯好高，才爬了两层我就开始喘了，白菜没心思和我开玩笑，低着头不说话，我说在我家门前的时候我可鼓励你了，你不鼓励鼓励我吗？白菜亲了我一下之后抱住了我，我说好啦好啦，女婿第一次上门不是好事吗？干什么这么垂头丧气的？其实我一点都不紧张，你看好了啊。 刚一进门，我看到白菜爸妈后瞬间感受到了未来岳父岳母对未来女婿的血脉压制，两腿一软差点没跪下去，本来计划中的点头示意变成了至少40°的深鞠躬，还好她爸妈还是比较和气的，站起来迎接我说来就来嘛，买这么多东西干什么的客套话。 吃饭时白菜妈妈问了我一些家里的情况，这些早就在我脑中做过预案所以答得还算流畅，白菜爸爸问我抽不抽烟我说不会，白菜爸爸说那咱俩喝点吧，我看着白菜求助，白菜说他不能喝酒，白菜爸爸说少喝点没关系。 抽烟我是假装不行，喝酒我可是真不行，几杯白酒下肚我感觉天旋地转，心想今天败的真是窝囊，什么叫出师未捷身先死啊，说的就是我啊。强挺着吃完饭我就不行了，听到白菜妈妈埋怨白菜爸爸说人家小伙第一次来，你搞什么呢？我以最后的一丝意识察觉到白菜家应该也是妈妈话事，然后我就感觉白菜把我扶到了沙发上躺下，后来我就什么都不知道了。 第二天早上醒来想了半天这是哪啊？白菜照顾好我洗漱吃完早饭，我感觉神志恢复的差不多了，问白菜你爸昨晚给我喝的什么酒啊？劲儿也太大了，正说着白菜爸妈回来了，原来是去逛早市了。坐下来问我怎么样了，我说没事了。聊着聊着逐渐进入了正题，我心说来了来了，成败在此一举，一定要拿出勇气和诚意和他们血战到底。 白菜妈妈问我毕业之后有什么打算？我说我的打算取决于二老的打算，无论如何我绝对不会和白菜分开。白菜妈妈说我和你叔叔都觉得你这小孩真不错，如果你是我们本地的，我们肯定没二话说就同意你俩的事，但我和你叔叔就白菜这一个闺女，总怕她在外面离我们远被人欺负，说实话把她送到你们县城我们都后悔死了，可没办法啊，不考个大专连工作都不好安排，那几年白菜一给我们打电话就哭，我们能不心疼吗？在L市我们有关系，可以给她找个轻松点的工作，去你那里，她能找什么样的工作呢？你还小，体会不到我们做父母的心情啊。 我说阿姨，您有什么话就直说吧，白菜妈说如果你想毕业后留在那里，我们真的不想同意你和白菜的事，你们处了还不到一年，感情还不是特别深，为了将来都能活得好一点，能再好好考虑一下吗？白菜在旁边已经开始掉起了眼泪瓣，我低着头想着这两个月来这件一直压在心头的事，总归要有个了断吧，想着昨晚我问我爸妈，如果我毕业了之后没留在当地，去L市他们支持吗？我妈说这事我们都考虑过，你已经长大了就自己拿主意吧，我们不想你将来怪我们，你只需要记住一点，只要你过得好就行，我们两个没意见。 我长出了一口气，站起来说叔叔阿姨，其实白菜没和你们说实话，我们在一起已经三年了，上大学之后这两年我们熬得很辛苦，但我们一直都在坚持，我知道白菜对我有多么真心实意，我也早已离不开她，所以我一定不会辜负她。叔叔阿姨，我完全能够体谅你们的心情，如果我只有一个女儿，我可能会和你们做出同样的选择。所以今天我在这里向你们表个态，毕业之后我就来L市定居娶白菜，以后会一直好好对她，请你们务必相信我的诚意，你们不用担心我出尔反尔，以后相处多了你们自然会明白我是一个什么样的人。说完之后我跪了下来给他们磕了个头，站起来之后我已热泪盈眶。 耳边传来白菜哭泣的声音，我看着她心想小傻瓜，没想到我来这一出吧，我怎么忍心看你伤心难过呢？白菜爸妈可能也有点感动，一直没有说话，白菜妈妈说好孩子，我们相信你，让我们老两口再想想吧。 白菜搂着我的胳膊一直把我送到车站，我说开心点嘛，干嘛一直愁眉苦脸的？白菜说觉得很对不起你，你真的想好了吗？我说该说的我都说了，剩下就看你的了，白菜一脸诧异的说看我什么？我说你得好好和你爸妈说我们感情多深多深之类的啊，精诚所至金石为开懂不懂？还有，你爸妈是不是对我说的“我是个什么样的人”有什么误解？感觉我说完之后他们还有点感动的样子，白菜说有什么误解？你不就是想说你是个好人吗？我说看来你也不是那么太了解我嘛，我真实的意思是其实我是个胸无大志好吃懒做的人，你们以为我牺牲很大，其实我觉得没什么，日子过得舒服我就满意了，将来来L市混吃混喝，没准你爸妈每天看到我就头疼呢。 接下来的几天我一直在家忐忑不安的等白菜的消息，觉得自己关键时刻还是没发挥好，总觉得想得挺好的一段怎么说起来有点磕磕巴巴的，过几天之后白菜打来了电话，兴高采烈的说爸妈同意我们在一起了，我说这就对了嘛，白菜说以后我一定一定一定全心全意的对你好，不会让你后悔的。 十一的时候十强赛正进行到关键时刻，白菜给我发了一条莫名其妙的短信，说让我去L市，她需要我的火力支援。我盯着这个火力支援陷入了长考，作为一个年轻小伙，火力这方面我肯定是很足的，这个支援又是什么意思呢？难道这是白菜邀请我那个的暗号？这个就是她说的全心全意吧？但又感觉不对，明明有很多更适合的词语，干嘛非得用这个，想来想去还是要做好万全准备，去外面转了一圈看了几家店都没好意思进去，回家之后在老八房间偷到两个小装备，屁颠屁颠的出发了。 到她家楼下之后我问白菜想干什么？白菜说她爸妈开始给她安排工作，明年过完年她就可以实习了，我说这不是好事吗？我能支援什么？白菜低头想了半天，抬起头来说我不想工作，我说你不想工作想干嘛？在家待着吗？白菜说你那里房租贵吗？ 我觉得自己的天灵盖被大雷咔嚓的劈了一下，对啊，我怎么从来没想到这个，不过她爸妈不会同意的吧？我好像突然明白火力支援是什么意思了，说一会还要我跪下磕一个吗？白菜说你见机行事吧，但你一定要好好表个态。 到她家后白菜提出她的想法，我感觉脑门开始冒汗，觉得她爸妈一定觉得是我撺掇她这么说的，她爸妈表态说明年这个工作机会难得，而且你们年纪还太小，不同意你们这么早就在一起生活。我心想人家说的没错啊，如果我是白菜爸我也不会同意的。 白菜说爸妈我想好了，我们在一起三年，什么都发生过了，我再也受不了长时间不能和他在一起的日子，我这辈子就是他了，明年我一定要去，你们拦不住的，不过你们放心，等他毕业我们就回来。 我感觉白菜爸妈看我的眼神都变了，心想要是他爸冲进厨房拿出菜刀把我砍了那我可太冤枉了，虽然没少动手动脚但罪不至死吧，白菜你也太坑人了，事先也不和我商量商量，早知道我把表哥的摩托车头盔带来好了，关键时刻还能保个小命。但白菜把话说到这份上，我也只能硬着头皮接着往下说了，我说叔叔阿姨，刚才白菜也说了，那我也说了吧，我这辈子也就是她了，我...我...心想我TMD还能说点什么啊？白菜妈叹了一口气，说希望你们将来别后悔吧，过年时能安排我们见一见你父母吗？ 大三上学期我开始玩网金，参加了CS城市赛区的比赛，和白菜盼星星盼月亮的等着寒假的到来，我说现在只差最后一步了，就看双方父母能谈的怎么样。我问白菜，你爸妈到底怎么想的？白菜说不知道，反正给我找工作的事没动静了。 我和candy说我女朋友下学期可能要来我这边了，candy说嘿嘿都聊了这么长时间，不出来见个面吗？等女朋友来了之后说不定就没机会了哦，我说不用了，我对130斤以下的没兴趣。 过完年白菜带着父母来到我家县城，两家六口找了个不错的饭店包间吃饭，我和白菜坐在一边静静的等着看谈判结果，双方父母可以称得上是一见如故，我爸妈管白菜爸妈叫大哥大姐，称呼的很是亲热，酒过三巡聊完家常之后四个大人已经熟得跟多年老友似的。我妈举着酒杯说大姐，我第一眼就相中你家姑娘了，这杯酒就是我们家的诚意，然后一仰头干了一整杯白酒。我心说卧槽这酒量为什么没有遗传给我？我要有这两下子，第一次和白菜爸爸喝酒把他干趴下，没准第二天的谈判我还能硬气点。 白菜妈妈说妹子，实不相瞒我也一眼就相中你家儿子了，我闺女脾气倔、性格闷、心眼老实，就怕找不到好小伙儿好人家好好待她，闺女嫁过去挨欺负，你家儿子多好，干干净净文质彬彬的，一看就心眼好，我和她爸就想找个这样的姑爷子。 我妈说那咱今天就初步把这个事定下来，两个孩子的小家从里到外我们全包，肯定全款不给孩子们填负担，白菜妈说那我们家陪嫁一台车（巴拉巴拉一大堆，反正两边都分完了），最后我妈说彩礼要多少，姐你就说吧，不用不好意思开口，白菜妈说你们看着给，反正我们肯定都返给小两口，再带一笔嫁妆，我妈说大哥大姐你们放心，我们家一定全力以赴，白菜妈说我们家也肯定全力以赴，四个家长碰杯说一切都为了孩子。 从开始到结束，不到半小时全谈完了，我和白菜一声没吱，也根本没有人问我们的意见，我们两个只是不停的看他们说话，谁说话我们就看谁，最后合影留念的时候我和白菜还有点懵，这就完事了？进饭店之前我们还是男女朋友，现在的身份好像已经变成了未婚夫妻？下午把白菜爸妈送走，我妈说留白菜在我家住两天，请白菜爸妈放心。 晚上睡觉前我妈依然还是老一套，猛的关门+咔咔反锁，留我和白菜坐在沙发上还没从自己的新身份中缓过神来，我说白菜，咱俩的事刚才是不是就这么定下来了？白菜转过头一脸严肃的盯着我说，好像还真是。我说我总觉得有点奇怪呢，你不觉得吗？白菜说她也觉得，但说不好哪里奇怪。 看着我爸妈房间的门，白菜说男孩女孩是不一样，你看你妈每次都这样，你在我家住的时候，那一晚上我没怎么睡好，感觉我妈半夜出来了好几趟，我问她出来干什么？白菜说出来看你在不在沙发上啊，我说你爸妈也太高估我的演技了吧？我喝多成那样，把苏菲玛索和张柏芝脱光了摆我面前我也无能为力了。白菜笑了出来说换成我呢？我说没看过你脱光了什么样，不过可以试试，白菜说谁跟你试，亲了我一下就回我的房间睡觉了。 我呆坐在沙发上，觉得今天发生的事情有点魔幻，本以为只是双方家长礼节性的见个面，没想到直接把婚事都定下来了，从现在开始我好像再也没有选择其他女生的权利了，虽然说跟白菜结婚一直是我心中所愿，但身份真的被锁定了之后还是感觉自己失去了点什么，到底失去了什么呢？说不出来。 嘿嘿，进去看看我的未婚娇妻吧，得有十分钟没见了，还真有点想她。蹑手蹑脚的开门，一片漆黑的环境对我根本不造成阻碍，对自己的房间我当然了如指掌，站在床头聆听白菜呼吸的声音，无数次分别之后的难过好像离我那么遥远，我爱的她就在我的床上啊，她软乎乎又香喷喷的，好想揉着她的小肚子搂着她睡觉，每次白菜在我家住时，我妈好像真的从没出来过，这样的好机会还是可以珍惜一下的吧？弯下腰闻她身上的香味，我始终搞不懂这种味道到底哪里来的，可每次闻起来都能让我心情愉悦，忽然我感觉我被白菜搂住了脖子，她问我偷偷跑进来干什么？我说想你了来看看你，她把我的头按在了她胸前，小声说我真的脱光了你信不信？一股火在我身上剧烈的燃烧，把正义小人和邪恶小人都烧得毫无踪迹，我不顾一切的掀开被子钻了进去，发现白菜身上还穿着一身睡衣，我一下子清醒了不少说你骗我啊？白菜咯咯笑了出来，说你怎么什么都信？ 我把白菜搂在怀里，说最喜欢抱着你睡觉了，白菜说不怕你妈一会冲进来吗？我嘴上说着不可能，心里还真有点犯嘀咕，按理说我妈绝对不会白痴到这个份上，但这种环境我总感觉不是百分百的安全。而且我已经把老八那两个宝贝偷偷放回去了，一会真发生点什么事我也没个装备啥的。 白菜说你再不出去，我可真要脱衣服了，然后抬起头来吻我，我一边亲她一边睁着眼睛看着门的方向，虽然黑了咕隆的什么都看不见，但就是没法集中精神做好眼前的事，突然感觉怀里的白菜真的开始上手脱衣服了，我连忙说别别别，我还没准备好，掀开被窝就往外跑，猛的一下拉开门，门后什么都没有。白菜说你想什么呢？我说总感觉我妈就躲在门后面偷听，白菜说你这就叫做贼心虚吧？我愣在门口想回到被窝里，白菜说去去去你都没准备好还进来干什么？ 寒假结束前一周我回到学校租好了附近的房子，然后去L市接白菜，在火车站我和白菜与她爸妈告别，白菜抹着眼泪说爸妈你们别太想我，一年后我就回来了，他放假时我们也会回来看你们的。白菜妈妈双手捧着白菜的脸，说到那好好的啊，别什么事都让人家让着你，想爸妈了就多打几个电话。我在旁边也有点不是滋味，多好的丈母娘啊，以后回她们身边一定要好好孝顺。我知道白菜妈妈也会叮嘱我，就老老实实的在旁边排队，没想到白菜妈妈到我面前同样的用双手捧住我的脸，认真的说帮叔叔阿姨照顾好白菜，等你们回来给你们做好吃的。我点了点头，觉得有点害羞，不敢直视白菜妈妈的眼睛，这种信任和亲密的举动让我感觉那种血脉压制好像完全消散不见了，取而代之的是一股浓浓的亲情，细想一下可不是吗？白菜的亲人不就是我的亲人吗？ 一路上白菜情绪有些低落，我能做的只有一直拉着她的手安慰她。第二天白菜的心情好多了，我带她去超市买生活用品，女生要用的乱七八糟的小东西还真是多，单是晾衣架就买了一大堆，我又选了点适合俩人闲着没事娱乐的扑克和五子棋，排队结账时我们已经装满了整整一购物车。 东张西望时我发现旁边有一些包装精致的小盒子，突然很想撩一撩白菜，就用胳膊肘撞了几下她的胳膊，白菜转头看我时我用下巴指了指那些小盒子，她看清之后害羞得低头笑了起来，我以一半请示要不要买，一半恶作剧逗她的心态又撞了撞她，她的脸变得更红，收起笑容后用手捂住嘴在我耳边说：你自己买吧，我不认识你，然后推着购物车去旁边的柜台排队了。 我用眼睛斜视观察着这些小盒子，分析着功能和尺寸，结账时我装成身经百战的淡定老手，其实心里慌的要死感觉全超市的人都在围观我，更不敢直视收银员的眼神，付完钱后我以迅雷不及掩耳盗铃之势收了起来。帮白菜结账后我左手提着几个大袋子，右手拉着白菜的手放进上衣右边口袋，白菜摸到小盒子之后羞的满脸通红，我们两个谁也没有说话，迈着比平时小得多也慢得多的脚步，不约而同的低头盯着步调一致的四只鞋子。 回到家继续整理我们的房间，白菜把衣服堆满了床，一件一件的用晾衣架挂起来。这间房子的暖气还是很给力的，白菜上半身只穿着一件薄睡衣，目测里面还有一件吊带，我看着她若隐若现的锁骨，咽了一下口水琢磨怎么能顺理成章的打开我刚买的小盒子。 我说白菜歇一会吧，咱俩玩会儿扑克，她说来什么的？我说来穿衣服的吧，输一把就穿一件衣服或裤子，袜子不算啊。白菜说那最后怎么算输赢呢？我说穿不进去了或者热得投降的就算输，至于惩罚嘛，那就今天输家必须答应赢家的任何要求吧。白菜想了一下说不行，我肯定玩不过你，我说那就这样，你输一把穿一件，我输一把穿两件，白菜伸出三根手指说你输一把穿三件，我说来吧。 我拆开一副新扑克，洗完牌拿出去一小摞，说你先抓吧。白菜盘腿坐好，把两边袖口撸到胳膊肘开始和我决战。我和同学、家人玩什么都从来不作弊，但今天我准备破个例，看着她认真的表情，我心里想着一会儿热不死你。白菜的脑袋是个单核处理器，抓一张就插在手中的牌里然后观察自己牌的好坏，根本没空看我，于是她抓一张我就抓两三张，抓完之后我把明显厚得多的牌叠起来握在手心里，说女士优先，出牌吧。 前两把白菜被我用炸弹一通乱轰，外面又穿了一套睡衣，第三把我想着放点水，不然她会怀疑为什么我的牌总是这么好，于是我也穿上了一套睡衣和一件球衫。又赢了她两把之后她运气爆棚又赢了一把，比分来到了4:6，我感觉确实有点热啊，于是更加丧心病狂的作弊，到后来我们的比分打到了十几比十几，两个人穿得跟玩偶一样胳膊都不好打弯，抓牌时都要配合上半��前倾才够得着。 感觉我最里面的一件已经快被汗水湿透了，白菜的脸上也全是汗珠，顺着脸颊往下滴，我心想罢了罢了，别把她热出病来，就和白菜说要不今天算打平吧？白菜赶紧说好好好，打平打平，我一边站起来奋力脱着衣服一边说也不知道谁想出来的损招，这也太热了，白菜也说不知道是哪个小坏蛋想出来的。 最后我脱得全身只剩一件在地中间来回走着散热，白菜只剩两件站在床上不停拽着自己的吊带透气，我感觉每走一圈都在蓄力，能量蓄满后腾的一下跳上床把她扑倒压在身下，我的妈呀，她脸和脖子上这热气腾腾还香喷喷的小汗珠也太性感了吧？白菜假装紧张的问你想干什么？我说你说呢？白菜笑了出来问这次准备好了吗？我仔细端详着她的脸，最后一次确认了我已完成所有心理准备工作，于是平静的说准备好了，白菜盯着我的眼睛，慢慢收起了笑容，一脸严肃认真的仰头吻了过来。 晚上出去散步时我感受到了一种与以往完全不同的柔情蜜意，之前在我身边的她始终都是独立的个体，我能感觉到她的身体对待我的侵犯或是严阵以待，或是诱敌深入，但今天这些我都感觉不到了，她已经完全融化成了蜂蜜粘在我身上和我合二为一，她的身体对我再没有丝毫的戒备，任君采摘。 她轻轻把玩我的手指，整理耳边的发梢，哪怕只是转头看我，每一个动作都充满了之前并不那么明显的女人味，眼中的柔情更是像大海一样深沉无限。我觉得自己好像出现了精神分裂，一边不太相信梦寐以求的时刻就这么来临了，一边又不停回味那销魂蚀骨的美妙瞬间。小盒子在白菜的坚持下始终没有打开，白菜说她想象中的那个场景应该是完美无缺的，我看着床单感动得痛哭流涕，白菜爬起来坐进我的怀里，一下一下的轻轻吻着我的眼睛、我的嘴、我的脸、我的耳朵、我的脖子、我的胸膛。看到路边的鲜花店我决定趁着刚开学生活费充足，在今天这么美好的日子里一定要来把大的，搂着白菜进去说老板娘，给我来99朵红玫瑰，白菜开心的接过鲜花，白里透红的脸蛋在红玫瑰的映衬下显得愈发的娇嫩欲滴。 之后我们就开始了每天没羞没臊的幸福生活，我觉得生命中之前的那些考了好成绩、大逆转赢球、玩游戏通关等等开心喜悦的时刻，和现在的美妙滋味相比根本不值一提，白菜总说让我注意节制保重身体，我说中学时我那么艰巨卓绝的锻炼身体就是为了今天而准备的。我在电脑里给白菜下了一些简单的游戏，比如连连看、大富翁4、主题医院，我白天有课的时候她可以自己在家玩，不至于那么无聊。 大二我就出来租房子住，有时也掺和做点饭菜，所以厨艺这方面我还是略懂的，除了一些需要特殊手艺和技巧的菜，其实大部分的菜无非也就是扔在锅里弄熟，油盐酱醋放多少，来回做几次也就心里有谱了，所以我做的菜白菜觉得味道还行。有一天我问白菜晚上想吃什么？白菜说她正在做，我直接回家就行。 进门之后我靠在厨房门上看白菜做菜，她穿着一件小围裙，梳了一个丸子头，我认识她这么多年，她不是披肩长发就是简单的马尾，我还是第一次看见这个发型，越看越觉得她耳边和脖子上那些细碎的头发真是性感诱人，心想哪怕她熬的是毒药，一会我也毫不犹豫的喝了。 白菜扭头看了我一眼说你去客厅坐一下，一会就好了。我感到特别的温馨，脱口而出叫了一句老婆，白菜转过头来，笑着问嗯？我说没事。感觉这句老婆叫得好过瘾，就又叫她老婆？白菜又转过头来，还是笑着问嗯？我又说没事。过了一小会儿我忍不住又叫了她一声老婆？白菜仍然乐此不疲的转过头来笑着问嗯？我走过去从后面搂住了她的一尺九，从侧面亲她的额头，说老婆我想你啦，白菜用她的额头蹭着我的脸，说我也想你了，我说好白菜叫声老公听听？她撒着娇说就不叫。我深呼吸闻她头发上的香味，鼻子里突然涌进来一股奇怪的味道，心中产生了一丝不详的预感，她不会真的在熬毒药吧？ 我坐在饭桌前想象着一会白菜端着一盘焦黑色条状物让我吃的画面，心想今天豁出去了，她第一次做菜，怎么也得给点面子。听着厨房方向传来的脚步声，我的大脑对消化系统说各位兄弟，今天要委屈你们了，结果没一会眼睛就对大脑报告说看起来还挺不错的，我看着白菜做的土豆烧芸豆，这个色彩看起来让人很有食欲啊，不愧是我老婆，脸上不由自主的露出了劫后余生的欣慰笑容。 刚摆在我面前没几秒我就发现我还是草率大意了，闻着这个味道，本该是心头一暖的心情变成了心头一呕，白菜在我对面坐下说尝一下嘛，我的笑容渐渐凝固，表情凝重的伸出筷子去夹了一块肉，脑子里浮现出了大郎该吃药了的画面，夹到嘴里后嚼了半天一咬牙一跺脚咽了下去，说味道不错你也尝尝。白菜得到鼓励，喜滋滋的夹了一根豆角放进了嘴里，刚嚼了两口我就发现她的瞳孔开始放大。 我抬头看了眼挂钟说6点了，我要看体育新闻，然后只拿着一碗米饭逃离饭桌坐在沙发上，刚看了一会白菜也拿着碗过来了，我们俩一边看电视一边干吃米饭，我问你怎么也过来了？白菜面无表情的看着电视，突然笑出来说太呛得慌了，我把嘴里的米饭喷了一地，说我感觉再待一会我都要吐了，闭上眼睛闻还以为你做的是花椒炒大料呢，你放那么多那个干什么啊？那晚温存时她可能有点亏欠心理，在我要出被窝不玩了的威胁下开口叫了老公。之后几天白菜的厨艺尝试基本都以失败告终，实在没脸还叫“快乐的小煮妇”，把网名改成了XX（我的小名）的老婆，我说以后做饭洗碗还是我来吧，你负责洗洗衣服就好。 五一时我们回家分别看了我爸妈和她爸妈，之后我们一起看了世界杯，暑假时先陪白菜回她家住了几天，然后我自己回老家县城。又过了几天白菜来看我爸妈，在家吃了午饭后我妈又拉着我们逛街买新衣服，晚饭后陪爸妈聊了会天，我看时间差不多了，就和爸妈说我们约XXX他们去网吧玩通宵，今晚不回来住了。我妈说网吧有什么可去的？好好在家休息得了，我还特意新买的床单被罩。我说明天再说吧，约好了不去多不好，然后给白菜了个“走”的眼色。 拉着有点懵的白菜走到大街上，她问我真和XXX约好了啊？我说哎呀，骗我爸妈的，这你也信。她说那咱俩干啥去？我说带你去个好地方。来到另一条街道我问眼熟不？她摇了摇头说好像没来过。我说也是，高中时我要不带你出来玩，你连放假都不怎么出校门，不过这片儿我可熟了。她问以前在这住过吗？我说不是，那时候整个县城只有三四家游戏厅，前面拐角就有一家，初中时我和那个谁（以下省略几百字）。 白菜说你上高中之前除了打游戏就没有点别的事可做？我说初中生小屁孩除了玩还能干啥？我们学校操场一圈只有200米连个足球门都没有。她笑嘻嘻的问就没处个小女朋友啥的？我说没啥机会啊，咱俩本来就比同学小，我长个也晚，初一初二时也就到女生肩膀，谁跟我这小屁孩啊？她说初三呢？我说初三还真有点机会，边用手比划边说：我初三时的同桌哈，眼睛特别大，得有这么大，留个小荷叶头，然后皮肤还好，跟你差不多白白净净的，而且她性格也好特别外向，我俩整天在一起就是玩，用那个泡泡胶吹了一堆泡泡，摆的我俩一桌膛都是，还挨个给起了名字，这个是我，那个是她，最大最圆的那个是体育老师什么的。白菜淡淡的问然后呢？我说然后就有点那个怎么说呢？就好像有种比其他同学更好一点的那种好感吧，放假几天不见还有点想得慌。白菜又问再后来呢？我说再后来她生病了，中考都没参加，留级之后第二年好像考到四高了。白菜问现在还有联系吗？我说没了，我高一时还偶尔互相写封信啥的，后来没她准确地址就不怎么联系了，哎，那时候就是没手机，要是有的话说不定我俩现在还（余光感觉到白菜转过头盯着我，隐约感觉到一股杀气）...还能过年时发个祝福短信啥的，白菜凶巴巴的说短信也不许发！我赶紧服软说对对对，不发不发。 转到一个单元门前，说这回有印象了吧？白菜抬头往楼上看了一眼，说嗯，有印象了，我领她上楼说老公今天带你故地重游，她说要是人家已经把房间租出去了怎么办？我说放心吧，昨天我就来交钱定好了，她说你也太奸诈了吧？我说这哪叫奸诈，明明是浪漫好吧？进了我们第一次单独过夜的小屋，黄色小暖灯散发着似曾相识的暧昧味道，我感觉到心跳开始疯狂加速，身体各个器官明显已经做好了战斗准备，看着同样小脸发红的白菜，我心想QTMD再也不用等什么明示暗示了。 我说我一直想问你个事，她懒洋洋的说你问吧，我说如果那晚我就想和你这样，你怎么办？她说哪样啊？我说就刚才那样嘛。她想着想着笑了出来，开始还拿手捂着，后来干脆不捂了，咯咯咯的笑了半天。我问你笑什么笑这么长时间？白菜说我当时还纳闷，你怎么一直不把我转过去？我正想要不然我主动点回头亲你吧，结果你摸着摸着就不动了，我回头一看睡着了，这你都能睡着？你可真行。 我说你好好回答问题，不要说那些非重点。她反问你想过吗？我说想肯定想了啊，不过也就一闪而过吧，她问为什么？我说真那样的话我们的关系突然间变化太大了，我当时一点心理准备都没有，而且感觉你顶多也就能让我摸两把，我要再想干别的你肯定给我一顿踢。 她把头靠到我肩膀上，说在小超市你给家里打电话的时候我就想好了，晚上怎么样我都随你，把第一次给你我能接受。我说你不怕我翻脸不认人吗？她说想过了，即使真是这样我也不后悔。我试着体会白菜当时的心情，感觉有点心酸，还好现在再补偿她也不算晚，回味着她这句话里的浓浓爱意，右手再次嗖的一下摸了过去。 回到大学后白菜吵着说自己在家没意思，带她逛商场时正好遇到招人，就找了个卖化妆品的工作，和老板商量好每周只有周一到周五的白天上班，工资方面差不多就可以。我经常去接她下班，周末时我们一起看电影，一起逛街，一起熬夜刷《GTO》，她陪着我踢球、上自习、去图书馆看书。有天我们逛夜市时遇到一只小母猫看见白菜就一直喵喵叫，去摸它的时候它抱着白菜的手不让走，于是我们就把小母猫买了下来起名叫黑妹，我是爸爸，白菜是妈妈。它不怎么听话，只有心情好的时候才会找我们玩，而且心理有点变态，极度喜欢偷窥我们洗澡上厕所，每次我和白菜切磋武功的时候它都会跑到旁边坐好，饶有兴致的揣起小手看热闹，白菜会和它说快来挠爸爸，爸爸欺负妈妈，而黑妹总是当没听见，看得津津有味的，以至于后来找不到它在哪的时候我就去脱白菜的衣服。 平安夜那天我们准备在家来次烛光晚餐，牛排煎的还算成功，就是买红酒时忘买开瓶器了，我们两个不信邪，用螺丝刀轮流抠了两三个小时，谁累了就吃会牛排，最后我累得满头大汗的终于弄开了，每人象征性的喝了半杯就回房打架了。这一年来甘蓝也经常来找我们玩，我和甘蓝的关系一直很好，就差正式的结拜了，前几次我回学校蹭床住，后来关系熟了索性三个人晚上挤一个被窝了。 白菜爸妈托人帮白菜安排好了工作，过完春节白菜就要上班了，虽然希望就在眼前，但离别的时候还是很不舍，白菜说你不用经常回来看我，来回路上怪累的，我说照顾好我们的黑妹，四个月之后我来找你们。白菜刚走的几天其实还没什么，突然感觉自由了不少，但紧接着来的就是各种不适应，总觉得白菜就在我的身边，自己在家时会在下意识叫她的名字，睡觉时胳膊会不自觉的去搂她却总是搂了个空，以至于我每天都要打几个电话问问她在干嘛，可我晚上回到家时看着空荡荡的房间还是会感觉怅然若失。 我和老四老七到fine所在的公司实习，那阵我经常吃住在工作现场，老四老七说不至于这么拼命，我说我学了3年多，可能只有这一次付诸实践的机会了，就让我认真做完吧，虽然最后的效果远没有我预想的那么完美，但也算顺利完成了任务，另外我把电脑和所有能卖的东西都卖了，因为我需要钱买一件东西。 毕业典礼上我的心情十分平静，毕竟这次分别已经在我心中预想过好多次，白菜拒绝了我的邀请，说不想让我觉得她是来押我回去的，给我最后一次自由选择的机会。candy说你都毕业了，还不跟我见一面吗？我说那你来吧，见面之后我们就跟相识多年的老友一样没有丝毫的紧张，围着操场走了几圈，candy说她有了新的男朋友，我说恭喜你，我也要去娶老婆喽。 宿舍的散伙饭我们醉得一塌糊涂，我最先离开那座城市，几个老哥来火车站送我，老二饿狼Q（饭量极大，一顿的量够我吃三顿，且唱K时飙高音很像饿狼传说里的狼嚎）、老三大臀美少男（身高170-，体重170+，掩饰自卑的方式为极度自恋）、老四招蛇郎君（古典音乐爱好者但天赋为零，每天起床先坐在床上吹同一段笛子，我听了4年都没听出是什么调）、老七牛比Y（篮球超级牛，庆祝动作极其浮夸且擅长吹一些不着边际的牛比）、老八梅毒L（私生活极其混乱，大一时我三观被冲击也有他一份功劳，每次一起洗澡他总是疯狂揉搓某部位说痒痒，我们都躲他老远）。没错这些外号统统都是我起的，至于他们给我起了什么外号，我不说。 我说对不起，哥几个当年一起吹过的牛，我没法跟你们一起实现了，感谢4年来你们对我这个小老弟的照顾，以后我会回来看你们的。老四说你小子结婚时一定要叫我们，否则我们一起过去PK你，大老爷们哭鸡毛，不怕别人看见了笑话。可他们转身离去的时候，我还是看到几个人都偷偷抬起胳膊擦了一下眼睛。 火车站前的高楼大厦依然还是那么繁华，4年前我们来到这里的时候曾靠在围栏上，半吹牛比半认真的说将来我要买下这一幢，我要买下那一幢，现在我先离开了，却对这些建筑没有丝毫留恋，把这一片都给我来换白菜我也不会考虑的。 我虽然有座位，但暂时没有静坐的心情，来到车门前看着眼前熟悉的城市在我眼前倒退，下次回来会是什么时候呢？我的好兄弟们，我们从陌生到熟悉又到情同手足，你们应该可以理解我的选择吧？还有candy，虽然我们只在最后当面说过几句话，但感谢你在我最迷茫最失落的时候一直坚持给我安慰和鼓励，以你的条件和能力，将来一定会获得你想要的幸福吧。 火车奔驰在田野上，我打开车窗大口呼吸着清新无比的空气，沉醉在窗外一片生机盎然的景象里，身上的每个毛孔仿佛都在感知着大自然的勃勃生机，不知不觉中我成功的从万般惆怅中解脱出来，情不自禁地回想起初识白菜的情景，往事一幕一幕的重现，时间以惊人的速度溜走，耳中传来报站的声音，前面那个小城就是属于我的天堂。 我第一个冲下车门一路狂奔出站，打车到白菜工作的地方，三步并作两步闯进大厅，想着一会要给她一个大大的惊喜，她一定会笑出声来的吧，应该还会哭出来哦，手里紧紧攥着的东西硌得我生疼，但我根本不在乎。来到白菜的柜台前排队，我只能看到可爱的套袖和正熟练敲击着键盘的右手，这双手是我真实见过的最好看的手，那么的纤细无骨又白嫩柔滑，却曾经被主人用来给我洗球衣、织围脖、擦后背、做饭煮菜，也曾经那么温柔的抚摸过我身体的大部分肌肤。 终于轮到我时我发现自己的心情远没有自己想象中那么欢快，事实上泪水已快夺眶而出，白菜一边低头整理单据一边说需要办理什么业务？我尽力压住哭腔说我要办一张本地手机卡，白菜一惊之下抬头，看清是我后几乎是立刻抽泣了起来，说先生您好请提供身份证。我把手里攥着的身份证放到柜台上，又把钻戒盒压了上去，她一脸难以置信的接过去，打开盒子后捂住了嘴，眼泪就如同决堤的洪水喷涌而下。我问有选号服务吗？她哽咽着说想选什么号码？我说我要尾号01XX（她生日）的，她擦了擦眼泪说先生您选好了吗？我说选好了，她说是要用一辈子的吗？我说对，一辈子。 --------上个答主和白菜的证---------赌咒发誓的话不想再说了--------你们相信就好----------- 我满22岁后第二天我们就去了民政局登记，我们的婚礼在紧锣密鼓的筹办，两家的积蓄以我和白菜心疼得龇牙咧嘴的速度在燃烧，家里的每个大件都是我们一两年的工资，就连白菜妈妈买的卧室窗帘都是我几个月的工资，以至于我们都认为婚礼办完后两家的经济状况绝对都会徘徊在破产边缘。 我和白菜在挑家具时产生了巨大的意见分歧，她只考虑这个单件好看、那个单件好看，我说你应该在考虑整体效果的基础上再考虑单件的，白菜委屈的表示你妈说了挑家具我说了算，我说那你也差不多点啊，怎么一点不讲道理呢？我和白菜气得谁也不搭理谁，一前一后出门各自打车回家，晚上一通电话和好，第二天早上又亲密无间的搂在一起进家具城，没看一会又气哄哄的出来。后来双方父母看我们挑一个月都挑不出来，就6个人一起看，当天搞定。 选婚纱礼服、订酒店、订婚车，直到婚礼彩排，都没有什么波澜，只有照婚纱照外景的时候赶上降温把我们冻得瑟瑟发抖，对我们来说这些是水到渠成的事情，心里只有甜蜜。我来L市后经常和眼镜哥一起去网吧玩，眼镜哥自告奋勇要当我的伴郎，我说婚礼没有伴郎，就白菜那几个闺蜜和小妹我自己轻松全部搞定。 结婚当天我只睡了四五个小时就醒了，我这辈子精神、体力、酒量的巅峰都留在了那一天，心中没有一丝紧张，妥妥的稳如老狗，感觉自己的目光有如闪电一般犀利，如果去参加运动会能轻松打破自己之前所有的记录，有不识相的想灌我，可惜我喝酒就跟喝水一样毫无醉意。白菜的美貌震惊在在场的所有人，以至于那个酒店同时另外两个婚礼的亲戚朋友都挤在门口看看传说中美艳不可方物的这家新娘子到底长什么样。 站在台上时我和白菜没少说悄悄话，问她紧张吗？她说还行。我想到了参加表哥婚礼时许下的梦想，心里盘算着白菜穿婚纱到底比表嫂漂亮了多少倍，喝交杯酒时我一口就干了下去，白菜一边喝一边责怪我喝那么快干什么？煽情环节音乐一响，主持人刚开口我和白菜就把那些假装出来的淡定抛到了九霄云外，痛哭流涕的紧紧拥抱在一起，白菜毫无顾忌的放声大哭，我心疼得不行就拿手去帮她抹眼泪，没想到她握紧我的手转过身去背对宾客把一堆鼻涕擤到了我手里，回过头来又若无其事的和我深情对视，接吻完我小声说白菜你也太不讲究了吧？她说再不擤出来就要流出来了只能委屈你了，我想直接甩地上太不雅观，手边又没东西擦，我还不能下台，于是我手里攥着那堆鼻涕坚持完整个婚礼，用左手完成了倒红酒杯塔和切蛋糕。下午我和白菜躺在婚床上拆红包，忙活了半年就为了今天这半天，顺顺利利的结束之后有种如释重负的感觉，我说从今天开始你就正式跟我混了。 我们度蜜月回来后因为给双方父母的礼物分赃不均干了起来，我气得把精油从楼上扔了下去，白菜哭着收拾东西说要回娘家，我本以为这会是婚后频繁闹摩擦的开始恐怕要有很长一段磨合期，万万没想到这就是我们两个吵架生涯的巅峰之作，婚后到现在吵架或者闹别扭的次数一共不超过10次，最长一次得有七八年我们连脸都没红过...有什么可吵的呢？婚姻就是互相包容，遇到什么事各退一步不就好了，甜甜美美的过小日子不好吗？ 儿子的降临是一次意外，当时我们还没做好当父母的心理准备，每天除了上班就是玩，到处玩、各种玩，双方父母也都觉得我们结婚还没几年，肯定没玩够也一直没催过我们。有年春节我们去看大姑和姑父的时候喝了点酒，回家借着酒劲放纵了一把，一个多月后我们在卫生间看着清晰的两道杠呆若木鸡灵魂出窍的对视了好几分钟。儿子出生那天我和白菜抱着宝宝整夜未睡，虽然看起来丑了点，但他身体里流淌着的是我们两个人共同的血脉啊，我整晚都在不停的亲，亲宝宝，亲白菜，我和白菜眼里的泪水一直没停过。儿子出生后白菜的网名就改成了XX妈妈一直保持到了现在，我们和黑妹给了这个小生命全部的爱。 我和丈人丈母娘相处得特别愉快，老丈人就是个老小孩儿，有各种兴趣爱好，我们结婚前他就打CS，后来我手把手传授过他不少技巧，现在他沉迷于耍大刀。我和白菜去医院照顾做手术的丈母娘，病友们都觉得是儿子和儿媳妇，丈母娘介绍才知道原来是女儿和姑爷，十几年来我们一家三口早已习惯了回白菜娘家一顿连吃带拿的，有时还在家做好直接送到白菜单位去，摊上这样的丈人丈母娘实在是太幸福了。那次分赃不均后我和白菜都吸取了教训，后来每年春节总会发生争执，争的是给对方父母花钱太少而给自己父母花钱太多。我们每次出门旅游双方父母都会主动提供赞助不要都不行，甚至有好几次我们发现花出去的还没收到的双份赞助多... 时间过得真快，我和白菜结婚十几年了，有太多太多仅仅属于我们两个的共同回忆，我们一起在禾木村看日出，一起在鸣沙山看日落，一起在冰雪大世界被冻到怀疑人生，一起在火焰山热得根本不敢出车门，我们在皇帝岛的酒店里追着满院子爬的蜥蜴跑，我们在五花海旁依偎在一起静坐两个小时不说一句话，我们白天爬完长城晚上在南锣鼓巷吃完饭不得不互相搀扶才能走出店门口，我们在丽江小酒吧里假装醉酒旁若无人的拥吻，我们在东方明珠的透明观光台上吓得瑟瑟发抖又忍不住拉手上去尝试，我们在公交车上装作陌生人发生摩擦一堆人来劝架然后赶忙抱在一起和他们解释，我们挽着胳膊在那场10年一遇的大雪中步行两个小时回家，我们带着儿子在国庆到天安门广场热泪盈眶的高唱国歌，我们在被窝里聊到后半夜聊到当年玩的大富翁4然后爬起来躲着儿子钻进书房打开电脑，我披着大被把她搂在怀里一起熬夜刷越狱柯南甄嬛传琅琊榜，我们一起玩手游每晚专门单挑PK好几局，我们每年要看几十个电影变形金刚哈利波特漫威我们一场不落，太多太多了，根本说不完。 当然我们还会偶尔复盘我们这段感情，我说我把那条围脖摆在床上看了几个小时一直在想你；白菜说大一平安夜那天吃完饭就跑回宿舍静坐等你的电话；我说其实我不想带你去游戏厅，但直觉告诉我要做一件让你印象深刻的事，你想到这件事就会想到我；白菜说其实去县招待所那次她带了一件吊带，只不过在包里一直没拿出来，连穿的bra都精挑细选了好几天...我说我一直觉得是我追你，但细细想来好像每次比较大的进展都是你主动的，我甚至觉得有儿子那次你说安全是不是在骗我？白菜趴在我身上捂着嘴嘻嘻嘻的笑了半天说这么多年都过去了，你才想明白啊？傻帽吧你？ -----------------------------------后记---------------------------- 高中毕业多年之后的大聚会，这届的组委会相当靠谱，聚会地点就选在原来的教室，第一天下午开班会，晚上在教室里包饺子。开班会时我们把课桌按照当年元旦晚会的位置布置，摆满了花生瓜子啤酒饮料矿泉水和各种水果，首先由班长上台宣讲规则，他说班会活动我只讲三点，第一是不管抽到什么，要么照做，要么罚两瓶啤酒，什么时候喝完什么时候下去，而抽到问题的，必须有问必答，不愿意回答的也是罚两瓶啤酒。第二是今天任何人都不许撒谎，被拆穿的直接开除班籍。第三是翻旧账干起来了只许斗嘴，不许骂人，更不许动手。祝大家今天吃好、喝好、玩好。 然后就按当年学号排序每人轮流上台抽箱子，1号就是班长，抽到的是请高中时最有好感的异性喝交杯酒，他当年没正经处过女朋友，但传说中的绯闻女友有两三个，这事被我们拿来八卦了好多年，结果他找了绯闻女友之中的某位，我们疯狂起哄并拍照录视频准备要挟班长几顿饭，否则就发给他媳妇看。我学号也比较靠前，上去的时候心想今天的尺度有点大啊，当着白菜的面可千万不能翻车，TMD要是班长的问题让我抽到就好了。 随便拿了个球递给负责宣读内容的团支书，她打开之后念到高中时期最难忘的事是什么？我微微一笑，这不是送分题吗？拿起话筒说我哪件事最难忘，你们应该都知道的啊，还用我说吗？同学们叽叽喳喳了一会说放烟花那次吗？我们要听细节！然后就起哄把另一位当事人也弄到台上。 我说你们想问什么就来问我吧，同学们问什么的都有，团支书说那就问个最关键的，当年是谁追的谁？我心想你们没少问我这问题，我一直没说，今天终于找到机会了啊？我不想替白菜说，要是白菜也不愿意说，我就来两瓶啤酒吧，刚琢磨好就听到白菜开口说我追的他，下面顿时群魔乱舞，这么多年下来陈年八卦基本挖的差不多了，难得有新料让他们这么兴奋，一堆女生问怎么追的怎么追的？白菜说就写了个小纸条呗。然后又被追问小纸条上都写什么了，我提出抗议说这都多少个问题了？女生们说又没问你，一边老实待着。团支书出来打圆场说时间有限啊同学们，这是最后一个问题，白菜答完就完事了。白菜说那行吧，面不改色的大致回忆完纸条内容，说到我踢球时怎么怎么帅时班主任和同学们笑得都快上不来气了，我一边捂着脑袋听，一边觉得白菜现在的性格跟高中时相比真是开朗了很多。 第二天上午的体育课，不少同学昨天晚上喝多了到现在还没爬起来。体育老师说看你们的样子，一个个的肚子比我都大，足球赛踢完估计得被救护车拉走好几个，那就换个趣味排球吧，规则呢大概就是按学号单双分两组，用打口袋的方式用排球砸人，被砸的一方谁被砸到谁出局，接住排球没落地，砸人的一方就出局1个。 我的身材虽然相比他们来说还算匀称，但还是高估了自己，一门心思想接球，不一会就出局了，来到操场边上观察这么多年的变化，还没来得及感叹时白菜也被砸下来了，来到我旁边问我看啥呢？我说现在的小孩儿真幸福啊，你看这足球场的草皮多好，咱那时候还是沙子地呢，高中三年我每年都穿坏一套校服，幸亏管后勤的副校长我家认识，不然后两年我每天都得跟要饭花子似的。白菜说围墙也变栏杆了，我说嗯，哎你还记得原来围墙边有一片小树林吗？那时经常有处对象的晚上去小树林，我总想着带个手电筒去吓唬吓唬他们，怕他们揍我一直没敢。白菜带着点怨念的说，这个我还真不知道，你又没带我去过。 我有点心虚的嘿嘿一笑，开始YY如果高中时带白菜到小树林里亲个嘴打打太极拳啥的，感觉应该很不错。白菜又说那边的单杠双杠也都没了，我说还真是，我还从单杠上掉下来过呢，屁股差点没摔成四瓣，给我疼了好几天，你要不说我都没想起来，你怎么记这么清楚呢？白菜说高一下学期的时候，我经常自己坐在双杠上看你踢球呀。 尽管过去了很多年，但想到那一幕，我竟然还是觉得有点心酸，紧接着那些我在操场上经历过的一幕幕像潮水一样翻涌在脑海里，在我最青春年少的时候曾经把汗水洒遍面前的每一寸土地，早操、间操、体育课、运动会、足球赛、冬季三项，陪白菜压操场、我组织的弹玻璃球大赛、打雪仗时我不小心落单被十几个女生按在雪堆里拽开我的脖领用撮子往里灌雪，当然还有那件在我高中三年里最难忘最疯狂的事情。 我拉过白菜的手，已经感受不到任何一点的心跳和悸动，但我依然能感受到那股和我血肉相连般的温暖，面对此情此景，我只想问一个在很多年前的这里曾经问过的问题：白菜，烟花好看吗？白菜转过头来看着我，面容依旧那么年轻美丽，看起来比其他女同学至少年轻10岁，她把大眼睛笑成了弯月牙，然后压低声音瓮声瓮气的说出了那个和很多年前同样的答案：好看极了。 ----------------------------------------全文完------------------------------------ 写在结束之后 正文部分的真实性我只能保证六七成以上，当小说看也可以。而下面这些我能保证九成以上，毕竟年纪大了记忆力也可能出问题，留点余量，这些都是我在更新过程中不吐不快又不能写在正文中的内容。 最开始只想写一篇高中时的短篇，老实说我并没有投入太多感情，直接平铺直述就好了。有些催更让我写大学部分的，我本计划按流水账的方式直接一路写下去就好了，但第一件印象深刻的事“第一次过夜”就卡住了，不铺垫高中时期的真挚感情和上大学之后那些怀疑、自卑、叛逆从而封闭自己的心理，就解释不清为什么我突然觉得白菜真的很好，愿意把她从名义上的女朋友上升到事实上的女朋友，选择和她一起过夜。 这一段我写得很快，之前我在更新时提到过，如果没有那次同学聚会，或者聚会之后没单独去开房，我们的生活轨迹一定会发生很大的改变，起码我不会在那个只去过几次的城市生活十几年，所以我几乎记得所有的关键细节。另外第一次更新时我还没有把时间线完全捋清，把第二年发生的情人节记到了那一年，已删去情人节快乐的内容。 没想到的是这次更新之后彻底爆炸了，双11那天我出去办事，看着一上午出现的上千条催更我完全懵逼了，我觉得我们的故事就是很普通的一段异地恋，实际上单是高中我们班就有六七人次（有和同班的，有和外班的）坚持完4年异地，我班有4对同学结婚（其中2对是大学同城才开始的），我搞不清楚爆点到底在哪。所以我每次更新的时候都想着下次要全部写完，免得你们再催。我也没少追贴，知道那种只能看一半的闹心感受，我现在还记得异性合租体验里有个女生是梅州小姐姐的帖子我找不到了。 于是我开始列整个故事的提纲，把那些记忆深刻的场景和对话大致按照时间顺序分成了三四十个章节，然后不断的回忆、补充，来回求证时间，实在想不出来的我就得考虑放在哪里才符合逻辑，其实写下来本身并不难，难得是来回安排顺序，要和上下文的进展和逻辑不发生冲突，我经常写着写着又想起一段有意思的情节和对话，调整的难度就更大了。 求证的过程中有个有意思的事，当我写到五一旅游后在火车站前人行天桥上拥吻告别，那是我和白菜唯一一次在大街上拥吻，所以印象很深刻。我一打开回忆就能直接代入到那个场景：我们上了桥，我觉得这里不错，但桥中间有人，我就在中间偏南找个空位置停下来看东面，因为那边视野更好更繁华，白菜站我左边，我们拥吻完后下桥向东北方向的火车站走去。结合印象中当时能看到的高楼大厦和与火车站的位置对应，我在百度地图上锁定了那条人行天桥应该在的位置，就是在XX街和XX路的交叉路口，绝不会错的。然后我点了百度街景，发现空旷旷的啥也没有，我又找了附近有可能的路口，还是没有。卧槽当时我头都大了，如果这么深刻的场景都是错误的，那其他的场景是不是更不准确了？然后我拼命搜索相关的关键词，找了半天终于找到一条当时的新闻：在2003年11月时人行天桥被拆了，就是我第一次锁定的位置...wtmd... 在不断往下写的过程中我觉得自己完全陷进去了，我又回到了“当时的我”的角色，“当时的我”动情时我也跟着动情，以至于整篇写下来我觉得感情越来越深也越来越甜，办卡那段我差不多是一边哭一边写完的。一些对话和动作我印象深刻直接往上搬，这种起码能占一半以上，有的我印象模糊或完全没有印象，就把自己代入场景想象着当时的我会怎么说、怎么做，很庆幸的是我仍然停留在离那个年龄段不远的心理年龄上，所以大致应该可以接近当时的真实反应，但我可以肯定的是“当时真正的我”肯定比“文中的我”更怂，表达心意时废话更多，因为很多事情我当时还不懂，远不如现在对整段感情的发展了解得通透。 在某次更新时也说过，我真不觉得我有什么水平，很多场景写的有些身临其境是因为那些事真的是发生在我身上且印象深刻的，我完全能够回忆起那是一种怎样的心理状态：第一次过夜时困得要死又强撑着不睡的不甘心和摸到后的心满意足、我妈近距离偷看白菜时我的惶恐紧张和看到那8个字留言时的好笑、第一次躺在白菜胸前听她心跳时的温暖和感动、第一次站在她房间里扑面而来的亲切感和说照片露点了时她佯怒的可爱、亲得舌头疼但就是停不下来的瘾头、不由自主想着这是我们最后一次这样的自卑和失落、第一次领白菜回家时的温馨和幸福感、五一旅游分别后灵魂被完全抽离的不舍、第一次见丈母娘被血脉压制的慌张、双方家长其乐融融我和白菜被当工具人的无奈夹杂着开心、打扑克穿衣服时热得要死又非要分个高下的好胜、第一次亲密关系后散步时那种极致的柔情蜜意和她拿着花时的开心，重回旧地时心脏急剧跳动全身血脉喷张的冲动和复盘时她说的把第一次给你我能接受那一段、和大学兄弟分别时和对那座城市告别时的惆怅、办手机卡时终于坚持到终点的欣慰和解脱、婚礼当天我的超神状态、同学聚会最后在操场上百种滋味尽上心头等等，这辈子都忘不掉了。第一次完整的写下一篇这么长的，再写一篇同样篇幅的几乎不可能，因为我谈恋爱时积累的感情素材就这么多。 我也经常回看已经更新完的部分，有时觉得确实有点过甜了，哪有恋爱是这么一帆风顺的？于是我开始在脑中搜索那些虐的和不愉快的地方，绞尽脑汁想了好久也想不到，婚前除了挑家具之外好像没吵过，婚后吵过几次，双方大声吵吵几句话然后开始冷战，最长的冷战一两天，短的一小时就和好了，正经吵架时双方从没提过离婚（偶尔说离婚、不过了这些话的时候双方都知道在开玩笑，基本都是笑着说的假装吵架玩），几乎从没出现过原则性的分歧，全都是鸡毛蒜皮的小事，大部分都是我想任性一把干点出格的事而她不让...我们结婚后我和她父母、她和我父母之间从没出现过任何矛盾，是不是有点假？可这就是事实啊... 所以后来我心安理得的越写越甜了，本来就是一段特别美好的感情和婚姻，我为什么为了要贴近所谓的真实非要加点不存在的狗血剧情呢？老实说我真心想过开始写的特别甜然后拐个大弯虐虐你们，后来看装备了40米大刀的兄弟实在有点多，想想还是算了，既然这么想吃狗粮就管饱的喂你们吧。后来我写到和白菜甘蓝三人一被窝的时候又突发奇想，要是我突然黑化和甘蓝搞在了一起，然后白菜伤心欲绝的剧情岂不是更恶趣味？哈哈哈，想到那一出时我都笑死了。 本来只想写到办手机卡就结束了，因为我觉得每个人的婚礼不都差不多吗？有什么可写的，老实说我的婚礼没什么让我特别深的画面，我就觉得我那天外表镇定内心亢奋特别能喝，还有黏糊糊的粘在手指和掌心上的感觉，我一点都不觉得恶心，但这不敢碰那不敢摸的还是挺别扭。 另外白菜仍然很好看，现在的她素颜看起来顶多也就30岁，实际上她在35岁之前几乎从不化妆，偶尔化了我也分不出来和素颜有什么区别，那种皮肤白皙和唇红齿白真的就是天生的。答主的颜值相比之下就有点惨了，虽然看着也能比同龄人年轻几岁，但现在的感受就是我俩一起出门时别人都感觉我肯定特别有钱。 下面的内容是作为叔叔也好，哥哥也好，答主对年轻小朋友们说的一些心里话。 ①关于年龄 我在年轻时也想象过自己在三四十岁时应该什么样，后来事实证明我想多了。每个男人心中都有一个小男孩这句话大致是没错的，很多人的内心都停留在某个比实际年龄更年轻的年纪上，只不过是为了生存而慢慢学会如何适应这个社会的规则，每天在外面伪装成大人的样子工作和生活。遇到事时我心里其实还是那么想的，只是我的年龄告诉我不能那么做了。 真正的伴侣和朋友就是你能在ta们面前毫不掩饰的做最真实的自己。我在白菜面前基本就是想一出是一出，她很少会说我幼稚，因为她知道我从来都没变，我们的心理年龄实际上都停在了25-30岁之间，有时也会在被窝里聊天，说总觉得自己还在上学，还有父母护着，可一晃我们也上有老下有小的，在单位下面也都有一堆小孩儿，我们再不想担事也不能躲，早上出门前的告别更像是在互相鼓劲对方今天也要好好伪装。 像答主这样的人身边大把，你们到了我们这个年纪自然会明白，所以不用理解不了为什么40岁的答主能写出这种文字。 ②家庭氛围 想讲讲我妈，真实的她就是文里的妈妈，一点不差，所有我妈的话几乎都是原话未动。偷看那次，她从白菜旁边经过时因为眼睛斜视太多导致嘴角也跟着咧的表情、我回家后她认真又好奇的问我亲嘴了吗的表情，至今想起来还想笑。在我心中她有很多缺点，但我年纪越大就越发现她的伟大之处，她要强、坚韧不拔，为了赚钱她错过了一些陪伴我成长的时间，她对自己抠门但对我超级大方就是她爱我的表达方式。我爸和我妈的婚姻关系远没有我和白菜融洽，但在我小时候，他们都选择了对我付出了全部的爱与包容，所以家庭氛围真的会影响一个孩子的性格，我有很多改不掉的缺点，但性格真的是让自己都非常满意的。 我和白菜结婚时我妈几乎掏光了所有家底，她真的特别喜欢白菜，那句“丫头”一直叫到了现在，婆媳关系绝对的融洽。但我妈一直认为婆媳走得太近早晚会出问题，所以她会刻意的保持距离，很少主动来看我们，当妈的能不想念唯一的儿子吗？可母爱并不是自私的霸占，我妈常说的话就是只要我儿子开心，怎么都行。 ③关于我的爱情观 我们那个时代，信息相比现在匮乏得多，我第一次认识到男女之间的感情应该是黄日华翁美玲版本的射雕电视剧，我觉得他们在一起很美好，所以我读的第一本金庸小说就是射雕，当时我只有十二三岁，看到牛家村疗伤那段时我反复品味，“靖哥哥你想亲我吗”这些话平平无奇，但就是感觉很美妙。之后看了全套金庸，喜欢的几部我会反复阅读，其中最喜欢的一段感情是张无忌和赵敏，从最开始绿柳山庄地牢的暗生情愫，到武当山的吃醋，大都的初吻，少室山下假扮小情侣的动手动脚，直到最后的真情流露，我觉得完全是水到渠成的一套流程，亲密程度就应该跟随好感程度升级而升级（划重点！！！！！！），金庸小说的男主角除了韦小宝这个小混混外都绝不会为了满足欲望而和没感情的人发生亲密关系，这就是我的爱情观来源。一些问我第一次过夜怎么睡得着的，郭靖黄蓉、张无忌赵敏、杨过小龙女等等都曾同住一室，他们能睡着，我为什么睡不着？难道张无忌第一次在绿柳山庄地牢里就应该把赵敏搞定才算正常？ 我不是说感情一定要经过很长时间才能升温，张翠山和殷素素那段我也很喜欢，谢霆锋和林嘉欣有部电影叫《恋爱行星》，还有《泰坦尼克号》，内核都是两人短时间内经历生离死别，我完全能理解哪些感情，但现实社会很少存在这种极端情况了，大部分人快速结合的感情基础是欲望和激情，甚至根本谈不到感情，这种我真的接受不了。 每个时代都有每个时代的生活方式，我不能说谁好谁坏，但在做出决定的时候，请至少想清楚自己到底想要一段什么样的感情，不能一边消费着快餐爱情来满足自己的精神和生理需求，一边又抱怨怎么遇不到一生一世的真挚爱情。在婚姻生活中再浓烈的激情也早晚会归于平淡，维系两人感情的只有一起经历过的那些记忆深刻的回忆，这些独属于两人的画面场景是别人无法替代的。年轻的时候不认真对待和维护感情，年纪大了匆匆找人结婚生子，哪有什么深厚的感情基础？当激情褪去遇到新的刺激时，人品不好对婚姻责任感低的自然会选择劈腿出轨。我和白菜永远不用担心出现这样的风险，因为我们的感情基础太深厚太牢固了。 人的一生会面对很多诱惑，几十年后的生活状态，就在于当下的一个又一个选择，我和白菜选择了坚持和抗拒所有诱惑，才有了现在我们在超市看到姚记扑克时会心一笑的温情，几十年后的你们回想起年轻的时候，还会记得那天约的妹子长什么样、朋友圈晒的包包有多少人点赞吗？ 曾今我以为我和白菜是命中注定的缘分，年纪大了之后我觉得可能不是这样，我只不过是在恰当的时间遇到了白菜而已，现在的我觉得如果我一开始的对象不是白菜，而是candy、甘蓝、或者初中那个小女孩，都有可能走得很远很幸福，相识的缘分是老天给的，自己能否把握才是关键，如果我是白菜，我觉得我根本坚持不了那么久。 ④关于婚姻 老实说当年的我们根本不懂，只是觉得跟对方感觉好就足够了，在见家长之前我们从没问过对方父母什么工作之类的，实际上是见家长时双方父母都感觉到了对方肯定是正经过日子的好人家，不然培养不出来这样的孩子。双方父母第一次见面时说的最多的词就是般配，当时的我还以为说的是长相，有点沾沾自喜原来自己长得还凑合，直到结婚多年我结合自身和朋友同事的感情问题才明白当年他们说的般配是什么意思。 第一是三观接近 我和白菜实际上在高中阶段就不知不觉间完成了对于对方三观的考察，我考虑接不接受白菜时更多的是在考虑接受后能不能做好，而不是她是不是个好女孩，实际上我和白菜的三观相当的一致。三观对于夫妻来说要么都正，要么都歪，最怕一正一歪，因为这样经常会出现原则性的分歧，一个视财如命，一个自己苦点也不能昧了良心；一个觉得孝敬父母是天经地义，一个觉得父母不给钱就是废物，这种两口子能过得下去吗？ 第二是门当户对 这个太重要了，每个人的各项条件都有对应的分数，双方总分接近才是最好的局面，否则特别容易出现家庭地位不对等的情况，时间长了就会积累各种怨气和矛盾，而且家庭环境差不多，两边对于物质、消费各方面的需求也比较接近。我们这里镇以上的孩子都是独生子女，整体房价也不贵，所以很少有那些彩礼闹纠纷、姐姐是扶地魔的乱七八糟事。即使这样，白菜和丈母娘都坚决表示绝对不找家里条件特别好的，否则以白菜的性格到人家里肯定挨欺负，有的妹子觉得自己年轻貌美确实是加分项，就一定要找条件好的，可年纪大了不好看了之后，还剩下什么资本能留住对方的心呢？ 第三是性格合适 至少有一方是性格外向愿意主动厚着脸皮求和的，答主的性格几乎完美的承担了这项任务，而白菜这么多年来始终未减对于接吻的热衷，所以难得闹点小脾气时只要我厚着脸皮找个没人的地方吻上去就好的差不多了。如果两边都是特别骄傲放不下自尊的，或者都是被动型的，真要发生矛盾时就不太容易解开，日积月累之下，积怨就会越来越深以致无法挽回，前任3都看过吧？ 好像真没啥写的了，就结束吧，能看到这里的都是真正的勇士，我自己都觉得墨迹的不行了。 再见。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/分享腾讯京东字节等大厂前端面试风格，你喜欢的风格这都有！ - 哔哩哔哩.html":{"url":"随笔/idea/分享腾讯京东字节等大厂前端面试风格，你喜欢的风格这都有！ - 哔哩哔哩.html","title":"分享腾讯京东字节等大厂前端面试风格，你喜欢的风格这都有！   哔哩哔哩","keywords":"","body":"自述 我是17年毕业的，大三升大四的暑假期间开始学习前端；在这之前一直在小公司打滚；而且至今已经换了四家公司了（算上接下来入职的公司），可谓跳槽非常频繁（其实是小公司容易倒闭）。如果说别人的经历的是如何的加分，那我得经历大概是负无穷。 【面试PDF文末拿！】 在这样的背景下，我从2019年末到2020年三月底为止；基本面完了深圳大多大公司和一些小公司，面试情况如下： 腾讯 - offer 京东凹凸实验室 - 谈薪环节 字节跳动 - 谈薪环节 富途证券 - offer Coding - 谈薪谈崩 顺丰 - 笔试 + 一面（薪酬面试官直言给不到，就没继续下去） 还有一些中途挂了的公司（蚂蚁、阿里国际化、大疆、微众） 这个朋友面了这么多家，小编想通过大厂面试风格、学历两方面来说下面试情况和感悟，面试风格可以了解到大厂偏向问哪方面； 而学历，无论你工作了几年，hr或面试官看简历第一眼想看的就是学历，这是一个很直观地给简历打分的点，好的学历不一定能让你通过面试，但却可以让你的简历通过初筛，很多人可能就因为学历这一关，导致连面试流程都进不去，可能空有一身本事却无法施展 每个厂之间的面试风格都不一样，甚至每个部门之间的风格都不一样；面不同的公司进行有针对性的准备可以提高成功几率。 把这两个放在一起说是因为这两家都喜欢写算法题。 富途证券这边一共三轮技术面试，基本上每轮都两道以上的编程题或者概率题，全程基本不会问项目，只有第一轮面试会过一遍前端基础问题，后续基本写题就完事了；反馈非常快，大概面试完第二天就能知道面试结果。 头条这边面得是飞书，每轮面试官除了固定的编程题外，像是有明确的问题方向；第一轮偏重前端基础，第二轮偏重项目设计，第三轮主要是针对某一方向深入挖掘和有点压力面得感觉。 另外头条比较好的地方是每轮面试记录比较详细，基本不会出现两轮面试之间问重复问题的情况；头条的反馈也是非常快的，基本上也是面完第二天就有反馈了。 这两家基本上要对自己的算法有一定信心才去尝试，因为算法题占面试的比重极大。 京东也是三轮技术面试，京东是面过的唯一一家没有编程题的大厂。 三轮技术面试基本偏宏观，比较少落到具体某个点的细节；也是唯一一家问了webpack的（我简历中并未提及webpack）；京东面的是凹凸实验室，场景比较核心（负责618和京东PC首页），内部平台使用nodejs；成员基本上全栈开发。 着重nodejs的工程化方案、部署运维（内存管理、监控方案）；webpack内部原理和针对小程序的应用；面试官对小程序、多端方案、前端微服务这些比较感兴趣。 另外据反馈，商家平台经常挂（nodejs），所以有这方面经验的同学去面基本很稳；基础题极少。 腾讯面试轮次很多和流程较慢，如果像我这样下定决心要进腾讯的，要做好长期作战准备；个人面试腾讯经历了五轮技术面，一轮GM，一轮HR一共七轮；前后一个多月的时间。 腾讯因为技术面比较多，所以总体问的会比较面面俱到，编程题、前端基础、项目、设计都会有所涉及；个人经历大概是组员负责面基础、leader会根据项目进行展开提问、总监（非前端）聊技术视野、面试委员会会比较难类似头条三面、GM聊人生；leader后面的面试基本都会问职业规范和跳槽原因；这些面试之中会穿插编程题。 总得来说，腾讯面试难度并不高，但是容错率比较低，一些问题没回答到点上就会挂；因为本身轮次也非常多，所以造成了面腾讯非常考验心态，两次面试之间的间隔非常随机，有可能隔一天，有可能隔一周；所以面试腾讯心态是最重要的。 这两个都挂了，而且说实话并不知道为啥挂了；二面之前会有道编程题并不难，但不能debug，到时间会自动提交；而且不知道执行结果。 总体的面试风格比较务实，一面基础，二面会根据项目展开进行提问； 个人建议的话，面阿里还是选择杭州的岗位比较靠谱。 如果你的学历不够让你立刻进大厂，但可以先进一些二三线厂或者小型的独角兽啊，那这可选择的范围就很多了，在这个层次的公司老老实实待个两年，期间别忘了修炼好基本功，别荒废了 两年后你的标签就是一个学历不是太好，但工作经历还不错，并且比较沉得住气的一个候选人，一般情况下，大厂给你个面试机会肯定还是没问题的，进入面试流程后，那就是你真正凭本事的时候了 这里有三点需要注意：1、作为跳板的公司不能太小了最起码是二三线或者独角兽，公司太小了也不可能给你太好的项目经历，另外，面试官和hr大概率得听说过你这个公司 2、不要频繁跳槽如果你是从腾讯跳到阿里再跳到微软谷歌，哪怕你半年一跳都没有任何问题，但如果你是从一个不知名小厂跳到另外一个不知名小厂，这种一年一跳hr都嫌你跳得太频繁了，觉得你不稳定，半年一跳就没法看了，如果你在小厂，然后将来想去大厂，那么就要稳住，别把简历搞花了 3、不要闷头搬砖无论在哪工作，肯定都是以写业务代码居多，也就是搬砖了，但既然你打定了主意将来要去大厂，那么就绝对不能真的局限于搬砖，要把砖搬出花来 比如发现项目中有个结构不太合理，但凑合着用问题也不是太大，那么你就得想我不能凑合，我得把它整舒服了才行，然后说干就干直到真的把它搞定，比如你觉得工作流程中有些步骤是重复工作，那你可以考虑下是不是可以造个轮子解决这个问题 我经历的面试，很多情况下就是让你给出解决方案，考得就是技术的实际运用能力，几乎每一轮面试我都会碰到这种题目，这就要求你在平时工作中要有意识的积累，光搬砖你是说不出来完整的解决方案的，当然，一些常见的基础知识比如原型链、闭包、diff算法等也都是会问的，所以你不能因为平时搬砖很少用到这些就不管了，有些知识点你可能知道是怎么回事，但就是说不明白，那也是不行的，一定要真的弄明白了 总而言之，就是要有自己的思考，不能光顾着搬砖，因为搬砖谁都会，大家都一样，都是搬砖的，凭什么你能去大厂我不能去？所以你就得比他们强才行，没条件创造条件也要上 实现Promise 实现xss-filter 实现正则获取url params 合并n个有序链表 渲染一个超长的list，实现dom节点的复用 random7实现random10 实现正则切分千分位（10000 => 10,000） 实现正则切分银行卡卡号（像实体卡一样四位一个空格） 实现jsonp 判断一个ipv4地址是否存在已有的1000万条ipv4地址中（bitmap） 实现bind，实现new 一次可以走一步或者两步，n个阶梯的楼梯有多少种走法 实现扫雷（二维数组，随机分布地雷坐标） 计算累进税率 求一个数组中比左边和右边的元素都大的元素（On） 实现双向绑定 实现InputNumber https原理（握手过程） http1和http2有什么区别，http2优势 http常见返回码及其含义 http缓存控制，协商缓存相关的几个头部的之间的优先级关系 什么是cors？为什么要用cors？ xss是什么？如何防范？具体例子，jsonp如何防止xss？ cookie有什么用？存在什么问题？如何解决？crsf如何防范？ dns寻址过程？简述cdn原理 谈下vue和react的差异 谈下对react hook的理解 谈下对typescript的理解 谈下对前端微服务的理解，有什么好处，有什么坏处 谈下对serverless架构的理解 谈下react fiber的理解 浏览器输入url后流程，尽可能详细 前端适配方案 谈下mobx和redux的差异和选择 如果让你从零主导一个项目，描述下整体思路，前端后端，开发到部署 如果让你搭建一套前端监控方案，具体思路 如何定位内存泄露 列举的都是通用面试题，小编把面试过的题目整理成一个文档，内并附有答案，需要完整版的大厂面试题的小伙伴，文末拿！ 作为技术人，最重要的就是自己的技术能力，很多人在刚毕业的时候一腔热血，每天打鸡血一般通宵工作也不嫌累，但是后来被社会毒打的次数多了，很容易就疲倦了，可能有的人喊着喊着就放弃了，开始安于现状，这是很危险的事情，技术这条路不进则退，只有持续学习才能在技术这条路上越走越远 而另外一方面，客观的困难确实又是存在的，比如工作量太大没时间，前端技术发展太快学不完等，这就需要你找到一条可持续发展的道路，比如每周仔细研读一篇高质量技术文章，或者定期地进行总结，不要给自己太大的压力，但又必须要保持学习和进步 无论你选择的方法是什么，最终最重要的还是要落到实处，收藏了一大堆优秀文章的链接放在收藏夹吃灰是没用的 注：前端面试题目整理PDF完整版（包括整理了些HTML、CSS、JS、Vue、React、微信小程序、项目类问题等）下图拿！ 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-04-17 22:47:56 "},"随笔/idea/想法.html":{"url":"随笔/idea/想法.html","title":"想法","keywords":"","body":"想法 激素可以控制情绪，思想也可以控制情绪，通过控制思想是否可以影响情绪进而控制人 人是由多巴胺控制还是由自己的思维控制，\"我\"是谁，谁又是\"我\" 如果两个人互相交换了记忆，那他们是交换了身体还是交换了灵魂 生命是否是被高维度生命设计出来的，如果生命是大自然进化而来的，那未免太过精妙了，各种细胞构成身体，各种激素控制情绪，就像一部精密的机器，哪怕有一点误差都不会有现在的人类，生命的存在就像是一个巧合，如果生命是进化而来的，那宇宙间必然会有其他生命，也许是硅基生命，也许是其他物质构成的，个人认为只要有意识的都能称之为生命（如果人类创造出ai也许能称为智能生命），也许已经存在只是人类无法观测到，比如四维生命，不过如果这样想就太复杂了，我们只能观测到自己所在的维度 基因编辑带来的阶级固化 多写评论锻炼写作能力，文笔，多思考 写博客 漫长的进化过程中，就只有人类成为了智慧生物吗，如果地球环境适宜生物生存，为什么没有其他智慧生物诞生，难道只有人类产生了这么高的智慧，如果有其他智慧生物，他们又到哪里去了 北落师门 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/拉件关系的36个问题.html":{"url":"随笔/idea/拉件关系的36个问题.html","title":"拉件关系的36个问题","keywords":"","body":"第一组问题 假如可以选择世界上任何人，你希望邀请谁共进晚餐？ 你希望成名吗？在哪一方面？ 拨打电话前，你会先练习要说的话吗？为什么？ 对你来说，怎样才算是“完美”的一天？ 上一次唱歌给自己听是什么时候？唱歌给别人听又是什么时候呢？ 假如你能够活到90岁，并且你可以选择让你的心智或身体在后60年一直停留在30岁，你会选择哪一个？ 关于未来你可能怎么死，你有自己的秘密预感吗？ 列举3个你和对方共同拥有的特质。 你的人生中最感恩的事情是什么？ 假如可以改变你成长过程中的任何事，你希望有哪些改变？ 用4分钟的时间，尽可能详细地向对方讲述你的人生故事。 假如明天早上起床后能获得任何一种能力或特质，你希望是什么？ 第二组问题 假如有颗水晶球能告诉你关于自己、人生或未来的一切真相，你想知道什么？ 有什么事想做很久了？还没去做的原因是？ 你人生最大的成就是什么？ 友情中你最重视哪一个部份？ 你最珍贵的回忆是什么？ 你最糟糕的回忆是什么？ 如果你知道自己将在一年内突然死去，你会改变自己目前的生活方式吗？为什么？ 友情对你而言意味着什么？ 爱和感情在你生命里扮演什么样的角色？ 轮流分享你认为对方拥有的比较好的性格特点。各自提5点。 你的家庭关系亲密温暖吗？你是否觉得自己的童年比大部分人快乐？ 你与母亲的关系如何？ 第三组问题 说出3个含有“我们”并且符合实际情况的句子，比如“我们现在都在这个房间里”。 完成这个句子：“我希望可以跟某个人分享——”。 如果你要成为对方的密友，有什么事是他或她需要知道的？ 告诉对方你喜欢他或她的什么地方（回答此题必须非常诚实，要说出你可能不会对刚认识的人说的事）。 和对方分享你人生中尴尬的时刻。 上次在别人面前哭是什么时候？自己哭又是什么时候？ 告诉对方，你现在喜欢他或她什么地方。 有什么事是绝对不能开玩笑的？ 如果你今天晚上就会死掉，而且无法与任何人联系，你最遗憾还没有告诉别人什么事？为什么还没说呢？ 你的房子起火了，你所有的东西都在里面。在救出所爱的人和宠物后，你还有时间可以安全地抢救出最后一件东西。你会拿什么？为什么？ 在你所有家人当中，谁的死对你的打击会最大？为什么？ 分享你人生中的一个问题，问对方遇到这样的问题会怎么做。同时也请对方告诉你，在他或她看来，你对这个问题的感受是什么。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/收藏链接.html":{"url":"随笔/idea/收藏链接.html","title":"收藏链接","keywords":"","body":" 程序员英语学习指南 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-24 14:43:05 "},"随笔/idea/普鲁斯特问卷.html":{"url":"随笔/idea/普鲁斯特问卷.html","title":"普鲁斯特问卷","keywords":"","body":"01 What is your idea of perfect happiness ? 你认为最完美的幸福是怎样的？ 幸福的样子有很多，涂涂改改写了好多遍，最终发现是自己太追求完美，而这个世界本无完美，所以生活点滴都是幸福。 02 What is your greatest fear ? 你最大的恐惧是什么？ 蟑螂。 03 What is the trait you most deplore in yourself ? 你最痛恨自己的哪些特质？ 自律性差，主要体现在早上起不来。 04 What is the trait you most deplore in others ? 你最痛恨别人的什么特点？ 以自己狭隘的三观去判断世界。 05 Which living person do you most admire ? 还在世的人中你最欣赏的是谁？ 很多，坂本龙一，扎克伯格，艾莫·阿拉慕丁，我所欣赏的特性是有学识才华却依然谦逊好学。 06 What is your greatest extravagance ? 你最大的奢侈品是什么？ 对自己不设限，保持纯真，感知美好。 07 What is your current state of mind ? 你目前的心境怎样？ 心境是平稳的，但有对现状的不满与对未来的期待。 08 What do you consider the most overrated virtue ? 你认为哪种美德是被过高评价的？ 同情分，好人卡。 09 On what occasion do you lie ? 什么情况下你会撒谎？ 为了避免不必要的麻烦。 10 What do you most dislike about your appearance ? 你对自己的外表哪一点不满意？ 好像没什么不满意。 11 Which living person do you most despise ? 还在世的人中你最鄙视谁？ 说不上来某个人，广义上来讲鄙视思想狭隘封建迷信的人。 12 What is the quality you most like in a man ? 你最喜欢男性身上的什么品质？ 谦逊、善良、包容、忠诚。 13 What is the quality you most like in a woman ? 你最喜欢女性身上的什么品质？ 谦逊、独立，有自我意识，内心坚强却依然温柔的。 14 Which words or phrases do you most overuse ? 你最常使用的单词或短语是什么？ 我。 15 What or who is the greatest love of your life ? 你这一生中最伟大的爱是谁/什么？ 家人、挚友以及未来的爱人。 16 When and where were you happiest ? 何时何地让你感觉到最快乐？ 很少会感到不快乐，好天气，吃美食，回家，旅途都会令我感到快乐。 17 Which talent would you most like to have ? 你最想拥有哪种才能？ 语言的才能和乐器的才能。 18 If you could change one thing about yourself, what would it be ? 如果你能够改变自己的一件事，那会是什么？ 去欧洲留学。 19 What do you consider your greatest achievement ? 你认为自己最大的成就是什么？ 找到了自己是谁。 20 If you were to die and come back as a person or a thing, what would it be ? 如果有转世，你希望成为什么样的人或物？ 还是自己，只不过选择另外一种没有尝试过的人生。 21 Where would you most like to live ? 你最想住在哪里？ 有河水流过的地方。城市的话天津、巴黎，养老想去自然景色优美的法国乡村。 22 What is your most treasured possession ? 你最珍贵的财产是什么？ 自学到的知识、读过的书与走过的路。 23 What do you regard as the lowest depth of misery ? 你认为程度最浅的痛苦是什么？ 丧失身外之物。 24 What is your favorite occupation ? 你最喜欢的职业是什么？ 艺术家、摄影师、作家等。 25 What is your most marked characteristic ? 你最显著的特点是什么？ 看起来有点高冷。性格比较固执，不合群。 26 What do you most value in your friends ? 你最看重朋友的什么特点？ 真诚。 27 Who are your favorite writers ? 你最喜欢的作家是谁？ 雨果、毛姆、狄更斯、波德莱尔。 28 Who is your hero of fiction ? 谁是你心目中小说里的英雄？ 《双城记》的卡顿。 29 Which historical figure do you most identify with ? 你最认同哪位历史人物？ 所有为了自由而战的人，还有德国将军隆美尔。 30 Who are your heroes in real life ? 谁是你现实生活中的英雄？ 父母，以及无私为他人/社会奉献的人。 31 What are your favorite names ? 你最喜欢的名字是什么？ 花朵的名字。 32 What is it that you most dislike ? 你最不喜欢什么？ 贫穷、失去自由（多方面的）。 33 What is your greatest regret ? 你最大的遗憾是什么？ 陪伴家人的时间太少。 34 How would you like to die ? 你想以何种方式死去？ 在一个景色优美，安静，有充足阳光洒进来，靠窗边的病床，并在家人孩子的陪伴下安静的死去。 35 What is your motto ? 你的座右铭是什么 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/idea/阿里巴巴又出事！服从性测试？别！他们只想把你变成奴隶！_哔哩哔哩_bilibili.html":{"url":"随笔/idea/阿里巴巴又出事！服从性测试？别！他们只想把你变成奴隶！_哔哩哔哩_bilibili.html","title":"阿里巴巴又出事！服从性测试？别！他们只想把你变成奴隶！ 哔哩哔哩 Bilibili","keywords":"","body":"阿里巴巴又出事！服从性测试？别！他们只想把你变成奴隶！_哔哩哔哩_bilibili 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-03-13 21:57:10 "},"随笔/摘抄/不要温和地走进那良夜，.html":{"url":"随笔/摘抄/不要温和地走进那良夜，.html","title":"不要温和地走进那良夜，","keywords":"","body":"不要温和地走进那良夜， 老年应当在日暮时燃烧咆哮； 怒斥，怒斥光明的消逝。 虽然智慧的人临终时懂得黑暗有理， 因为他们的话没有迸发出闪电，他们 也并不温和地走进那个良夜。 善良的人，当最后一浪过去，高呼他们脆弱的善行 可能曾会多么光辉地在绿色的海湾里舞蹈， 怒斥，怒斥光明的消逝。 狂暴的人抓住并歌唱过翱翔的太阳， 懂得，但为时太晚，他们使太阳在途中悲伤， 也并不温和地走进那个良夜。 严肃的人，接近死亡，用炫目的视觉看出 失明的眼睛可以像流星一样闪耀欢欣， 怒斥，怒斥光明的消逝。 您啊，我的父亲．在那悲哀的高处． 现在用您的热泪诅咒我，祝福我吧．我求您 不要温和地走进那个良夜。 怒斥，怒斥光明的消逝 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/摘抄/仿生人会梦见电子羊吗评论摘抄.html":{"url":"随笔/摘抄/仿生人会梦见电子羊吗评论摘抄.html","title":"仿生人会梦见电子羊吗评论摘抄","keywords":"","body":"我常常想到，怎么来界定我，怎么确定我是我，如同休谟一样只相信自我感觉，还是笛卡尔的我思故我在？亦或者康德融合经验论和唯理论？ 我们无时无刻不在变化，唯一能够确认的就是一切都在变化，如果有一天人类能够制造出生命，有独立的思想。也许现在就能制造出？当然这种制造是除却了生殖的制造。这种时候，人是不是从人变成了神？或者说是不是具有对其他生命进行裁决的权利？当然如今我们也无时无刻不对除了人以外的其他生物有意识或无意识的进行着裁决。 人类残忍，这是不争的事实，这是本性，人类也孤独，所以茫茫宇宙中寻找其他高智能生物，好奇是原因之一，但是我想更多的是孤独。有一天我们用物理方式通过非生殖手段制作出来专门受人奴役的生物的时候，还怎么能够说我们善良，可能正因为我们生而向欲，欲壑难填，所以善良才被称为美德。 宇宙何其浩瀚，人类何其渺小，人类的历史和其他生物相比又何其短暂，更何况作为个体的我。常常因此感到生命无意义。思考能够让空虚的人感觉到充实，这其实和满足生理欲望一样，精神的欲望其实也不过是物理状态的投射。这么想来，仿生人如果拥有了人类的身体如何能够没有人类的感情呢？假如有天科技允许，复制一个一模一样的你，那么如何区别哪个是你？人之所以成为人，是千千万万个过往透过时间综合到一点也就是现在这一点之上的人，当我说现在之时现在已经变成过往。 我们总觉得有权利创造或者说决定自然，吕思勉的书里说，大意是改变环境及为了适应而做出的行为，称之为文明。文明的本质是人类为了适应环境所做出的行为，慢慢的演变成习俗。战争杀戮变成体育竞技，斗兽，激烈的电子竞技，杀戮这种本性是根植于生物的基因里的，面对陌生首先是恐吓，这是本能。文明是包括杀戮的，一切危害自身的，都有权利将其灭绝，甚至同类，这就是真实的文明，因为我们依赖肉体，依赖物质，即使我们能够产生同情，能够感恩，能够善良，那都是有前提的，所有的付出，都是有回报的，可能是物质上的也可能是精神上的，这是毋庸置疑的。 所以如果有谁跟我说，人类会前进而不伤害其他物种，我从来都不相信，道德只有在有利于自己的时候才被遵循。 不过不用忧伤，即使时间也是概念而已，何必忧伤。 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/摘抄/在银河系的第三旋臂边缘一颗蓝色行星上碳基生物正在庆祝他们所在的行星.html":{"url":"随笔/摘抄/在银河系的第三旋臂边缘一颗蓝色行星上碳基生物正在庆祝他们所在的行星.html","title":"在银河系的第三旋臂边缘一颗蓝色行星上碳基生物正在庆祝他们所在的行星","keywords":"","body":"在银河系的第三旋臂边缘一颗蓝色行星上碳基生物正在庆祝他们所在的行星又在该恒星系里完成一次公转，他们也知道整个太阳系也是围绕着银河系公转错过的位置永远也不会再回来了，而银河系也在飞驰甚至空间本身也在膨胀他们走过的路穷尽时光无法回头，而他们的高歌跨过时空而万物的细语超越时间他们曾拥有闪亮的日子，他们的梦与渴望将化为光在每一个凶险的转角处波与粒也在喃喃自语:一切存在的意义在于存在本身 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "},"随笔/摘抄/性格内向的人如何锻炼社交能力？ - 知乎.html":{"url":"随笔/摘抄/性格内向的人如何锻炼社交能力？ - 知乎.html","title":"性格内向的人如何锻炼社交能力？   知乎","keywords":"","body":"这是一篇专门写给内向者的社交指南。 全文5500+字，纯干货，你可以根据自己的需要和兴趣进行选读或跳读，不影响理解。 或者先收藏起来，等闲下来再慢慢看。 这篇文章主要讲了以下内容 : 1.如何确定自己是内向者还是外向者？ ——内向者和外向者的性格特征 2.内向者的困境 ——不懂说“不”、常被误解、不懂经营关系、没有存在感。 3.如何突破这些困境？ ——4p法: 准备（Preparation）、展示（Presence）、推动（Push）、练习（Practice） 4.4p法的实践运用 ——用4p法进行公众演讲 ——内向者如何建立自己的人脉网？ （参考资料: 《内向者的沟通圣经》[美] 珍妮弗·康维勒） 1. 如何确定自己是内向者还是外向者？ 在心理学上，对于内向性格和外向性格还没有明确的界定，但你可以通过下面这些典型性格特征，来判断自己更倾向于哪一边。 通过这些性格特征我们可以知道，内向只是一种偏好，不应该被看成是缺陷。 也许你在不同的情况下，表现出的性格也不一样，所以不确定自己是哪种性格。 这样的话，你可以问自己一个问题: “如果在接下来的人生中必须选择一种性格倾向，我更愿意是哪种？” 2. 内向者的困境 小时候，就因为不爱说话，我经常被亲戚邻居们评价为“有点儿傻”、“笨”、“反应迟钝”。 即使我在小学时名列前茅，门门90分往上，还是会被说成是“死学习”，以后肯定不如那些会说话的孩子有出息。 后来，事实证明他们是错的。 我相信这一定不是我一个人的经历，肯定还有很多和我有同样经历的小伙伴。 这就是我们内向者面临的四大困境之一: （1）常被误解 你不想说话，别人却以为你愚蠢孤僻 在热闹的聚会中，你可能经常会被问:“你怎么了？”、“你咋不说话？”。 你只是不想说话而已，这在你看来很正常。 可在别人眼里，你看起来好像不是很高兴，甚至会被认为是不合群、没礼貌。 因为外向者无法理解，你没有那么需要人陪伴，你就喜欢一个人待着。 你爱倾听，别人却以为你优柔寡断 内向者习惯在听取了所有的信息之后，再给出自己的观点。 可是在会议或讨论中，大家往往更偏好那些能快速接上话的人，所以内向者经过深思熟虑给出的结果，却被认为是反应迟钝、拖延，甚至是优柔寡断。 你只想安静，别人却以为你懦弱 安静的人会被认为气场太弱，没有存在感，尤其是在强势者的身边。 拘谨的性格也容易被当成是“软柿子”，这个时候一定要坚定自己的原则。 （2）四大困境之: 压力大 内向者性格含蓄，不懂说“不”，因此被委派更多任务，超负荷工作； 在公众场合过度紧张，事后想起来又尴尬沮丧，容易导致身体不适； 有时候不得不应付社交，出去“嗨”一下午，得缓一个星期，让人身心俱疲。 在这个以外向者为主导的社会，内向者压力是真的很大。 （3）四大困境之: 不懂经营关系 我是一个典型的内向者，上学的时候，老师经常在课堂上提问，很多问题我都会，而且有非常新奇有趣的回答，但是我不敢举手。 我就幻想着被提问，然后站起来侃侃而谈，震惊四座。 当然这基本没有实现过，因为别人没有读心术，你不表现出你优秀，别人怎么知道你优秀？ 很多内向者都不会表现自己，就等着能有一个伯乐来发现自己的才能。但这个世界就是这么“肤浅”，很多事情你不说，就不会有人了解。 内向者还总是回避和大人物的接触，只想低调做事。 但和上层交流，就像往信任银行中存钱。 今天打个招呼，混个脸熟，信任+10； 在茶水间和领导闲聊几句，信任+50； 明天汇报个工作，表现一下，信任+100； …… 这样等到将来有什么好事儿的时候，领导肯定会首先想到信任值高的人。 人们会聘用他们认识和信赖的人，这是人之常情。 （4）四大困境之: 没有存在感 不敢站出来表现或者不愿成为众人关注的焦点，是内向者的又一个特点。 这个特点又带来种种问题: 不站到舞台中心，就没有机会； 过于低调，想法便无人关注； 错误的沟通，降低存在感和影响力。 以上是内向者面临的四大困境，这些问题对我们的工作生活都产生了巨大的影响，很多人深受其扰，努力想要变成外向者，却因其本性内敛，而变得更加疲惫不堪。 难道内向的人就注定只能被误解、被忽视吗？ 当然不是了！ 这个世界上还有数以千万计的人是内向者，光在美国，就有50%的美国人、40% 的企业高管是内向者。 很多举世闻名的成功人士和领导者，如比尔·盖茨、沃伦·巴菲特、亚伯拉罕·林肯、马丁·路德·金……都是内向者。 内向只是一种偏好，和技能和个人成就都没有直接关系。 所以请你不要灰心，我们只要找到一个方法，去发挥内向者的优势，化困境为机会，就能更好地融入这个以外向、人际交往为主导的社会。 3. 如何突破这种困境？ 要想突破内向者的困境，有一个简单易记的指南: 4P法。 4P 法由四个部分组成： 准备（Preparation） 展示（Presence） 推动（Push） 练习（Practice） 准备: 做计划 计划越充分，应对越自如。 在参加社交活动前，准备一个通盘计划: 例如，明确目的，想出具体要问的问题和要说的话，做笔记，并且跟一个值得信赖的朋友排练一下。 展示: 赢得好感 做好计划之后，接下来你就只需要在实际的社交活动中，用一种能赢得好感的方式，把它“表演”出来。 推动: 张开嘴，迈开腿 走出自己的舒适区，去做你害怕的事情，你会发现也不过如此。 最难的是开始前的纠结，张开嘴，迈开腿，说出第一个字，走出第一步之后，就简单多了，不然你永远不知道自己有什么样的潜能。 一位内向型领导者为推动自己克服不适感提出了最好的理由，他说：“你毕竟想知道自己在这个世界上能做些什么。” 练习: 熟能生巧 创造与人交流的机会，在实践中不断提高自己的社交技能。 练习能够让你不断尝试和试验与人交往的不同方式，还能让你具备根据不同情况调整方法和行为的能力。 说到这里，你可能还不是很懂。 没关系，接下来我们就通过实践来学习4P法的运用。 4.4p法的实践运用 （1）用4p法进行公众演讲 准备 这个准备分两个层面，一个是做好材料准备，一个是做好自我准备。 ① 做好材料准备 明确你的演讲目的，你的听众是谁？你要给他们传达什么信息？你要让他们记住什么？ 讲一个故事，可以调动起听众的积极性，帮助他们理解你的观点，同时也能更好地论证你的观点。 不要照着PPT读，只把重点信息放在PPT上，剩下的通过你的讲解、图片、视频、音频等形式展示出来。 ②做好自我准备 建立一个积极的心态，你要知道，所有的演讲者都会紧张，我们要做的是把紧张的情绪转化为更高层次的热情。 每当我上台演讲前心跳加速、控制不住手抖的时候。我就会把自己想象成一个整装待发的战士。 有一个声音问，你心跳好快，你在害怕？ 我说， 不！ 这是我对即将开始战斗的激动！ 这是我对胜利的渴望！ Fighting！！！ 睡个好觉，保持充沛的精力。 对着镜子多排练几次，能录下来最好。 提前到达演讲现场，熟悉一下环境。 这些准备都能帮助你减轻对公众演讲的恐惧和焦虑。 展示 演讲其实是一场表演，是表演就有表演技巧。 ①与观众建立联系 选择一个观众对视，这样不仅被关注的人会集中注意力，其他人也会好奇，你在跟他说什么呢？（当然不能整场只盯着一个人看，多换几个。） 把关注点从你在说什么转移到听众在听什么，关注听众的接收效果，根据听众的反应调整你的节奏。 ②让你的声音更富有磁性 采用腹式呼吸: 就是我们常说的深呼吸。 呼吸过浅会让你说话带有气音，听起来很虚弱。颈部的紧绷会让声带变得僵硬、死板、反应迟钝，容易损伤。它会停止共振，缺乏弹性……采用腹式呼吸时，你的声音会更加饱满和浑厚，因为你的身体和声带可以自由振动。 在讲到重要论点前停顿一下，能够抓住听众的注意力，让他们做好准备倾听接下来的内容，可以让观众有时间消化内容。 ③用身体语言塑造形象 学习演讲表演，有一个可以快速提高的方法，就是模仿。 选择你想成为什么样的人，然后套上那种人的模型。 不用担心会有人看穿你，没人有心思去深度了解你，你表现出什么样，别人就会觉得你是什么样的人。 推动 加入一个演讲社团，找到和你一样想练习演讲的人，他们能给你反馈，帮助你获得演讲的自信和能力。 给你的演讲准备一个爆点，一个笑话、一张搞笑图片、一张当红明星的剧照，都能瞬间吸引观众的注意力，让气氛活跃起来。这种积极的反馈，也能让你放松下来，开始享受演讲。 练习 抓住一切机会练习演讲，工作总结？项目汇报？读书分享？都可以。 我知道练习很难，而且很不舒服，但这是提高能力的唯一途径。 （2）内向者如何建立自己的人脉网？ 首先我们要明确一个认知，不管内向外向，发展人际交往的技能，都是需要后天练习获得的，都需要付出时间和心力。 还是那句话，内向只是一种性格偏好，它和社交技能的学习，并不排斥。所以内向者通过练习，依然可以获得良好的社交技能，建立自己的人脉网。 准备 为建立关系做准备意味着你应该： ①了解你的目的； ②计划你能提供什么； ③计划你需要得到什么； ④利用社交网络做好准备； ⑤战胜消极自我暗示。 ①了解你的目的 你要清楚: 你要去哪里？认识什么人？达到什么样的目的？ ②计划你能提供什么？ 社交是一个互相交流的过程，因此你首先要了解你能在互动中给别人提供什么。 不一定得是多么专业的资源或知识。 一个新奇的app、一部有趣的电影、一个有创意的点子，这些都可以是你的社交资源。 ③计划你需要得到什么？ 你需要哪些资源、信息或专业知识？ 在脑子中想出一系列的需求，在和别人互动时，准备好随着谈话进展提出相关的问题。 ④利用社交网络做好准备 你可以在qq、微信、微博等社交app和网站上，和对方先聊一阵儿暖暖场，这样做有利于减轻内向者对与人联系的恐惧或犹豫。 ⑤战胜消极自我暗示 用积极的声音去反驳消极的想法。 原著中的这个例子就很好: 我不会打高尔夫。 ——我可以去学。或者有的人跟我一样，不擅长打高尔夫球。或者不试怎么知道行不行。 跟别人闲聊会让我觉得不自在。 ——要是提前准备一些问题，我会感觉更自在。或者我可以提前做些调查，了解我的高尔夫球队友。（例如：他们有孩子吗？如果有，孩子多大了？他们养宠物吗？他们住在哪里？） 没有一起去打高尔夫，我觉得很不安。 ——我不一定非要打球。我可以先去跑步。然后再找他们一起喝一杯，听听有什么最新消息。 可我不喜欢高尔夫。我为什么要因为大家都去就也一起去呢？ ——我可以在那找机会跟马里奥或者凯瑟琳聊一聊。 展示 重要的是沟通，不需要闲聊。 要给别人留下良好的印象，你需要做到： ①倾听； ②进行实质性谈话，而不是闲聊； ③互相告知姓名； ④回答”你是做什么的“这个问题。 ①倾听 内向者注重深度甚于广度，并且擅长倾听，你可以利用倾听这项优势，展开谈话了解到别人真正的兴趣。 这时事先准备的问题会帮助你更好地倾听。 ②进行实质性谈话，而不是闲聊 实质性谈话更能够真正地建立人与人之间的联系。 任何能让对方多谈论自己的话题都可以，比如他们的家乡、兴趣爱好、对某事的看法。 你不喜欢说话，可以让对方多说啊，而且主动提问也不会让人觉得你孤僻、难以交流。 ③互相告知姓名 一定要问清楚对方的名字到底该怎么念，问他喜欢让别人怎么称呼他，他有没有昵称。 同时教别人念自己的名字，也是为别人提供了一个记住你名字的机会。 ④回答”你是做什么的“这个问题 提前准备好对自己工作的介绍，不要等人问起”你是做什么的“时，就懵了。 这里有一个做自我介绍的公式： “我是”（你的职位或职业）+“做”（你在工作中做什么）+“举个例子”。 最后一部分是最重要的一部分，通过讲你的成就或者一个故事来让听众真正体会到你是做什么的。 比如： 我是一名客户主管。我的工作是了解你们公司的需求，并把你们提出的变更要求转达给我们的支持团队。例如，你们的公司生产任务增加了，我就要和车间经理一起合作，及时给团队进行培训。这样他们就不会耽误进度，并且还可能超额完成生产目标。你之前使用过我们的软件产品吗？ 推动 在社交关系中更重要的是谁认识你，而不是你认识谁，所以有时候你必须要站到更显眼的位置。 这里有6个技巧推动你去建立关系： ①角色扮演 假装自己是另一个人，是自己期望中的形象。 前面说过，别人没有心思也没有办法去深度了解你，你表现出什么样，别人就会认为你是什么样。 所以想象自己是另一个人，真的能减轻紧张和焦虑。 ②在杂货店排队或者出门办事时跟周围人聊一聊 如果实在没有话题，也不用尬聊。 但如果你能开始这么做，也许会发现日常生活的精彩程度远超你的想象。 ③登门拜访前先打电话预约 问问对方什么时候方便，是否需要准备带什么东西。 他会感激你对他的注意，说不定还会主动提出来接你，节省交通费用。 ④主动开启餐桌话题 在餐桌上主动开启一个话题，问问他们对这个话题的看法。 接下来你只需要倾听就好，这样就算你没怎么说话，也会让大家觉得你很积极主动。 ⑤与社交高手保持紧密联系 向他们学习与人交流的技巧，通过他们来结交更多人。 ⑥担任在专业、商业或社团性质的组织的志愿者 在那里你会遇到很多与你志趣相投的小伙伴，并且可以展示你的优势和才能。 练习 ①先在安全的环境中练习 尝试主动和身边的人交流，比如主动询问同学、同事，“你的新衬衫在哪里买的？”、“最近有什么好看的电影？” 然后就这个话题谈论下去。 ②在网络上展示自己 对内向者来说，网络上的社交方式，可以让我们更好地发挥擅长用文字交流的优势。 而且在网络上可以扩大社交、表达想法和兴趣，如果你是职场人或专业人士的话，在网络上 撰写相关文章，也能让你在行业和领域中扩大知名度。 在这篇文章中，我先列出了内向者和外向者的性格特征，帮助你确认自己的性格倾向； 然后我总结了内向者身处的困境，并提出了突破这种困境的方法——4P法； 最后我们一起运用4P法去进行公众演讲和建立人脉网。 现在让我们再来回顾一下4P法的用法： 准备：哪怕是一点点准备，都可以缓解紧张情绪； 展示：关注当下，给人留下正面印象； 推动：迈出第一步，你就成功了 90%； 练习：内向者只有不断练习，才能适应这个社会。 你不需要改变自己的性格，但你需要练习社交的技能，才能更好地发挥内向者的优势，适应这个以人际交往为主要驱动力的社会。 “你毕竟想知道， 自己在这个世界上能做些什么。” 我是鲤鲤，做着一个叫PickYou的小app，观察社交行为的方方面面。 · 月明 all right reserved，powered by Gitbook该文件最后修改时间： 2022-01-23 23:07:36 "}}